<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>seteuid0's blog</title><link>/</link><description>Recent content on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Sun, 18 Apr 2021 11:16:32 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>[zz]FireEye的成功之路</title><link>/posts/fireeye/</link><pubDate>Thu, 13 Feb 2014 00:49:09 +0000</pubDate><guid>/posts/fireeye/</guid><description>seteuid0's blog /posts/fireeye/ -&lt;p>现在说起FireEye，就会让人想起一个词: APT(Advanced Persistent Threat)，仅从这一点看，FireEye就成功了：创造了一个市场并成为这个市场的领导者，相对于Palo Alto Networks定义了NGFW，可以说是有过之而无不及。 但是，FireEye所经历的并不像我们想象的那么一帆风顺。自2006年创建，到2013年获得资本市场的认可和追捧后顺利IPO，这7年到底是怎杨一个过程，且让我们复盘来看看。 2007年前的FireEye可谓处境艰难，互联网上几乎听不到什么声音，只能看到其在2008年断断续续的写了三篇技术blog，内容主要是exploit的利用分析。 但是在2009年也许是获得了CIA的默许，主动发起了对Botnet的进攻：FireEye研究员Atif Mushtaq在长达两年后跟踪和逆向Mega-D Botnet后，成功识别了其协议并导致其C&amp;amp;C服务器下线。 这逆转了业界对FireEye的”Just another security startup”的印象，因为在严谨法律的美国的网络安全界，从来没有出现过像美国军方一样的“主动打击”事件，这也算是开了网络安全的主动攻击先例，后来的各个机构(Law Enforcement)主动攻击或DDoS黑客组织，似乎也就顺理成章。 2010年的FireEye，在各大IT公司间左右逢源，建立合作伙伴关系，与媒体的关系也更加融洽，在Malware分析和保护领域逐步站稳了脚步，对IE和PDF文件的重点分析是当年的亮点。 2011年，FireEye重点帮助市场和媒体理解Targeted Attack和APT攻击本身，及其危害，这其实就是赌这个细分领域会成为一个高速成长的市场。 2012年底，FireEye顺利拿到5000万美金融资，并迎来了重量级的CEO，前McAfee CEO，Dave DeWalt，也顺利补充了大批后来成为百万富翁的资深安全研究员，这些都为2013年顺利IPO奠定了资本市场的人脉基础。 个人看来，FireEye的成功是一个市场定位的成功，在其他厂商都看不上这块市场的时候，顺利转型并在APT防护领域异军突起，顺利达阵，这是一盘很大的棋，政府和资本的力量在其中比技术实力更重要，占据了天时，地利，人和，无法失败。 IPO之后，FireEye的股票也是单边一路上扬，大部分投资者现在都应该是赚的盆满钵满，至于其中是否有泡沫，似乎都不是那么重要了。这也许正是硅谷之美，不甘心平庸，参与创业，成则获取巨额财富，为后续创业或享受人生提供契机，败也是积累了经验，找一家重新再来。&lt;/p>
- /posts/fireeye/ - This is a customized copyright.</description></item><item><title>SELinux策略约束（constrain）里的L与H</title><link>/posts/selinux_constrain/</link><pubDate>Mon, 20 Jan 2014 06:57:10 +0000</pubDate><guid>/posts/selinux_constrain/</guid><description>seteuid0's blog /posts/selinux_constrain/ -&lt;p>在SELinux里，除了使用TE（type enforcement）来实现强制访问控制，还可以使用MLS机制的MCS或MLS。 MCS是single-sensitivity的安全机制，通过不同的categories来实现控制效果。 MCS的控制规则只能在base策略里面实现，如果想要修改refpolicy里的默认控制规则，可以修改策略里的mcs文件。MCS的基础内容如下：&lt;/p>
&lt;blockquote>
&lt;p>mlsconstrain dir { search read ioctl lock } (( h1 dom h2 ) or ( t1 != mcs_constrained_type )); mlsconstrain dir { write setattr append unlink link rename add_name remove_name } (( h1 dom h2 ) or ( t1 != mcs_constrained_type ));&lt;/p>
&lt;/blockquote>
&lt;p>里面的mlsconstrain是约束语法，dir{search &amp;hellip;.}是对应的客体类和权限集。后面的就是MCS约束的定义。分为T、L、H{1/2}，分别表示类型（type），低安全集（L）和高安全集（H），之后的1，或2描述该表达式所限定的主体与客体，即L1表示主体的低安全级，如果上下文system_u:system_r:httpd_t:s0-s0:c0.c1024中，L1就是s0。 在selinux里面，看上面MCS对dir的约束定义，大家可能会有一个疑虑，selinux都是默认对当前级别（low level）进行判断，策略里面怎么是对high level进行判断。 看了下selinux的内核代码才知道缘由。 在selinux进行inode_doinit_with_dentry的时候，security_context_to_sid_default会到用到mls_context_to_sid对mls部分的上下文进行处理。该函数后部分有如下代码&lt;/p>
&lt;blockquote>
&lt;p>if (l == 0) { context-&amp;gt;range.level[1].sens = context-&amp;gt;range.level[0].sens; rc = ebitmap_cpy(&amp;amp;context-&amp;gt;range.level[1].cat, &amp;amp;context-&amp;gt;range.level[0].cat); if (rc) goto out; }&lt;/p>
&lt;/blockquote>
&lt;p>即，如果只有low level的时候，high level的值按照low level的进行处理。 以上就是SELinux里面对MCS部分的控制。&lt;/p>
- /posts/selinux_constrain/ - This is a customized copyright.</description></item><item><title>编码版b374k实现分析</title><link>/posts/b374k/</link><pubDate>Fri, 10 Jan 2014 09:54:37 +0000</pubDate><guid>/posts/b374k/</guid><description>seteuid0's blog /posts/b374k/ -&lt;p>实验PHP+SELINUX的时候，使用B374k，发现PHP文件的上下文意外的发生了变化，Inode号却没有发生变化，审计日志里也找不到relabel相关信息，就想一探究竟。 看代码发现上下文变化的这个版本是代码进行了编码处理的，从google code里找到的那些没有编码处理的版本上下文不会发生变化，看来只能对解码处理。 第一层使用了简单的“.&amp;ldquo;符号把字符串进行了分割，将$b374k=@create_function('$x',&amp;lsquo;ev&amp;rsquo;.&amp;lsquo;al&amp;rsquo;.'(gz'.&amp;lsquo;inf&amp;rsquo;.&amp;lsquo;late&amp;rsquo;.'(bas'.&amp;lsquo;e64&amp;rsquo;.'_de'.&amp;lsquo;co&amp;rsquo;.&amp;lsquo;de($x)));');处理后就可以看到(gzinflate(base64_decode($x)))；使用这个函数把后面的解码就可以得到解密后的代码。将代码格式化处理下，可以看到前半部分还是编码后的代码，后半部分有一些功能代码。&lt;/p>
&lt;blockquote>
&lt;p>eval(gzinflate(base64_decode($x7774cacf))); rebirth(); eval(gzinflate(base64_decode(hate($xc3a649b2,$xec8e9aa2))));&lt;/p>
&lt;/blockquote>
&lt;p>同样，去掉eval，通过gzinflate(base64_decode($x7774cacf))解码，得到上面的功能代码，将解码后的内容格式化可以得到&lt;/p>
&lt;blockquote>
&lt;!-- raw HTML omitted -->
&lt;/blockquote>
&lt;p>里面是基础的编码、解码、生成随机数功能函数，可以注意到里面的rebirth函数，该函数将该PHP文件重新编码后替换当前的PHP文件。而随后的代码便调用了rebirth()函数，实现了这个webshell的rebirth。 而eval(gzinflate(base64_decode(hate($xc3a649b2,$xec8e9aa2))));就是执行本次请求的功能。可以找一个文件将该解码后的内容拷贝进去进行验证，功能与预期一致。 目前知道了上下文改变是由于用新生成的文件替换了之前的老文件，但是为什么inode号会保持一致？对该文件进行审计,将日志处理后可以看到。&lt;/p>
&lt;blockquote>
&lt;p>syscall=4 ppid=2563 pid=2617 syscall=2 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13403 syscall=21 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13403 syscall=87 ppid=2563 pid=13403 syscall=82 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13404 syscall=2 ppid=2563 pid=13405 syscall=2 ppid=2563 pid=13405 syscall=2 ppid=2563 pid=13404 syscall=87 ppid=2563 pid=13405 syscall=82 ppid=2563 pid=13405 syscall=87 ppid=2563 pid=13404 syscall=82 ppid=2563 pid=13404 syscall=2 ppid=2563 pid=13406 syscall=2 ppid=2563 pid=13406 syscall=87 ppid=2563 pid=13406 syscall=82 ppid=2563 pid=13406 syscall=2 ppid=2563 pid=13407 syscall=2 ppid=2563 pid=13407 syscall=87 ppid=2563 pid=13407 syscall=82 ppid=2563 pid=13407&lt;/p>
&lt;/blockquote>
&lt;p>应该是apache多次解析了这个文件，进行了多次的unlink与rename操作。会不会是inode号重用呢，看如下实验：&lt;/p>
&lt;blockquote>
&lt;p>$ touch inode $ ls -i inode 1048641 inode $ rm inode $ touch inode $ ls -i inode 1048641 inode $&lt;/p>
&lt;/blockquote>
&lt;p>到此可以明白只有上下文和文件内容发生变化的原因。 通过php直接执行测试发现，由于只执行了一次，所以inode号也随着发生了变化。 遗留问题：目前还无法确知为什么多次解析了这个PHP文件。&lt;/p>
- /posts/b374k/ - This is a customized copyright.</description></item><item><title>Apparmor的前世今生</title><link>/posts/apparmor_info/</link><pubDate>Wed, 01 Jan 2014 14:51:44 +0000</pubDate><guid>/posts/apparmor_info/</guid><description>seteuid0's blog /posts/apparmor_info/ -&lt;p>Apparmor是linux下安全机制的一种，使用LSM（Linux security modules），在2.6.36进入内核。以下介绍下Apparmor项目的发展历程。 1998～2003时，Apparmor在Immunix Linux中使用，当时名称是Subdomain。2005年5月10日，Immunix作为Novell的长期合作伙伴，被Novell收购，其中Apparmor是Novell的主要关注重点，而且被命名为Novell Apparmor。从2005年到2007年9月由Novell进行维护。2007年4月，Ubuntu进入Apparmor，进入Ubuntu 7.10包，作为Ubuntu8.04的一部分发布。 2007年9月，Novell将维护Apparmor的团队解散了。而Suse也在OpenSUSE11.1中引入了对SELinux的支持。作为Apparmor的founder和leader，Crispin Cowan和其他四个同事丢掉了在Novell的工作，当时Crispin表示会继续Apparmor的开发，他和其他2个同事Steve Beattie和Dominic Reynolds开办了Mercenary Linux公司，专注于Apparmor咨询工作。好景不长，2008年8月，有人发出了Apparmor is Dead的博文，引发讨论。随后 Crispin Cowan也在2008年加入了Windows Security Team。 从2009年开始，Canonical开始开发apparmor。现在的Maintainer是John Johansen &lt;a href="mailto:john.johansen@canonical.com">john.johansen@canonical.com&lt;/a>   参考资料： 1、blogs.msdn.com/b/michael_howard/archive/2008/01/17/crispin-cowan-joins-the-windows-security-team.aspx 2、en.wikipedia.org/wiki/Immunix 3、news.cnet.com/8301-13580_3-9796140-39.html 4、etbe.coker.com.au/2008/08/23/apparmor-is-dead/ 5、&lt;a href="http://en.wikipedia.org/wiki/AppArmor">http://en.wikipedia.org/wiki/AppArmor&lt;/a>&lt;/p>
- /posts/apparmor_info/ - This is a customized copyright.</description></item><item><title>开发PHP扩展（extension)或模块(module)简介</title><link>/posts/php_extension/</link><pubDate>Tue, 31 Dec 2013 02:17:57 +0000</pubDate><guid>/posts/php_extension/</guid><description>seteuid0's blog /posts/php_extension/ -&lt;p>PHP的插件分为两种:PHP extensions 和Zend Extensions.其中PHP extensions 被当作modules，而Zend extensions被当作extensions.这两个的主要差异在于Engine中注册了不同的钩子。（当然在插件代码编写和使用的配置文件中也存在一定差异，这是后话）&lt;/p>
&lt;h3 id="环境搭建">环境搭建&lt;/h3>
&lt;p>首先需要搭建基础的php环境，我采用Fedora自带的库，然后下载系统对应的rpm源码包编译后使用，这样就可以保证和系统自带版本一致。&lt;/p>
&lt;blockquote>
&lt;p>yundownload &amp;ndash;source php rpm -ivh php-*.src.rpm Cd ~/rpmbuild/SPEC/ rpmbuild -ba php.spec&lt;/p>
&lt;/blockquote>
&lt;p>这样就有了php的源码环境。&lt;/p>
&lt;h3 id="代码编写">代码编写&lt;/h3>
&lt;p>开发PHP插件可以使用源码中的ext_skel快速的生成框架代码，只需要简单的修改框架代码就可以生成一个可用的PHP插件。 最简单的使用模式就是 Php_src/ext/ext_skel &amp;ndash;extname=module 执行后生成了由你制定的module关联的几个文件，module.c和php_module.h,以及config.m4工程配置文件 对应的修改这几个文件就可以了。 如果是要开发zend_extension则记得添加如下内容&lt;/p>
&lt;blockquote>
&lt;p>/* This is a Zend  extension */ #ifndef ZEND_EXT_API #define ZEND_EXT_API    ZEND_DLEXPORT #endif ZEND_EXTENSION(); ZEND_DLEXPORT zend_extension zend_extension_entry = {&lt;/p>
&lt;/blockquote>
&lt;h3 id="编译测试">编译测试&lt;/h3>
&lt;p>编译测试： 执行phpize生成configure文件 然后执行./configure和make 将module目录下的so文件拷贝到你要的目录，然后配置一个php配置文件 添加extension=path/module_name.so,如果是zend extensions，则是 Zend_extension=path/module_name.so 这样，就可以开始你的调试之旅了。&lt;/p>
- /posts/php_extension/ - This is a customized copyright.</description></item><item><title>Fedora20上安装wps</title><link>/posts/fedora20_wps/</link><pubDate>Sat, 28 Dec 2013 08:26:49 +0000</pubDate><guid>/posts/fedora20_wps/</guid><description>seteuid0's blog /posts/fedora20_wps/ -&lt;p>日常使用难免需要用到处理文档，以下介绍如何在feodra20类似的系统上安装wps&lt;/p>
&lt;ol>
&lt;li>下载最新版本的wps linux版本&lt;/li>
&lt;li>可以从http://community.wps.cn/download/中下载。&lt;/li>
&lt;/ol>
&lt;p>例如wget &lt;a href="http://wdl1.cache.wps.cn/wps/download/Linux/unstable/kingsoft-office-9.1.0.4244-0.1.a12p3.i686.rpm">http://wdl1.cache.wps.cn/wps/download/Linux/unstable/kingsoft-office-9.1.0.4244-0.1.a12p3.i686.rpm&lt;/a> 3. 使用yum安装该rpm包（当然可以不下载，直接使用网络地址安装） sudo yum install kingsoft-office-9.1.0.4244-0.1.a12p3.i686.rpm 4.下载font文件，可以使用&lt;a href="http://pan.baidu.com/share/link?shareid=3371036765&amp;amp;uk=505215462">http://pan.baidu.com/share/link?shareid=3371036765&amp;amp;uk=505215462&lt;/a> rpm2cpio ../symbol-fonts-1.2-1.noarch.rpm |cpio -dium sudo cp -r usr/share/fonts/symbol-fonts/ /usr/share/fonts/ （详情参见&lt;a href="http://linuxsec.net/?p=78">http://linuxsec.net/?p=78&lt;/a>） 可以了，开始使用吧。&lt;/p>
- /posts/fedora20_wps/ - This is a customized copyright.</description></item><item><title>About</title><link>/posts/about/</link><pubDate>Mon, 16 Dec 2013 14:05:56 +0000</pubDate><guid>/posts/about/</guid><description>seteuid0's blog /posts/about/ -&lt;p>Linux、虚拟化、云计算、系统安全爱好者 在此希望和大家分享、交流Linux、虚拟化、云计算、security相关内容。 同时也欢迎大家提供其他有意思的内容。&lt;/p>
- /posts/about/ - This is a customized copyright.</description></item><item><title>主机名bogon问题</title><link>/posts/host_name_bogon_problem/</link><pubDate>Wed, 04 Dec 2013 16:13:00 +0000</pubDate><guid>/posts/host_name_bogon_problem/</guid><description>seteuid0's blog /posts/host_name_bogon_problem/ -&lt;p>有时会发现主机名变成bogon了，偶然用nslookup发现了原因 172.16.141.139Server:61.234.254.5Address:61.234.254.5#53Non-authoritative answer:139.141.16.172.in-addr.arpaname = bogon.Authoritative answers can be found from:16.172.in-addr.arpanameserver = localhost.localhostinternet address = 127.0.0.1localhosthas AAAA address ::1&amp;gt;&lt;/p>
- /posts/host_name_bogon_problem/ - This is a customized copyright.</description></item><item><title>sudo对selinux的支持及用法</title><link>/posts/sudo_for_selinux_support_and_usage/</link><pubDate>Mon, 02 Dec 2013 02:42:00 +0000</pubDate><guid>/posts/sudo_for_selinux_support_and_usage/</guid><description>seteuid0's blog /posts/sudo_for_selinux_support_and_usage/ -&lt;p>sudo已经主持selinux，这样就可以在切换uid的同时切换上下文。实现的方式大致如下：再selinux.c的文件里面，提到了借鉴newrole的代码， 实验创建test用户 semanage login -a -s staff_u test修改sudoers文件，test    ALL=(ALL)       ROLE=sysadm_r TYPE=sysadm_t ALL然后使用test用户登陆,在执行sudo -Es后便转换上下文&lt;/p>
- /posts/sudo_for_selinux_support_and_usage/ - This is a customized copyright.</description></item><item><title>Fedora20启用wayland</title><link>/posts/fedora20_enable_wayland/</link><pubDate>Sat, 30 Nov 2013 10:10:00 +0000</pubDate><guid>/posts/fedora20_enable_wayland/</guid><description>seteuid0's blog /posts/fedora20_enable_wayland/ -&lt;p>wayland开发正如火如荼，不久的将来就会代替现在的x，好奇就再f20上实验了以下，方法如下：更新xorg-x11-server,xorg-x11-drv-intel 和mutter-wayland然后有2中方法启用：1、在一个虚拟终端执行“mutter-wayland &amp;ndash;wayland&amp;quot;2、切换到控制台，登陆有执行,gnome-session &amp;ndash;session=gnome-wayland现在当然还有一些bug，而且只支持intel的显卡？毕竟还没有开发完成。。。&lt;/p>
- /posts/fedora20_enable_wayland/ - This is a customized copyright.</description></item></channel></rss>