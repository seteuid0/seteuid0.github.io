<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>seteuid0's blog</title><link>/</link><description>Recent content on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Sun, 18 Apr 2021 11:16:32 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>vmware安装Centos7虚拟机网络不识别解决方案</title><link>/posts/vmware_centos7_network/</link><pubDate>Thu, 30 Jul 2015 07:23:30 +0000</pubDate><guid>/posts/vmware_centos7_network/</guid><description>seteuid0's blog /posts/vmware_centos7_network/ -&lt;p>今天使用vmware安装centos 7虚拟机，安装完毕以后发现网络无法识别。 通过lspci发现网卡没有加载驱动，猜测可能是由于centos 7默认的内核没有编译该虚拟网卡的驱动。 因此，想到通过如下方式解决，经验证，可以解决问题。 编辑虚拟机的*.vmx文件，添加ethernet0.virtualDev = &amp;ldquo;e1000&amp;rdquo;，把该虚拟机的网卡设定成e1000。再开机验证，发现网路正常。 此外还有一个方法，就是修改guest os的类型，在安装的时候就选择centos，或者同样通过修改配置文件完成。 guestOS = &amp;ldquo;centos&amp;rdquo;&lt;/p>
- /posts/vmware_centos7_network/ - This is a customized copyright.</description></item><item><title>[zz]Debian / Ubuntu tasksel: Install Group Software (tasks) such As DNS / Web Server In A Single Click</title><link>/posts/zzdebian-ubuntu-tasksel-install-group-software-tasks-such-as-dns-web-server-in-a-single-click/</link><pubDate>Mon, 15 Jun 2015 14:53:19 +0000</pubDate><guid>/posts/zzdebian-ubuntu-tasksel-install-group-software-tasks-such-as-dns-web-server-in-a-single-click/</guid><description>seteuid0's blog /posts/zzdebian-ubuntu-tasksel-install-group-software-tasks-such-as-dns-web-server-in-a-single-click/ -&lt;p>&amp;rsquo;m looking for &amp;lsquo;&lt;a href="http://www.cyberciti.biz/faq/rhel-centos-fedora-linux-yum-command-howto/" title="yum command: Update / Install Packages under Redhat Enterprise / CentOS Linux Version 5.x">yum groupinstall group&lt;/a>&amp;rsquo; like command under Debian or Ubuntu Linux. How do I install group of softwares such as DNS or LAMP server in a single command? You need to use tasksel command. It is a software installation application that is an integral part of the Debian installer and works under Ubuntu Linux too. It groups some packages by tasks and offers the user an easy way to install the packages for that task. It provides the same functionality as using conventional meta-packages.&lt;/p>
&lt;h2 id="how-do-i-use-tasksel">How do I use tasksel?&lt;/h2>
&lt;p>tasksel has been included as part of the base installation under both Debian and Ubuntu Linux (since Ubuntu Edgy). tasksel shows all available tasks and allows to user to select ones to install. Simply type tasksel as root user at a shell prompt: &lt;code>$ sudo tasksel&lt;/code> OR &lt;code># tasksel&lt;/code> You will see software selection menu as follows: &lt;img src="http://s0.cyberciti.org/uploads/faq//2009/02/debian-tasksel-command.png" alt="Fig.01: Debian Linux tasksel command in action" title="Fig.01: Debian Linux tasksel command in action"> &lt;img src="http://s0.cyberciti.org/uploads/faq/2009/02/ubuntu-tasksel-command.png" alt="Fig.02: Ubuntu Linux tasksel command in action" title="Fig.02: Ubuntu Linux tasksel command in action"> Select required group by pressing space bar followed by OK button.&lt;/p>
&lt;h3 id="how-do-i-list-available-groups-from-a-command-prompt">How do I list available groups from a command prompt?&lt;/h3>
&lt;p>The option &amp;ndash;list-tasks list on screen the tasks (packages) that would be displayed in the tasksel TUI (text user interface). You can use it as follows: &lt;code>$ tasksel --list-tasks&lt;/code> Sample output:&lt;code>u server Basic Ubuntu server u dns-server DNS server u edubuntu-server Edubuntu server i lamp-server LAMP server u mail-server Mail server i openssh-server OpenSSH server u postgresql-server PostgreSQL database i print-server Print server i samba-server Samba file server u tomcat-server Tomcat Java server u virt-host Virtual Machine host u ubuntustudio-graphics 2D/3D creation and editing suite u ubuntustudio-audio Audio creation and editing suite u edubuntu-desktop-kde Edubuntu KDE desktop u edubuntu-desktop-addon Edubuntu desktop u kubuntu-desktop Kubuntu desktop u ubuntustudio-audio-plugins LADSPA and DSSI audio plugins u mythbuntu-desktop Mythbuntu additional roles u mythbuntu-frontend Mythbuntu frontend u mythbuntu-backend-master Mythbuntu master backend u mythbuntu-backend-slave Mythbuntu slave backend u mobile-mid Ubuntu MID edition u ubuntustudio-desktop Ubuntu Studio desktop (must install) i ubuntu-desktop Ubuntu desktop u mobile-mobile Ubuntu mobile u ubuntustudio-video Video creation and editing suite u xubuntu-desktop Xubuntu desktop u edubuntu-live Edubuntu live CD u kubuntu-kde4-live Kubuntu live CD u kubuntu-live Kubuntu live CD u kubuntu-dvd-live Kubuntu live DVD u mythbuntu-live Mythbuntu live CD u ubuntu-live Ubuntu live CD u ubuntu-dvd-live Ubuntu live DVD u xubuntu-live Xubuntu live CD&lt;/code>The &amp;ndash;task-desc task option displays the extended description of the given task: &lt;code>$ tasksel --task-desc virt-host&lt;/code> Sample output:```
Packages necessary to host virtual machines&lt;/p>
&lt;pre>&lt;code>
### How do I install package group (tasks) from a command line?
To install lamp-server, enter: `$ sudo apt-get install lamp-server^` And yes, you CANOT forgot the caret (^) symbol. You need to put ^ at the end of package name; otherwise it will give an error which read as follows:```
E: Couldn't find package lamp-server
&lt;/code>&lt;/pre>&lt;h5 id="further-readings">Further readings:&lt;/h5>
&lt;p>Read tasksel man page for more info: &lt;code>man tasksel&lt;/code>&lt;/p>
- /posts/zzdebian-ubuntu-tasksel-install-group-software-tasks-such-as-dns-web-server-in-a-single-click/ - This is a customized copyright.</description></item><item><title>linux-3.19下运行vmware解决方案</title><link>/posts/linux-3-19-vmware-vmnet-error/</link><pubDate>Thu, 30 Apr 2015 02:32:59 +0000</pubDate><guid>/posts/linux-3-19-vmware-vmnet-error/</guid><description>seteuid0's blog /posts/linux-3-19-vmware-vmnet-error/ -&lt;p>由于linux3.19内核升级导致接口变化，vmnet无法编译通过。解决办法如下，可以把附件的&lt;a href="http://linuxsec.net/wp-content/uploads/2015/04/vmnet.tar">vmnet&lt;/a>替换掉原来的，即可使用。下载后执行：```
cp vmnet.tar /usr/lib/vmware/modules/source/vmnet.tar&lt;/p>
&lt;pre>&lt;code class="language- " data-lang=" ">&lt;/code>&lt;/pre>- /posts/linux-3-19-vmware-vmnet-error/ - This is a customized copyright.</description></item><item><title>[转]U-boot 之TFTP服务器配置</title><link>/posts/u-boot-tftp-server-config/</link><pubDate>Wed, 15 Apr 2015 16:27:38 +0000</pubDate><guid>/posts/u-boot-tftp-server-config/</guid><description>seteuid0's blog /posts/u-boot-tftp-server-config/ -&lt;p>一.PC端配置 1.关闭防火墙 [root@gliethttp root]# /etc/init.d/iptables stop 2.使用setup启动tftp [root@gliethttp root]# setup -&amp;gt;System services-&amp;gt;选中tftp 3.如果setup中找不到tftp选项，那么你需要rpm包来安装 在redhat9的CD3里可以找到tftp-server-0.32-4.i386.rpm文件 [root@gliethttp root]# rpm -ivh tftp-server-0.32-4.i386.rpm 4.修改tftp服务器配置 [root@gliethttp root]# vim /etc/xinetd.d/tftp 将server_args配置项为你自己的tftpboot根目录 将disable 配置为no service tftp { socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /tftpboot disable = no per_source = 11 cps = 100 2 flags = IPv4 } 5.启动tftp服务器 [root@gliethttp root]# /etc/init.d/xinetd restart 6.下载文件准备 [root@gliethttp root]# mkdir /tftpboot [root@gliethttp root]# cp usb1-uImage /tftpboot ；拷贝预下载的内核文件到/tftpboot目录下 [root@gliethttp root]# cp minigui9200.gz /tftpboot ；将ramdisk拷贝到/tftpboot目录下 二.ARM板端配置 重启开发板进入uBoot 1.设置tftp的ip地址和服务器地址 FFTUBoot &amp;gt; printenv ；打印当前环境配置 FFTUBoot &amp;gt; setenv ethaddr 12:34:56:78:99:aa ；MAC 地址设置 FFTUBoot &amp;gt; setenv ipaddr 192.168.23.250（缺省192.168.0.11） ；目标板IP 地址 FFTUBoot &amp;gt; setenv serverip 192.168.23.23（缺省192.168.0.55） ；服务器IP 地址 FFTUBoot &amp;gt; setenv bootdelay 5 ；延时 FFTUBoot &amp;gt; saveenv ；可以进行保存，如果不保存，掉电后需要重新设置 2.启动参数设置 FFTUBoot &amp;gt; setenv bootargs root=/dev/ram rw initrd=0x21100000,6000000 ramdisk_size=15360 console=ttyS0,115200 mem=32M FFTUBoot &amp;gt; saveenv 3.下载文件 FFTUBoot &amp;gt; tftp 21000000 usb1-uImage ；下载内核 FFTUBoot &amp;gt; tftp 21100000 minigui9200.gz ；下载文件系统 FFTUBoot &amp;gt; bootm 21000000 ；开始运行 或者直接 FFTUBoot &amp;gt; tftp 21000000 usb1-uImage;tftp 21100000 minigui9200.gz;bootm 21000000 （注： 如果正在进行内核和ramdisk开发，那么最好进行如下设置： FFTUBoot &amp;gt; setenv bootcmd tftp 21000000 usb1-uImage/;tftp 21100000 minigui9200.gz/;bootm 21000000 FFTUBoot &amp;gt; saveenv 这样每次将板子复位后，内核和ramdisk都会通过tftp自动装载运行。 如果只对内核开发，那么可以先将ramdisk烧到flash中 FFTUBoot &amp;gt; tftp 20000000 minigui9200.gz FFTUBoot &amp;gt; cp.b 20000000 10200000 文件系统大小 然后设置自启动参数 FFTUBoot &amp;gt; setenv bootcmd tftp 21000000 usb1-uImage/;cp.b 10200000 21100000 文件系统大小/;bootm 21000000 FFTUBoot &amp;gt; saveenv 如果只对ramdisk开发，那么可以先将kernel烧到flash中 FFTUBoot &amp;gt; tftp 20000000 usb1-uimage FFTUBoot &amp;gt; cp.b 20000000 10060000 内核影象大小 然后设置自启动参数 FFTUBoot &amp;gt; setenv bootcmd tftp 21100000 minigui9200.gz/;bootm 10060000 FFTUBoot &amp;gt; saveenv ） 4.烧写内核到flash(0x10060000) FFTUBoot &amp;gt; tftp 20000000 usb1-uimage FFTUBoot &amp;gt; cp.b 20000000 10060000 内核影象大小 5.烧写ramdisk到flash(0x10200000) FFTUBoot &amp;gt; tftp 20000000 minigui9200.gz FFTUBoot &amp;gt; cp.b 20000000 10200000 文件系统大小 6.设置flash启动环境 FFTUBoot &amp;gt; setenv bootargs root=/dev/ram rw initrd=0x21100000,6000000 ramdisk_size=15360 console=ttyS0,115200 mem=32M FFTUBoot &amp;gt; setenv bootcmd cp.b 10200000 21100000 文件系统大小/;bootm 10060000 ；uBoot将存储在10060000压缩内核解压到20008000处 FFTUBoot &amp;gt; saveenv&lt;/p>
- /posts/u-boot-tftp-server-config/ - This is a customized copyright.</description></item><item><title>串口登陆类ubuntu系统设置方法</title><link>/posts/serail_console_login_ubuntu_howto/</link><pubDate>Tue, 24 Mar 2015 16:22:51 +0000</pubDate><guid>/posts/serail_console_login_ubuntu_howto/</guid><description>seteuid0's blog /posts/serail_console_login_ubuntu_howto/ -&lt;p>在调试嵌入式等设备的时候，难免需要使用串口来登陆系统，ubuntu模式配置是没有启用串口登陆的，以下将简要介绍如何开启串口登陆。 在较高（12.04以后？）中，基于upstart的启动环境中使用/etc/init下面创建的启动脚本。如tty0～tty7都有相关的配置文件tty[0&amp;hellip;7].conf。如果需要启用串口登陆，只需要对应的创建一个新的文件，例如你使用的串口是ttyS0,则新建ttyS0.conf文件。 填写如下内容到该配置文件(注意里面的115200即串口的波特率。```
# ttyS0 - getty&lt;/p>
&lt;h1 id="heading">&lt;/h1>
&lt;h1 id="this-service-maintains-a-getty-on-ttys0-from-the-point-the-system-is">This service maintains a getty on ttyS0 from the point the system is&lt;/h1>
&lt;h1 id="started-until-it-is-shut-down-again">started until it is shut down again.&lt;/h1>
&lt;p>start on stopped rc or RUNLEVEL=[12345]
stop on runlevel [!12345]&lt;/p>
&lt;p>respawn
exec /sbin/getty -L 115200 ttyS0 vt102
&lt;code>这样连接串口重新启动进行验证吧，当然也可以不重启，通过执行以下命令实现：&lt;/code>
sudo start ttyS0&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>- /posts/serail_console_login_ubuntu_howto/ - This is a customized copyright.</description></item><item><title>[ZZ]Device Tree（一）：背景介绍 为什么引入dtb</title><link>/posts/dtb1/</link><pubDate>Mon, 23 Mar 2015 02:44:42 +0000</pubDate><guid>/posts/dtb1/</guid><description>seteuid0's blog /posts/dtb1/ -&lt;p>作者：&lt;a href="http://www.wowotech.net/author/3">linuxer&lt;/a> 发布于：2014-5-22 16:46 分类：&lt;a href="http://www.wowotech.net/sort/device_model">统一设备模型&lt;/a>&lt;/p>
&lt;p>一、前言 作为一个多年耕耘在linux 2.6.23内核的开发者，各个不同项目中各种不同周边外设驱动的开发以及各种琐碎的、扯皮的俗务占据了大部分的时间。当有机会下载3.14的内核并准备学习的时候，突然发现linux kernel对于我似乎变得非常的陌生了，各种新的机制，各种framework、各种新的概念让我感到阅读内核代码变得举步维艰。 还好，剖析内核的热情还在，剩下的就交给时间的。首先进入视线的是Device Tree机制，这是和porting内核非常相关的机制，如果想让将我们的硬件平台迁移到高版本的内核上，Device Tree是一个必须要扫清的障碍。 我想从下面三个方面来了解Device Tree： 1、为何要引入Device Tree，这个机制是用来解决什么问题的？（这是本文的主题） 2、Device Tree的基础概念（请参考&lt;a href="http://www.wowotech.net/linux_kenrel/dt_basic_concept.html">DT基础概念&lt;/a>） 3、ARM linux中和Device Tree相关的代码分析（请参考&lt;a href="http://www.wowotech.net/linux_kenrel/dt-code-analysis.html">DT代码分析&lt;/a>） 阅读linux内核代码就像欣赏冰山，有看得到的美景（各种内核机制及其代码），也有埋在水面之下看不到的基础（机制背后的源由和目的）。沉醉于各种内核机制的代码固然有无限乐趣，但更重要的是注入更多的思考，思考其背后的机理，真正理解软件抽象。这样才能举一反三，并应用在具体的工作和生活中。 本文主要从下面几个方面阐述为何ARM linux会引入Device Tree： 1、没有Device Tree的ARM linux是如何运转的？ 2、混乱的ARM architecture代码和存在的问题 3、新内核的解决之道   二、没有Device Tree的ARM linux是如何运转的？ 我曾经porting内核到两个ARM-based的平台上。一个是小的芯片公司的应用处理器，公司自己购买了CPU core，该CPU core使用ARM兼容的指令集（但不是ARM）加上各种公司自行设计的多媒体外设整合成公司的产品进行销售。而我的任务就是porting 2.4.18内核到该平台上。在黑白屏幕的手机时代，那颗AP（application process）支持了彩屏、camera、JPEG硬件加速、2D/3D加速、MMC/SD卡、各种音频加速（内置DSP）等等特性，功能强大到无法直视。另外一次移植经历是让2.6.23内核跑在一个大公司的冷门BP（baseband processor）上。具体porting的方法是很简单的： 1、自己撰写一个bootloader并传递适当的参数给kernel。除了传统的command line以及tag list之类的，最重要的是申请一个machine type，当拿到属于自己项目的machine type ID的时候，当时心情雀跃，似乎自己已经是开源社区的一份子了（其实当时是有意愿，或者说有目标是想将大家的代码并入到linux kernel main line的）。 2、在内核的arch/arm目录下建立mach-xxx目录，这个目录下，放入该SOC的相关代码，例如中断controller的代码，时间相关的代码，内存映射，睡眠相关的代码等等。此外，最重要的是建立一个board specific文件，定义一个machine的宏：&lt;/p>
&lt;blockquote>
&lt;p>MACHINE_START(project name, &amp;ldquo;xxx公司的xxx硬件平台&amp;rdquo;) .phys_io    = 0x40000000, .boot_params    = 0xa0000100, .io_pg_offst    = (io_p2v(0x40000000) &amp;raquo; 18) &amp;amp; 0xfffc, .map_io        = xxx_map_io, .init_irq    = xxx_init_irq, .timer        = &amp;amp;xxx_timer, .init_machine    = xxx_init, MACHINE_END&lt;/p>
&lt;/blockquote>
&lt;p>在xxx_init函数中，一般会加入很多的platform device。因此，伴随这个board specific文件中是大量的静态table，描述了各种硬件设备信息。 3、调通了system level的driver（timer，中断处理，clock等）以及串口terminal之后，linux kernel基本是可以起来了，后续各种driver不断的添加，直到系统软件支持所有的硬件。 综上所述，在linux kernel中支持一个SOC平台其实是非常简单的，让linux kernel在一个特定的平台上“跑”起来也是非常简单的，问题的重点是如何优雅的”跑”。   三、混乱的ARM architecture代码和存在的问题 每次正式的linux kernel release之后都会有两周的merge window，在这个窗口期间，kernel各个部分的维护者都会提交各自的patch，将自己测试稳定的代码请求并入kernel main line。每到这个时候，Linus就会比较繁忙，他需要从各个内核维护者的分支上取得最新代码并merge到自己的kernel source tree中。Tony Lindgren，内核OMAP development tree的维护者，发送了一个邮件给Linus，请求提交OMAP平台代码修改，并给出了一些细节描述： 1、简单介绍本次改动 2、关于如何解决merge conficts。有些git mergetool就可以处理，不能处理的，给出了详细介绍和解决方案 一切都很平常，也给出了足够的信息，然而，正是这个pull request引发了一场针对ARM linux的内核代码的争论。我相信Linus一定是对ARM相关的代码早就不爽了，ARM的merge工作量较大倒在其次，主要是他认为ARM很多的代码都是垃圾，代码里面有若干愚蠢的table，而多个人在维护这个table，从而导致了冲突。因此，在处理完OMAP的pull request之后（Linus并非针对OMAP平台，只是Tony Lindgren撞在枪口上了），他发出了怒吼：&lt;/p>
&lt;blockquote>
&lt;pre>&lt;code>Gaah. Guys, this whole ARM thing is a f\*cking pain in the ass.
&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>负责ARM linux开发的Russell King脸上挂不住，进行了反驳：事情没有那么严重，这次的merge conficts就是OMAP和IMX/MXC之间一点协调的问题，不能抹杀整个ARM linux团队的努力。其他的各个ARM平台维护者也加入讨论：ARM平台如何复杂，如何庞大，对于arm linux code我们已经有一些思考，正在进行中……一时间，讨论的气氛有些尖锐，但总体是坦诚和友好的。 对于一件事情，不同层次的人有不同层次的思考。这次争论涉及的人包括： 1、内核维护者（CPU体系结构无关的代码） 2、维护ARM系统结构代码的人 3、维护ARM sub architecture的人（来自各个ARM SOC vendor） 维护ARM sub architecture的人并没有强烈的使命感，作为公司的一员，他们最大的目标是以最快的速度支持自己公司的SOC，尽快的占领市场。这些人的软件功力未必强，对linux kernel的理解未必深入（有些人可能很强，但是人在江湖身不由己）。在这样的情况下，很多SOC specific的代码都是通过copy and paste，然后稍加修改代码就提交了。此外，各个ARM vendor的SOC family是一长串的CPU list，每个CPU多多少少有些不同，这时候＃ifdef就充斥了各个源代码中，让ARM mach-和plat-目录下的代码有些不忍直视。 作为维护ARM体系结构的人，其能力不容置疑。以Russell King为首的team很好的维护了ARM体系结构的代码。基本上，除了mach-和plat-目录，其他的目录中的代码和目录组织是很好的。作为ARM linux的维护者，维护一个不断有新的SOC加入的CPU architecture code的确是一个挑战。在Intel X86的架构一统天下的时候，任何想正面攻击Intel的对手都败下阵来。想要击倒巨人（或者说想要和巨人并存）必须另辟蹊径。ARM的策略有两个，一个是focus在嵌入式应用上，也就意味着要求低功耗，同时也避免了和Intel的正面对抗。另外一个就是博采众家之长，采用license IP的方式，让更多的厂商加入ARM建立的生态系统。毫无疑问，ARM公司是成功的，但是这种模式也给ARM linux的维护者带来了噩梦。越来越多的芯片厂商加入ARM阵营，越来越多的ARM platform相关的代码被加入到内核，不同厂商的周边HW block设计又各不相同…… 内核维护者是真正对操作系统内核软件有深入理解的人，他们往往能站在更高的层次上去观察问题，发现问题。Linus注意到每次merge window中，ARM的代码变化大约占整个ARCH目录的60％，他认为这是一个很明显的符号，意味着ARM linux的代码可能存在问题。其实，60％这个比率的确很夸张，因为unicore32是在2.6.39 merge window中第一次全新提交，它的代码是全新的，但是其代码变化大约占整个ARCH目录的9.6％（需要提及的是unicore32是一个中国芯）。有些维护ARM linux的人认为这是CPU市场占用率的体现，不是问题，直到内核维护者贴出实际的代码并指出问题所在。内核维护者当然想linux kernel支持更多的硬件平台，但是他们更愿意为linux kernel制定更长远的规划。例如：对于各种繁杂的ARM平台，用一个kernel image来支持。 经过争论，确定的问题如下： 1、ARM linux缺少platform（各个ARM sub architecture，或者说各个SOC）之间的协调，导致arm linux的代码有重复。值得一提的是在本次争论之前，ARM维护者已经进行了不少相关的工作（例如PM和clock tree）来抽象相同的功能模块。 2、ARM linux中大量的board specific的源代码应该踢出kernel，否则这些垃圾代码和table会影响linux kernel的长期目标。 3、各个sub architecture的维护者直接提交给Linux并入主线的机制缺乏层次。   四、新内核的解决之道 针对ARM linux的现状，最需要解决的是人员问题，也就是如何整合ARM sub architecture（各个ARM Vendor）的资源。因此，内核社区成立了一个ARM sub architecture的team，该team主要负责协调各个ARM厂商的代码（not ARM core part），Russell King继续负责ARM core part的代码。此外，建立一个ARM platform consolidation tree。ARM sub architecture team负责review各个sub architecture维护者提交的代码，并在ARM platform consolidation tree上维护。在下一个merge window到来的时候，将patch发送给Linus。 针对重复的代码问题，如果不同的SOC使用了相同的IP block（例如I2C controller），那么这个driver的code要从各个arch/arm/mach-xxx中独立出来，变成一个通用的模块供各个SOC specific的模块使用。移动到哪个目录呢？对于I2C或者USB OTG而言，这些HW block的驱动当然应该移动到kernel/drivers目录。因为，对于这些外设，可能是in-chip，也可能是off-chip的，但是对于软件而言，它们是没有差别的（或者说好的软件抽象应该掩盖底层硬件的不同）。对于那些system level的code呢？例如clock control、interrupt control。其实这些也不是ARM-specific，应该属于linux kernel的核心代码，应该放到linux/kernel目录下，属于core-Linux-kernel frameworks。当然对于ARM平台，也需要保存一些和framework交互的code，这些code叫做ARM SoC core architecture code。OK，总结一下： 1、ARM的核心代码仍然保存在arch/arm目录下 2、ARM SoC core architecture code保存在arch/arm目录下 3、ARM SOC的周边外设模块的驱动保存在drivers目录下 4、ARM SOC的特定代码在arch/arm/mach-xxx目录下 5、ARM SOC board specific的代码被移除，由Device Tree机制来负责传递硬件拓扑和硬件资源信息。 OK，终于来到了Device Tree了。本质上，Device Tree改变了原来用hardcode方式将HW 配置信息嵌入到内核代码的方法，改用bootloader传递一个DB的形式。对于基于ARM CPU的嵌入式系统，我们习惯于针对每一个platform进行内核的编译。但是随着ARM在消费类电子上的广泛应用（甚至桌面系统、服务器系统），我们期望ARM能够象X86那样用一个kernel image来支持多个platform。在这种情况下，如果我们认为kernel是一个black box，那么其输入参数应该包括： 1、识别platform的信息 2、runtime的配置参数 3、设备的拓扑结构以及特性 对于嵌入式系统，在系统启动阶段，bootloader会加载内核并将控制权转交给内核，此外，还需要把上述的三个参数信息传递给kernel，以便kernel可以有较大的灵活性。在linux kernel中，Device Tree的设计目标就是如此。&lt;/p>
- /posts/dtb1/ - This is a customized copyright.</description></item><item><title>ubuntu安装光盘iso修改方法总结</title><link>/posts/ubuntu_modify_iso/</link><pubDate>Wed, 04 Feb 2015 06:19:10 +0000</pubDate><guid>/posts/ubuntu_modify_iso/</guid><description>seteuid0's blog /posts/ubuntu_modify_iso/ -&lt;p>可以使用mount命令查看iso的内容&lt;code>#mkdir iso #mount -o loop ubuntu.iso ./iso&lt;/code>把iso里面的内容取出来,iso_modify&lt;code>#mkdir iso\_modify #rsync -az ./iso ./iso\_modify&lt;/code>Iso目录里面的casper/filesystem.squashfs就是启动以后的虚拟文件系统，我们要修改的就是这里的内容。&lt;code>#mkdir squashfs #cp iso/casper/filesystem.squashfs ./squashfs #cd squashfs&lt;/code>解压squashfs&lt;code>#unsquashfs filesystem.squashfs&lt;/code>可以看到解压出的squashfs-root目录就是一个文件系统，针对性的进行修改，如果需要安装deb包，可以chroot进去使用dpkg进行安装。 如果安装了软件包，需要跟新dpkg的列表：&lt;code>#chroot squashfs-root/ dpkg-query -W --showformat='${Package}\\t${Version}\\n' &amp;gt; dpkg\_list #cp dpkg\_list ../../iso\_modify/casper/filesystem.manifest&lt;/code>把squashfs-root目录从新制作成squashfs文件&lt;code>#mksquashfs squashfs-root filesystem.squashfs -b 1024k -comp xz -Xbcj x86 -e boot&lt;/code>用新的filesystem.squashfs替换原来的文件。 把新的iso-modify打包成iso```
#mkisofs -r -V &amp;ldquo;UbuntuTest&amp;rdquo; -cache-inodes -J -l -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o ../ubuntu-test.iso .&lt;/p>
&lt;pre>&lt;code class="language-好了，开始使用修改后的iso吧。" data-lang="好了，开始使用修改后的iso吧。">&lt;/code>&lt;/pre>- /posts/ubuntu_modify_iso/ - This is a customized copyright.</description></item><item><title>ubuntu下initramfs相关内容记录</title><link>/posts/ubuntu_initramfs/</link><pubDate>Mon, 02 Feb 2015 16:54:53 +0000</pubDate><guid>/posts/ubuntu_initramfs/</guid><description>seteuid0's blog /posts/ubuntu_initramfs/ -&lt;p>为了适应不同的运行环境，Linux发行版的启动基本都分为两个阶段，第一阶段使用initramfs文件系统，加载所需要的硬件驱动、文件系统驱动等；当完成根文件系统挂载后执行chroot，进入真实的文件系统。 initramfs类似与一个极其简化的文件系统，里面包含了系统启动时驱动的最小集合，这样使得initramfs的体积尽可能的变小。但不同发行版本的initramfs中内容的制作方式不尽相同，例如在fedora、rhel、centos的版本中，使用dracut工具包来生成相对应的initrd，而在ubuntu系统中使用initramfs-tools工具包所提供的相关工具。 当安装内核、内核升级的时候，内核的postinst脚本会在安装结束后调用update-initramfs工具更新相关的initramfs文件。查看update-initramfs文件发现，其主要调用mkinitramfs来完成相关操作。 update-initramfs与mkinitramfs文件都是BASH脚本文件，mkinitramfs文件基于事先约定的规则拷贝相关的程序、库、脚本、配置等到特定的目录，然后打包成initramfs格式的文件。mkinitramfs文件会引用/usr/share/initramfs-tools/hook-functions中事先约定好的函数，例如copy_exec可以完成二进制程序的拷贝，同时拷贝该程序所以来的动态库。/usr/share/initramfs-tools/scripts/目录中存放着生成initramfs中所需要的脚本。 修改//usr/sbin/mkinitramfs或者其他相关的内容，自己重新生成一个initramfs文件和之前的对比下，就可以看到效果。 例如：mkinitramfs -o test.img即可使用当前运行的内核版本生成一个对应的initramfs文件。 initramfs-tools软件包中除了mkinitramfs、update-initramfs工具外还有lsinitramfs等工具来帮助用户进行操作。 当然，最后生成的initramfs.img文件只是一种打包好的文件而已，方便grub加载及运行，我们也可自行进行解压、修改、再打包。 命令大致如下： 解压：zcat in.img |cpio -dium 打包：find . |cpio -H newc -o |gzip -9 &amp;gt; out.img&lt;/p>
- /posts/ubuntu_initramfs/ - This is a customized copyright.</description></item><item><title>[zz]CVE-IDs have a new format</title><link>/posts/cve-ids_have_a_new_format/</link><pubDate>Mon, 02 Feb 2015 15:27:48 +0000</pubDate><guid>/posts/cve-ids_have_a_new_format/</guid><description>seteuid0's blog /posts/cve-ids_have_a_new_format/ -&lt;p>之前的CVE命名规则已经无法满足现状了，已经没有什么能够阻挡漏洞挖掘的大军了。&lt;/p>
&lt;p>&lt;a href="http://cve.mitre.org/news/index.html#january132015_First_CVE_IDs_Issued_in_New_Numbering_Format_Now_Available">First CVE-IDs Issued in New Numbering Format Now Available&lt;/a>&lt;/p>
&lt;p>January 13, 2015 | &lt;a href="http://cve.mitre.org/news/index.html#january132015_First_CVE_IDs_Issued_in_New_Numbering_Format_Now_Available">Share this article&lt;/a>&lt;/p>
&lt;p>The first ever CVE-ID numbers issued in the &lt;a href="http://cve.mitre.org/cve/identifiers/syntaxchange.html#new">new CVE-ID numbering format&lt;/a> were posted on January 13, 2015 for vulnerabilities disclosed in 2014: &lt;a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-10001">CVE-2014-10001&lt;/a> with 5 digits and&lt;a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-100001">CVE-2014-100001&lt;/a> with 6 digits.&lt;/p>
&lt;p>The format of CVE-ID numbers was changed a year ago this month in January 2014 so that the CVE project can track 10,000 or more vulnerabilities for a given calendar year. Previously, CVE-IDs were restricted to four digits at the end in the sequence number portion of the ID, for example &amp;ldquo;CVE-2014-0160&amp;rdquo;, but this four-digit restriction only allowed up to 9,999 vulnerabilities per year. With the new format, CVE-ID numbers may have 4, 5, 6, 7, or more digits in the sequence number if needed in a calendar year. For example, the just released &amp;ldquo;&lt;a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-10001">CVE-2014-10001&lt;/a>&amp;rdquo; with 5 digits in the sequence number and &amp;ldquo;&lt;a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-10001">CVE-2014-100001&lt;/a>&amp;rdquo; with 6 digits in the sequence number, or CVE-2014-XXXXXXX with 7 digits in the sequence number, and so on.&lt;/p>
&lt;p>Additional CVE-IDs in the new format with 5 and 6 digits in the sequence number were also issued today—CVE-2014-10001 through CVE-2014-10039 with 5 digits, and CVE-2014-100001 through CVE-2014-100038 with 6 digits—to also identify vulnerabilities disclosed in 2014. Enter these CVE-ID numbers on the &lt;a href="http://cve.mitre.org/cve/cve.html">CVE List&lt;/a> search page to learn more about each issue.&lt;/p>
&lt;p>Please report any problems, or anticipated problems, that you encounter with CVE-IDs issued in the new format to &lt;a href="mailto:cve-id-change@mitre.org">cve-id-change@mitre.org&lt;/a>.&lt;/p>
- /posts/cve-ids_have_a_new_format/ - This is a customized copyright.</description></item><item><title>搭建linux0.11系统环境</title><link>/posts/install_linux0.11/</link><pubDate>Wed, 14 Jan 2015 16:17:56 +0000</pubDate><guid>/posts/install_linux0.11/</guid><description>seteuid0's blog /posts/install_linux0.11/ -&lt;p>要学习Linux0.11的内核代码必须要有一个运行环境来做实验，本文简要介绍如何搭建该环境。 环境：ubuntu14.10 x86_64 Linux0.11的内核可以说是古董级的，所以必须要祭出模拟器了，有2中搭建方案bochs或qemu&lt;/p>
&lt;h3 id="使用bochs仿真器">使用bochs仿真器：&lt;/h3>
&lt;p>1、使用发行版的bochs，通过apt-get安装，需要安装如下软件包，如果缺包在之后的运行中就会有各种问题，此处忽略。当然你也可以从&lt;a href="http://sourceforge.net/projects/bochs/files/Disk%20Images/">http://sourceforge.net/projects/bochs/files/Disk%20Images/&lt;/a> 处下载安装。&lt;code>ii bochs 2.6-2 amd64 IA-32 PC emulator ii bochs-doc 2.6-2 all Bochs upstream documentation ii bochs-term 2.6-2 amd64 Terminal (ncurses-based) plugin for Bochs ii bochs-wx 2.6-2 amd64 WxWindows plugin for Bochs ii bochs-x 2.6-2 amd64 X11 plugin for Bochs ii bochsbios 2.6-2 all BIOS for the Bochs emulator&lt;/code>2、下载虚拟文件系统：地址：http://www.oldlinux.org/Linux.old/bochs/linux-0.11-devel-040329.zip 3、由于bochs的变化，所以需要修改配置文件，我修改bochsrc-hd.bxrc后的内容如下：```
megs: 16
floppya: 1_44=&amp;ldquo;bootimage-0.11-hd&amp;rdquo;, status=inserted
floppyb: 1_44=diskb.img, status=inserted
ata0-master: type=disk, path=&amp;ldquo;hdc-0.11.img&amp;rdquo;, mode=flat, cylinders=121, heads=16, spt=63
boot: a
log: bochsout.txt
parport1: enable=0
vga_update_interval: 300000
keyboard_serial_delay: 200
keyboard_paste_delay: 100000
cpu: count=1, ips=1000000
mouse: enabled=0
private_colormap: enabled=0
fullscreen: enabled=0
screenmode: name=&amp;ldquo;sample&amp;rdquo;
i440fxsupport: enabled=0&lt;/p>
&lt;pre>&lt;code class="language-4、使用以下方式启用：bochs" data-lang="4、使用以下方式启用：bochs">
### 使用qemu：
1、编译内核，我使用从https://github.com/peterx/linux-cd/archive/master.zip下载的修改后的linux0.11的内核版本。使用gcc version 4.9.1的时候，需要Makefile.header的CFLAGS里面添加-fno-stack-protector参数。 2、同样使用bochs中下载的系统镜像，使用如下命令启动。（注意参数中的Image是步骤1中编译后生成的文件）```
qemu-system-x86\_64 -m 16M -boot a -fda ../../linux-cd/linux-0.11-20110805/Image -hda ./hdc-0.11.img
```ok，qemu的界面出现了&lt;/code>&lt;/pre>- /posts/install_linux0.11/ - This is a customized copyright.</description></item></channel></rss>