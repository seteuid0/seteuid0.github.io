<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>seteuid0's blog</title><link>/</link><description>Recent content on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Sun, 18 Apr 2021 11:16:32 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>[zz]迅雷回应流氓插件事件 “员工违规解释”存蹊跷</title><link>/posts/zz_thunder_responded_rogue_plug-in_event_quotexplained_staff_violationquot_kept_strange/</link><pubDate>Thu, 22 Aug 2013 14:37:00 +0000</pubDate><guid>/posts/zz_thunder_responded_rogue_plug-in_event_quotexplained_staff_violationquot_kept_strange/</guid><description>seteuid0's blog /posts/zz_thunder_responded_rogue_plug-in_event_quotexplained_staff_violationquot_kept_strange/ -&lt;p>2013-08-22 09:34比特网佚名关键字：流氓插件 迅雷 迅雷流氓插件事件 员工违规操作比特(ChinaByte)8月22日消息，今年8月初以来，关于迅雷客户端“制造并传播病毒”的传闻在业内广泛流传，就此，今日迅雷方面做出回应，称报道中所指的“病毒插件”实为公司视频事业部某负责人避开公司流程，擅自制作上线的一个流氓插件。公司目前已开除该事件负责人，同时，对上级负责人给予记过、警告以及罚款等处罚。据了解这款病毒插件在用户手机连接到电脑时，其在满足某些条件时，会在用户不知情的情况下，该程序会后台下载并自动安装APK到连接至当前计算机的手机上，这些APK为“九游棋牌大厅”、“91手机助手”、“360手机助手”、“UU网络电话”、“机锋应用市场”带来流量。扩散近两个月，已有超过2800万用户中招。在昨天迅雷公司总部临时召开的发布会上，迅雷高级副总裁黄芃称，迅雷早在7月27号就接到用户反馈，发现上述程序可能是流氓插件，经过排查后发现，此插件系迅雷集团视频事业部传媒部门某经理避开公司规定流程，私自制作上线的一款插件，公司在发现问题一周后就开除了这位部门经理，并对其上级同时进行处罚。对于迅雷给出的“解释”，外界并不买账。一种观点认为，迅雷是内部冲业绩的铤而走险的行为。据媒体报道，传言出来后，腾讯电脑管家，金山、360等杀毒软件已先后检测到上述恶意程序，并在7月下旬通知迅雷公司进行联合处理，但直到8月21日，迅雷方面才给出官方回应，处理并不及时，说明事件背后有更深层次的原因。迅雷客户端的一位高管邮件向媒体透露，推送九游棋牌大厅、91手机助手、360手机助手、UU网络电话、机锋应用市场的事情，是经过公司领导审批的。&amp;ldquo;置换推广的策略本身没有问题，但是执行手段属于病毒行为，和公司推行用户体验至上的原则是背道而驰的。”也有内部人士称，根本原因在于，迅雷看看今年设定的移动安装量，要求每日新增15万，正常需要推广费用5400万元，但公司给的预算只有800万用于无线推广。该被处理的员工会不会是事件的“替罪羊”？对于这种推测，迅雷方面称，这些应用原本与迅雷集团有流量互换的合作，但该员工的行为并未得到这些应用公司的许可。迅雷CEO邹胜龙在发布会上表示了对用户的歉意，并表示今后会完善公司的员工和流程管理机制。同时迅雷方面目前正通过腾讯电脑管家、金山软件、奇虎360等合作伙伴清除用户电脑上的这款插件。&lt;/p>
- /posts/zz_thunder_responded_rogue_plug-in_event_quotexplained_staff_violationquot_kept_strange/ - This is a customized copyright.</description></item><item><title>fedora19中使用wps：No necessary symbol fonts</title><link>/posts/fedora19_use_the_wps_no_necessary_symbol_fonts/</link><pubDate>Wed, 21 Aug 2013 08:15:00 +0000</pubDate><guid>/posts/fedora19_use_the_wps_no_necessary_symbol_fonts/</guid><description>seteuid0's blog /posts/fedora19_use_the_wps_no_necessary_symbol_fonts/ -&lt;p>1下载如下内容文件名：              symbol-fonts-1.2-1.noarch.rpmbox网盘下载链接：     https://app.box.com/s/wmsdpn8x9qpcbcnekke1金山快盘下载链接：    http://www.kuaipan.cn/file/id_19418406138675465.htm百度网盘下载链接：    http://pan.baidu.com/share/link?shareid=3371036765&amp;amp;uk=505215462文件大小：            246 KB (252,171 字节)md5码：               4a7649c69e15983a6e69c31f38f64c62sha1码：              9d00e765169bba5f1351cf7f21a15ae3e26dcb082、把rpm包里面的文件解到mkdir /usr/share/fonts/symbol-fonts目录rpm2cpio ~/下载/symbol-fonts-1.2-1.noarch.rpm |cpio -idum然后执行fc-cache  -fv再打开wps就没有问题了。参考地址：http://community.wps.cn/wiki/No_necessary_symbol_fontshttp://bbs.wps.cn/thread-22355435-1-1.html&lt;/p>
- /posts/fedora19_use_the_wps_no_necessary_symbol_fonts/ - This is a customized copyright.</description></item><item><title>fedora19系统t430s使用小红帽</title><link>/posts/fedora19_system_t430s_use_little_red_riding_hood/</link><pubDate>Tue, 20 Aug 2013 15:19:00 +0000</pubDate><guid>/posts/fedora19_system_t430s_use_little_red_riding_hood/</guid><description>seteuid0's blog /posts/fedora19_system_t430s_use_little_red_riding_hood/ -&lt;p>执行以下命令，或者放入开机启动的脚本中即可：set -euid=$(xinput list | sed -n &amp;lsquo;/TPPS/2 IBM TrackPoint/s/.*id=([0-9]+).*/1/p&amp;rsquo;)emu=$(xinput list-props &amp;ldquo;$id&amp;rdquo; |     sed -n &amp;lsquo;/Evdev Wheel Emulation (/s/.*(([0-9]+)).*/1/p&amp;rsquo;)but=$(xinput list-props &amp;ldquo;$id&amp;rdquo; |     sed -n &amp;lsquo;/Evdev Wheel Emulation Button (/s/.*(([0-9]+)).*/1/p&amp;rsquo;)axs=$(xinput list-props &amp;ldquo;$id&amp;rdquo; |     sed -n &amp;lsquo;/Evdev Wheel Emulation Axes (/s/.*(([0-9]+)).*/1/p&amp;rsquo;)xinput set-int-prop &amp;ldquo;$id&amp;rdquo; &amp;ldquo;$emu&amp;rdquo; 8 1xinput set-int-prop &amp;ldquo;$id&amp;rdquo; &amp;ldquo;$but&amp;rdquo; 8 2不同的型号可能值不同，可以通过工具gpointing-device-settings设置。&lt;/p>
- /posts/fedora19_system_t430s_use_little_red_riding_hood/ - This is a customized copyright.</description></item><item><title>linux 下如何通过软件模拟按键[转-修改]</title><link>/posts/how_software_under_linux_analog_buttons_turn_-_modify/</link><pubDate>Wed, 14 Aug 2013 17:13:00 +0000</pubDate><guid>/posts/how_software_under_linux_analog_buttons_turn_-_modify/</guid><description>seteuid0's blog /posts/how_software_under_linux_analog_buttons_turn_-_modify/ -&lt;p>其实在/dev/input/by-path目录下面的文件名有表明是什么设备，键盘还是鼠标，可以通过文件名来确认键盘所对应的dev设别，然后对该文件进行处理。然后按以下的内容进行操作即可。linux 下如何通过软件模拟按键[转-修改]转自：http://zhgw01.blog.163.com/blog/static/10414812200992854628702/参考http://www.linuxdiyf.com/viewarticle.php?id=104221名词解释：scancode: 驱动对硬件的标记keycode： 上层应用程序所见的标记，跟硬件的标记不同， 一般为KEY_F1之类的宏一般驱动将scancode绑定到keycode对未绑定的scancode, 可以通过setkeycodes将将其绑定到未使用的keycode注： 有些按键会被解释成acpi event, 可以通过acpi_listen来监听，但不一定成功，目前还没具体了解模 拟按键是上层应用程序的行为， 所以不需要编译成模块，只需要想平常的应用程序那样编译就可以了， 不过它要包含&amp;lt;linux/input.h&amp;gt;这个文件， 同时要明确键盘对应的/dev/input/event[0-4]到底是哪个文件， 此外还需要以root权限来运行赖半仙注解：运行命令 cat /proc/bus/input/devices  在输出里面查找 xxx keyboard 对应的文件是/dev/input/event几。我开始想当然的以为键盘文件是event1,结果死人都调不出来，弄了很久最后从event0开始一个一个试，才发现我的手提电脑键盘文件对应的是event4。在我的电脑上运行命令 ls /dev/input/event* 发现有好多输入设备…………/dev/input/event0  /dev/input/event10  /dev/input/event2  /dev/input/event4  /dev/input/event6  /dev/input/event8/dev/input/event1  /dev/input/event11  /dev/input/event3  /dev/input/event5  /dev/input/event7  /dev/input/event9下面是 cat /proc/bus/input/devices 命令对应键盘文件的一段输出I: Bus=0011 Vendor=0001 Product=0001 Version=ab41N: Name=&amp;ldquo;AT Translated Set 2 keyboard&amp;quot;P: Phys=isa0060/serio0/input0S: Sysfs=/devices/platform/i8042/serio0/input/input4U: Uniq=H: Handlers=kbd event4 B: EV=120013B: KEY=8000 0 0 0 0 0 5007 2002000 380307c f800d001 feffffdf ffefffff ffffffff ffffffffB: MSC=10B: LED=7下面的程序是模拟按键NumLock，就是控制小键盘灯的那个按键，按下去（运行程序没有问题）后小键盘灯就会点亮或者熄灭。 #include &amp;lt;linux/input.h&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;errno.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;void simulate_key(int fd, unsigned int keycode, int keyvalue){struct input_event event;event.type = EV_KEY;event.code = keycode;event.value = keyvalue;gettimeofday(&amp;amp;event.time, 0);if (write(fd, &amp;amp;event, sizeof(event)) &amp;lt; 0) {printf(&amp;ldquo;simulate key errorn&amp;rdquo;);return;}elseprintf(&amp;ldquo;simuate key %d, %dn&amp;rdquo;, keycode, keyvalue);}int main ( int argc, char *argv[] ){char *path = &amp;ldquo;/dev/input/event1&amp;rdquo;;unsigned int key_code = KEY_NUMLOCK;   //键值: NumLock//unsigned int key_code = KYE_A;        //键值：a   if (argc &amp;gt;= 3) {path = argv[1];key_code = atoi(argv[2]);}else if (argc &amp;gt;= 2)path = argv[1];int fd_kbd = open(path, O_RDWR);if(fd_kbd &amp;lt;= 0) {printf(&amp;ldquo;error open keyboard:%sn&amp;rdquo;, strerror(errno));return -1;}simulate_key(fd_kbd, key_code, 1);simulate_key(fd_kbd, key_code, 0);close(fd_kbd);return 0;}               /* &amp;mdash;&amp;mdash;&amp;mdash;-  end of function main  &amp;mdash;&amp;mdash;&amp;mdash;- */&lt;/p>
- /posts/how_software_under_linux_analog_buttons_turn_-_modify/ - This is a customized copyright.</description></item><item><title>[zz] extJs常用的四种Ajax异步提交</title><link>/posts/zz_extjs_four_common_ajax_asynchronous_commit/</link><pubDate>Thu, 08 Aug 2013 08:09:00 +0000</pubDate><guid>/posts/zz_extjs_four_common_ajax_asynchronous_commit/</guid><description>seteuid0's blog /posts/zz_extjs_four_common_ajax_asynchronous_commit/ -&lt;p> extJs常用的四种Ajax异步提交分类： ExtJs2010-06-01 16:52 2973人阅读 评论(0) 收藏 举报ajaxextjsfunctionactionuserhtml[java] view plaincopy/**  * &lt;!-- raw HTML omitted -->  * 第一种Ajax提交方式  * &lt;!-- raw HTML omitted -->  * &lt;!-- raw HTML omitted -->  * 这种方式需要直接使用ext Ajax方法进行提交  * &lt;!-- raw HTML omitted -->  * &lt;!-- raw HTML omitted -->  * 使用这种方式，需要将待传递的参数进行封装  * &lt;!-- raw HTML omitted -->  *   * @return  */  function saveUser_ajaxSubmit1() {      Ext.Ajax.request( {          url : &amp;lsquo;user_save.action&amp;rsquo;,          method : &amp;lsquo;post&amp;rsquo;,          params : {              userName : document.getElementById(&amp;lsquo;userName&amp;rsquo;).value,              password : document.getElementById(&amp;lsquo;password&amp;rsquo;).value          },          success : function(response, options) {              var o = Ext.util.JSON.decode(response.responseText);              alert(o.msg);          },          failure : function() {          }      });  }  /**  * &lt;!-- raw HTML omitted -->  * 第二种Ajax提交方式  * &lt;!-- raw HTML omitted -->  * &lt;!-- raw HTML omitted -->  * 这种方式将为ext的ajax指定一个html表单  * &lt;!-- raw HTML omitted -->  * &lt;!-- raw HTML omitted -->  * 使用这种方式，不需要将待传递的参数进行封装  * &lt;!-- raw HTML omitted -->  *   * @return  */  function saveUser_ajaxSubmit2() {      Ext.Ajax.request( {          url : &amp;lsquo;user_save.action&amp;rsquo;,          method : &amp;lsquo;post&amp;rsquo;,          form : &amp;lsquo;userForm&amp;rsquo;, // 指定表单          success : function(response, options) {              var o = Ext.util.JSON.decode(response.responseText);              alert(o.msg);          },          failure : function() {          }      });  }  /**  * &lt;!-- raw HTML omitted -->  * 第三种Ajax提交方式  * &lt;!-- raw HTML omitted -->  * &lt;!-- raw HTML omitted -->  * 这种方式将为ext的自己的表单进行提交  * &lt;!-- raw HTML omitted -->  * &lt;!-- raw HTML omitted -->  * 使用这种方式，需要使用ext自己的textField组件  * &lt;!-- raw HTML omitted -->  *   * @return  */  function saveUser_ajaxSubmit3() {      // 定义表单      var formPanel = new Ext.FormPanel( {          labelWidth : 75,          frame : true,          bodyStyle : &amp;lsquo;padding:5px 5px 0&amp;rsquo;,          width : 350,          defaults : {              width : 230          },          defaultType : &amp;lsquo;textfield&amp;rsquo;,          items : [ {              fieldLabel : &amp;lsquo;用户名&amp;rsquo;,              name : &amp;lsquo;userName&amp;rsquo;,              allowBlank : false          }, {              fieldLabel : &amp;lsquo;密   码&amp;rsquo;,              name : &amp;lsquo;password&amp;rsquo;          } ]      });      // 定义窗口      var win = new Ext.Window( {          title : &amp;lsquo;添加用户&amp;rsquo;,          layout : &amp;lsquo;fit&amp;rsquo;,          width : 500,          height : 300,          closeAction : &amp;lsquo;close&amp;rsquo;,          closable : false,          plain : true,          items : formPanel,          buttons : [ {              text : &amp;lsquo;确定&amp;rsquo;,              handler : function() {                  var form = formPanel.getForm();                  var userName = form.findField(&amp;lsquo;userName&amp;rsquo;).getValue().trim();                  var password = form.findField(&amp;lsquo;password&amp;rsquo;).getValue().trim();                  if (!userName) {                      alert(&amp;lsquo;用户名不能为空&amp;rsquo;);                      return;                  }                  if (!password) {                      alert(&amp;lsquo;密码不能为空&amp;rsquo;);                      return;                  }                  form.submit( {                      waitTitle : &amp;lsquo;请稍后&amp;hellip;',                      waitMsg : &amp;lsquo;正在保存用户信息,请稍后&amp;hellip;',                      url : &amp;lsquo;user_save.action&amp;rsquo;,                      method : &amp;lsquo;post&amp;rsquo;,                      success : function(form, action) {                          alert(action.result.msg);                      },                      failure : function(form, action) {                          alert(action.result.msg);                      }                  });              }          }, {              text : &amp;lsquo;取消&amp;rsquo;,              handler : function() {                  win.close();              }          } ]      });      win.show();  }  /**  * &lt;!-- raw HTML omitted -->  * 第四种Ajax提交方式  * &lt;!-- raw HTML omitted -->  * &lt;!-- raw HTML omitted -->  * 这种方式将html的表单转化为ext的表单进行异步提交  * &lt;!-- raw HTML omitted -->  * &lt;!-- raw HTML omitted -->  * 使用这种方式，需要定义好html的表单  * &lt;!-- raw HTML omitted -->  *   * @return  */  function saveUser_ajaxSubmit4() {      new Ext.form.BasicForm(&amp;lsquo;userForm&amp;rsquo;).submit( {          waitTitle : &amp;lsquo;请稍后&amp;hellip;',          waitMsg : &amp;lsquo;正在保存用户信息,请稍后&amp;hellip;',          url : &amp;lsquo;user_save.action&amp;rsquo;,          method : &amp;lsquo;post&amp;rsquo;,          success : function(form, action) {              alert(action.result.msg);          },          failure : function(form, action) {              alert(action.result.msg);          }      });  }&lt;/p>
- /posts/zz_extjs_four_common_ajax_asynchronous_commit/ - This is a customized copyright.</description></item><item><title>[zz]ExtJS之Ext.Ajax.request用法详解</title><link>/posts/zz_extjs_detailed_usage_of_extajaxrequest/</link><pubDate>Thu, 08 Aug 2013 08:07:00 +0000</pubDate><guid>/posts/zz_extjs_detailed_usage_of_extajaxrequest/</guid><description>seteuid0's blog /posts/zz_extjs_detailed_usage_of_extajaxrequest/ -&lt;p>ExtJS之Ext.Ajax.request用法详解 RIA-ExtJS专栏EXTAjaxjsonOO浏览器 Java代码  &amp;lt;span style=&amp;ldquo;font-size: medium;&amp;quot;&amp;gt;Ext.Ajax.request({            url:&amp;lsquo;findbyid.action&amp;rsquo;,         params:{          id:cell.getId()          },          success: function(resp,opts) {                                var respText = Ext.util.JSON.decode(resp.responseText);                                                                                name=respText.name;                               oid=respText.id;                              findbyid(graph,cell,oid,name);                               //Ext.Msg.alert(&amp;lsquo;错误&amp;rsquo;, respText.name+&amp;quot;=====&amp;quot;+respText.id);                        },                        failure: function(resp,opts) {                                var respText = Ext.util.JSON.decode(resp.responseText);                                Ext.Msg.alert(&amp;lsquo;错误&amp;rsquo;, respText.error);                         }                    });&lt;!-- raw HTML omitted -->   在Ext开发过程中，基本上时刻需要用到异步请求，那么这个请求到底是怎么执行的呢，我们接下来来探讨下  首先：Ext.Ajax类继承了Ext.data.Connection，为Ajax的请求提供了最大灵活性的操作方式再简单请求基础上我们加上一个使用的 说明的是这种请求通常都是放在触发某个事件的处理方法中的url:就是我们要请求的路径params:里面的参数用逗号隔开，就是我们要发出请求带的参数success:是服务器处理成功返回failure:是服务器处理失败返回重点讲的就是如何处理返回值信息，我们的resp这个参数就显得非常重要了resp是Ext构造的一个返回结果对象，如服务器端返回“this is a test！”（可以通过throw new Exception(&amp;ldquo;this is a test!&amp;quot;)简单实现)。那么返回将是如下内容：Java代码  &amp;lt;span style=&amp;ldquo;font-size: medium;&amp;quot;&amp;gt;tId.1  status.200  statusText.OK  getResponseHeader.[object Object]  getAllResponseHeaders.Server: Apache-Coyote/1.1  Content-Type: text/html;charset=GBK  Content-Language: zh-CN  Content-Length: 108  Date: Wed, 31 Oct 2007 12:51:23 GMT  responseText.  &lt;!-- raw HTML omitted -->  &lt;!-- raw HTML omitted -->  &lt;!-- raw HTML omitted -->错误&lt;!-- raw HTML omitted -->  &lt;!-- raw HTML omitted -->  &lt;!-- raw HTML omitted -->    &lt;!-- raw HTML omitted -->错误：this is a test!&lt;!-- raw HTML omitted -->  &lt;!-- raw HTML omitted -->  &lt;!-- raw HTML omitted -->  responseXML.  argument.undefined&lt;!-- raw HTML omitted -->   从上面结果可以看出来，最开始是一些状态属性，我们也不常用，不管他。里面真正常用的是responseText与responseXML两个属性，那么这里面的responseText内容又被Ext用html包装了，但使用Ext.MessageBox展示出来正合适；reponseXML将在服务器端返回“text/xml”类型时使用。若服务器端返回是“text/json”类型时，客户端需要使用obj= Ext.util.JSON.decode(result.responseText);进行构造json对象，然后就可以正常使用了具体操作返回值 我们用JSON就这么写ServletActionContext.getResponse().setContentType(&amp;ldquo;text/json; charset=utf-8&amp;rdquo;);ServletActionContext.getResponse().getWriter().write(&amp;quot;{success:true,info:&amp;lsquo;更新信息成功&amp;rsquo;,name:'&amp;rdquo; + oo.getName() + &amp;ldquo;',id:'&amp;rdquo; + id + &amp;ldquo;'}&amp;quot;);显然我这里返回的是JSON的值了(记住里面的属性值一定要加单引号) var respText = Ext.util.JSON.decode(resp.responseText); 这个就可获得返回结果对象，要使用属性的话respText.id等都可直接用了说到这里如果还想对这里面其他配置感兴趣的话可以参考下面的语句url : String/Function (Optional)（可选项）发送请求的url，默认为配置的url。 若为函数类型那么其作用域将由配置项scope所指定。默认为配置好的URL。 The URL to which to send the request, or a function to call which returns a URL string. The scope of the function is specified by the scope option. Defaults to configured URL.params : Object/String/Function （可选项）(Optional)一包含属性的对象（这些属性被用作request的参数）或一个编码后的url字串或一个能调用其中任一一属性的函数。 若为函数类型那么其作用域将由配置项scope所指定。 An object containing properties which are used as parameters to the request, a url encoded string or a function to call to get either. The scope of the function is specified by the scope option.method : String （可选项）(Optional)该请求所用的http方面，默认值为配置的方法，或者当没有方法被配置时，如果没有发送参数时用get，有参数时用post。 The HTTP method to use for the request. Defaults to the configured method, or if no method was configured, &amp;ldquo;GET&amp;rdquo; if no parameters are being sent, and &amp;ldquo;POST&amp;rdquo; if parameters are being sent. Note that the method name is case-sensitive and should be all caps.callback : Function （可选项）(Optional)该方法被调用时附上返回的http response对象。不管成功还是失败，该回调函数都将被调用，该函数中传入了如下参数: The function to be called upon receipt of the HTTP response. The callback is called regardless of success or failure and is passed the following parameters:options : Object&amp;gt;请求所调用的参数。The parameter to the request call.success : Boolean请求成功则为true。True if the request succeeded.response : Object包含了返回数据的xhr对象。The XMLHttpRequest object containing the response data. Seehttp://www.w3.org/TR/XMLHttpRequest/ for details about accessing elements of the response.success: Function （可选项）(Optional)该函数被调用取决于请求是否成功。该回调函数被传入如下参数: The function to be called upon success of the request. The callback is passed the following parameters:response : Object包含数据的xhr对象。The XMLHttpRequest object containing the response data.options : Object请求所调用的参数。The parameter to the request call.failure : Function （可选项）(Optional)该函数被调用取决于请求失败。该回调函数被传入如下参数: The function to be called upon failure of the request. The callback is passed the following parameters:response : Object包含数据的xhr对象。 The XMLHttpRequest object containing the response data.options : Object请求所调用的参数。 The parameter to the request call.scope : Object （可选项）(Optional)回调函数的作用域：回调函数&amp;quot;this&amp;quot;对象指针。默认值为浏览器窗口。 The scope in which to execute the callbacks: The &amp;ldquo;this&amp;rdquo; object for the callback function. If the url, or params options were specified as functions from which to draw values, then this also serves as the scope for those function calls. Defaults to the browser window.form : Element/HTMLElement/String （可选项）(Optional)用来压入参数的一个&lt;!-- raw HTML omitted -->元素或&lt;!-- raw HTML omitted -->的标识。 The &lt;!-- raw HTML omitted --> Element or the id of the &lt;!-- raw HTML omitted --> to pull parameters from.isUpload : Boolean （可选项）(Optional)如果该form对象是上传form，为true（通常情况下会自动探测）  headers : Object （可选项）(Optional)为请求所加的请求头。 Request headers to set for the request.xmlData : Object （可选项）(Optional)用于发送的xml document。注意:它将会被用来在发送数据中代替参数任务参数将会被追加在url中。 XML document to use for the post. Note: This will be used instead of params for the post data. Any params will be appended to the URL.jsonData : Object/String （可选项）(Optional)JSON data to use as the post. Note: This will be used instead of params for the post data. Any params will be appended to the URL.disableCaching : Boolean （可选项）(Optional)设置为True,则添加一个独一无二的cache-buster参数来获取请求。 True to add a unique cache-buster param to GET requests&lt;/p>
- /posts/zz_extjs_detailed_usage_of_extajaxrequest/ - This is a customized copyright.</description></item><item><title>rhel6.4/Fedora18/19上kerberos安装实验</title><link>/posts/kerberos_install_experimental_rhel64fedora1819/</link><pubDate>Wed, 31 Jul 2013 06:05:00 +0000</pubDate><guid>/posts/kerberos_install_experimental_rhel64fedora1819/</guid><description>seteuid0's blog /posts/kerberos_install_experimental_rhel64fedora1819/ -&lt;p>在rhel6.4上安装kerberos实验，理解kerberos原理。安装步骤如下：安装krb，yum install krb5-*修改hosts文件：添加ip kerberos.example.com kerberos主要是修改主机名，修改host是为了找到地址在fedora18/19等系统还需要修改/etc/hostname，添加主机名：kerberos.example.com在rhel的系统中在 /etc/sysconfig/network文件中如果以上修改有误，可能会提示默认的krb配置基本就可以使用了，krb初始化kdb5_util create -r EXAMPLE.COM -s启动服务service krb5kdc start安装完毕，可以使用你的Krb服务了。测试方法：创建一个sample的principal，用来给服务程序使用kadmin.local:addprinc &lt;a href="mailto:sample/kerberos.example.com@EXAMPLE.COMkadmin.local">sample/kerberos.example.com@EXAMPLE.COMkadmin.local&lt;/a>:ktadd -k /etc/krb5.keytab &lt;a href="mailto:sample/kerberos.example.com@EXAMPLE.COM">sample/kerberos.example.com@EXAMPLE.COM&lt;/a>创建一个用户的principalkadmin.local:addprinc &lt;a href="mailto:test1/kerberos.example.com@EXAMPLE.COM">test1/kerberos.example.com@EXAMPLE.COM&lt;/a>运行测试服务程序：sserver -p 8899 -s sample登录系统，执行kinit获取principal:kinit test1/kerberos.example.comklist查看相关内容sclient kerberos.example.com 8899 sample返回success，说明配置正确。其他测试程序1、sim_serversim_server -p 8888 -s samplesim_client -p 8888 -h kerberos.example.com -m hello2、uuserver修改/etc/services添加uu-sample    8888/tcp    #uu-sample添加一个新的pricipal,使用该principal登录，然后执行uuserver用另外一个principal登录，然后执行uuclient kerberos.example.com message&lt;/p>
- /posts/kerberos_install_experimental_rhel64fedora1819/ - This is a customized copyright.</description></item><item><title>install vmware 9.0.2 on fedora 19</title><link>/posts/install_vmware_902_on_fedora_19/</link><pubDate>Tue, 30 Jul 2013 13:20:00 +0000</pubDate><guid>/posts/install_vmware_902_on_fedora_19/</guid><description>seteuid0's blog /posts/install_vmware_902_on_fedora_19/ -&lt;p>不能用，需要修改vmware的驱动，在http://forums.fedoraforum.org/showthread.php?t=292907找到了解决办法，内容如下。Re: vmware player 5.0.2 onf fc19 (3.10.3-300.fc19.x86_64) - who got it running?I have 5.0.2 running. To get it running at all, I first had to do a tweak to the /usr/bin/vmplayer file to allow VMPlayer to run in Fedora 19.1. Open /usr/bin/vmplayer in nano or other text editor of your choice, using sudo or su.2. Look for the lines that read as follows:Code:3. Add the following after the above lines:Code:4. Save the file. You should be able to at least get the program running after that.You also very likely will experience an error with building two of the required modules in Fedora 19 as VMPlayer tries to build them. There are two patches out there on the net that fix the problems with vmnet and vmblock with 3.10 kernels, if you are experiencing those problems. I did not write the patches and do not recall who did or where I got them, but here they are:vmblock.3.10.patchvmnet.3.10.patchHere is what you have to do with these patch files:1. Go to /lib/vmware/modules/source and copy the vmnet.tar and vmblock.tar archives to the desktop. Also put the patch files on your desktop.2. Extract files for VMNet and VMBlock TAR files to desktop. You will have two folders when done.3. Just cd into vmnet folder on desktop in terminal and runCode:4. Just cd into vmblock folder on desktop in terminal and run:Code:5. Put the folders back into the archives sitting on your desktop, rename the original TAR files in the folder mentioned in step 1, and put your modified tar files into the same source folder.After that, VMWare Player should run and rebuild the modules in Fedora 19 with 3.10 kernels.Hope this helps.&lt;/p>
- /posts/install_vmware_902_on_fedora_19/ - This is a customized copyright.</description></item><item><title>[zz]RHEL 5/6 差异：时间处理机制</title><link>/posts/zz_rhel_56_difference_time_handling_mechanism/</link><pubDate>Mon, 29 Jul 2013 17:13:00 +0000</pubDate><guid>/posts/zz_rhel_56_difference_time_handling_mechanism/</guid><description>seteuid0's blog /posts/zz_rhel_56_difference_time_handling_mechanism/ -&lt;p>when you use different linux system,you will find the time&amp;rsquo;s different between the systems,here is the reason.RHEL 5/6 差异：时间处理机制06.29.2012, 系统服务 , by Roger.RHEL 5/6 差异：时间处理机制作者：Roger简介本文介绍了在 RHEL5 和 RHEL 6 两个版本系统中，对待时间的差异。目的在于帮助我们了解系统，应对OS升级的改动。概述RHEL 5/6 时间机制差异类别RHEL 5RHEL 6建议Anaconda 参数timezone &amp;ndash;utc修改/etc/sysconfig/clock修改/etc/adjtime对用户透明，不用调整开机初始化脚本，硬件时钟到系统时钟/etc/rc.d/rc.sysinit传参调用hwclock内核直接读取rtc_cmos获取时间/etc/sysconfig/clock需要区分关机脚本，系统时钟到硬件时钟/etc/rc.d/init.d/halt传参数调用hwclock/etc/rc.d/init.d/halt直接调用hwclock/etc/sysconfig/clock需要区分NTP软件包一个包：ntp-4.2.2p1-9.el5_3.2三个包：ntp-4.2.4p8-2.el6.centos.i686ntp-perl-4.2.4p8-2.el6.centos.i686ntpdate-4.2.4p8-2.el6.centos.i686RHEL 6 把 RHEL 5 一个包拆成了三个RHEL 6 建议三个包都安装ntpd启动脚本一个脚本：/etc/rc.d/init.d/ntpd两个脚本：/etc/rc.d/init.d/ntpd/etc/rc.d/init.d/ntpdateRHEL 6 中添加了ntpdate启动脚本，相当于额外多了一个服务，需要注意RHEL 5 与 RHEL 6 中，时间这块，外围软件包改动并不大，例如hwclock，NTP。改动比较大的是：Anaconda安装系统时，timezone &amp;ndash;utc的处理方式。开机读取硬件时钟的机制。关机写入硬件时钟的机制。linux 时间存储 原理分析首先需要了解的概念：硬件时钟系统时钟其次，BIOS里硬件时钟存的仅是一个UNIX时间戳。这个时间戳，有UTC时钟和LOCAL时钟两钟存法。UTC时间LOCAL时间（本地时间）注意点：我们所说的system clock use UTC (timezone &amp;ndash;utc) 实际上就是指BIOS里的时钟存法。与系统的“时区”没有关系。这点不要混淆。这里举一个你常见的例子：笔记本双系统，win+linux，如果linux使用了UTC时间，那么两个系统就会差8小时。原因：Unix规范里BIOS时钟存UTC时间戳，但windows改成了只支持存LOCAL时间戳（就是你墙上的时间），而linux两个格式都支持。这时，如果你linux使用了UTC时间，就会把BIOS的时间戳当作UTC时间，而你的windows把BIOS时间戳当作LOCAL时间。所以无论你怎么调，两个系统时间都不会一致。hwclock说到linux下的时钟，一定不能忽略hwclock，硬件时钟和系统时钟的互写就全靠它了。后续我们详解hwclock的工作机制。推荐看 man clock。开机对时钟的处理我们电脑关机状态时，硬件上的晶振会持续保存一个时间，这个时间就是硬件时钟。进入BIOS便可以看到。开机后，系统将硬件时钟读入系统，然后开始维持时间的增长。硬件时钟仅开机读取一次，由于进入了OS，我们有很多途径让时钟更准确，比如NTP等，这时的硬件时钟对我们是没有用的。关机对时钟的处理要关机了，系统会把时间写入硬件时钟，相当于更新硬件时钟。RHEL 5/6 都是/etc/rc.d/init.d/halt调用hwclock来写入硬件时钟，细节上略有不同，但都是做一样的事情。hwclockRHEL 5/6 中hwclock机制并没有变化：这里需要注意的是：hwclock维护一个文件，/etc/adjtime，用来确定硬件时钟是UTC还是LOCAL。hwclock原理分析：我们直接执行hwclock，就是读取硬件时钟。01[root@centos6 install]# strace -e trace=open hwclock02open(&amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY)      = 303open(&amp;quot;/lib/libaudit.so.1&amp;quot;, O_RDONLY)    = 304open(&amp;quot;/lib/libc.so.6&amp;quot;, O_RDONLY)        = 305open(&amp;quot;/usr/lib/locale/locale-archive&amp;quot;, O_RDONLY|O_LARGEFILE) = 406open(&amp;quot;/usr/lib/locale/locale-archive&amp;quot;, O_RDONLY|O_LARGEFILE) = 407open(&amp;quot;/dev/rtc&amp;quot;, O_RDONLY|O_LARGEFILE)  = 408open(&amp;quot;/etc/adjtime&amp;quot;, O_RDONLY|O_LARGEFILE) = 509open(&amp;quot;/usr/share/zoneinfo/Universal&amp;quot;, O_RDONLY) = 510open(&amp;quot;/etc/localtime&amp;quot;, O_RDONLY)        = 511open(&amp;quot;/usr/share/locale/locale.alias&amp;quot;, O_RDONLY) = 512open(&amp;quot;/usr/share/locale/zh_CN.UTF-8/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)13open(&amp;quot;/usr/share/locale/zh_CN.utf8/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)14open(&amp;quot;/usr/share/locale/zh_CN/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = 515open(&amp;quot;/usr/share/locale/zh.UTF-8/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)16open(&amp;quot;/usr/share/locale/zh.utf8/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)17open(&amp;quot;/usr/share/locale/zh/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)18Wed 09 May 2012 05:56:55 PM CST  -0.430311 seconds1.hwclock首先打开了/dev/rtc,读取硬件时钟.2.打开/etc/adjtime文件,通过先前的记录来估算硬件时钟的偏差,并用来校正目前的时间.3.打开/etc/localtime时区文件,将硬件时间转换为当前时区对应的时间.我们执行hwclock -w &amp;ndash;debug，写入硬件时钟。同时打开debug模式，方便观察。01[root@centos6 install]# strace -e trace=open hwclock -w &amp;ndash;debug02open(&amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY)      = 303open(&amp;quot;/lib/libaudit.so.1&amp;quot;, O_RDONLY)    = 304open(&amp;quot;/lib/libc.so.6&amp;quot;, O_RDONLY)        = 305open(&amp;quot;/usr/lib/locale/locale-archive&amp;quot;, O_RDONLY|O_LARGEFILE) = 406open(&amp;quot;/usr/lib/locale/locale-archive&amp;quot;, O_RDONLY|O_LARGEFILE) = 407open(&amp;quot;/usr/share/locale/locale.alias&amp;quot;, O_RDONLY) = 408open(&amp;quot;/usr/share/locale/zh_CN.UTF-8/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)09open(&amp;quot;/usr/share/locale/zh_CN.utf8/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)10open(&amp;quot;/usr/share/locale/zh_CN/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = 411open(&amp;quot;/usr/share/locale/zh.UTF-8/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)12open(&amp;quot;/usr/share/locale/zh.utf8/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)13open(&amp;quot;/usr/share/locale/zh/LC_MESSAGES/util-linux-ng.mo&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)14hwclock from util-linux-ng 2.17.215open(&amp;quot;/dev/rtc&amp;quot;, O_RDONLY|O_LARGEFILE)  = 416Using /dev interface to clock.17open(&amp;quot;/etc/adjtime&amp;quot;, O_RDONLY|O_LARGEFILE) = 518Last drift adjustment done at 1336557886 seconds after 196919Last calibration done at 1336557886 seconds after 196920Hardware clock is on UTC time21Assuming hardware clock is kept in UTC time.22Waiting for clock tick&amp;hellip;23&amp;hellip;got clock tick24Time read from Hardware Clock: 2012/05/09 10:38:0725open(&amp;quot;/usr/share/zoneinfo/Universal&amp;quot;, O_RDONLY) = 526Hw clock time : 2012/05/09 10:38:07 = 1336559887 seconds since 196927open(&amp;quot;/etc/localtime&amp;quot;, O_RDONLY)        = 528Time elapsed since reference time has been 0.505254 seconds.29Delaying further to reach the new time.30Setting Hardware Clock to 10:38:08 = 1336559888 seconds since 196931ioctl(RTC_SET_TIME) was successful.32Not adjusting drift factor because it has been less than a day since the last calibration.33open(&amp;quot;/etc/adjtime&amp;quot;, O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE, 0666) = 51.打开/dev/rtc，读取硬件时钟。2.打开/etc/adjtime文件,通过先前的记录来估算硬件时钟的偏差,并用来校正目前的时间.3.打开/etc/localtime时区文件,将硬件时间转换为当前时区对应的时间.4.ioctl写入硬件时钟5.更新/etc/adjtime文件里的时间戳/etc/adjtime由hwclock维护，默认不需要我们修改。如果修改，也仅是 RHEL 6 上修改第三行。UTC / LOCAL 。1[root@centos6 install]# cat /etc/adjtime2-0.436938 1336541643 0.000000313365416434UTC不同之处的注意点在 RHEL 5 中，开机会读取/etc/sysconfig/clock，传参数给 hwclock，因此/etc/adjtime文件失效，会以/etc/sysconfig/clock为准。关机也同样是这个原理。在 RHEL 6 中，不再有/etc/sysconfig/clock的参与，hwclock直接读取/etc/adjtime处理时间格式。Anaconda我们安装系统时，一般设置为：timezone Asia/Shanghai。也就是不使用UTC时间。RHEL 5 中，Anaconda会修改/etc/sysconfig/clock文件。1[hongmeng@login1.cm4 ~]$ cat /etc/sysconfig/clock2ZONE=&amp;ldquo;Asia/Shanghai&amp;quot;3UTC=false4ARC=falseRHEL 6 中，Anaconda会直接修改/etc/adjtime文件。/etc/sysconfig/clock里UTC，ARC等配置无意义。因为/etc/rc.d/rc.sysinit和/etc/rc.d/init.d/halt已经不再读取/etc/sysconfig/clock。1[root@opsinfo1 ~]# cat /etc/sysconfig/clock2ZONE=&amp;ldquo;Asia/Shanghai&amp;quot;1[root@opsinfo1 ~]# cat /etc/adjtime2-0.004473 1336506385 0.000000313365063854LOCAL相关源码：RHEL 5 Anaconda：1usr/lib/anaconda/timezone.py2 3        f = open(instPath + &amp;ldquo;/etc/sysconfig/clock&amp;rdquo;, &amp;ldquo;w&amp;rdquo;)4 5        f.write(&amp;lsquo;ZONE=&amp;quot;%s&amp;quot;n&amp;rsquo; % self.tz)6        f.write(&amp;ldquo;UTC=%sn&amp;rdquo; % bool(self.utc))7        f.write(&amp;ldquo;ARC=%sn&amp;rdquo; % bool(self.arc))8 9        f.close()RHEL 6 Anaconda：01usr/lib/anaconda/timezone.py02 03        f = open(instPath + &amp;ldquo;/etc/adjtime&amp;rdquo;, &amp;ldquo;w&amp;rdquo;)04        f.write(lines[0])05        f.write(lines[1])06        if self.utc:07            f.write(&amp;ldquo;UTCn&amp;rdquo;)08        else:09            f.write(&amp;ldquo;LOCALn&amp;rdquo;)10        f.close()/etc/rc.d/rc.sysinitRHEL 5 中，开机启动脚本会读取/etc/sysconfig/clock，再传参调用hwclock。将硬件时钟写入系统时钟。01# Set the system clock.02update_boot_stage RCclock03ARC=004SRM=005UTC=006 07if [ -f /etc/sysconfig/clock ]; then08   . /etc/sysconfig/clock09 10   # convert old style clock config to new values11   if [ &amp;ldquo;${CLOCKMODE}&amp;rdquo; = &amp;ldquo;GMT&amp;rdquo; ]; then12      UTC=true13   elif [ &amp;ldquo;${CLOCKMODE}&amp;rdquo; = &amp;ldquo;ARC&amp;rdquo; ]; then14      ARC=true15   fi16fi17 18CLOCKDEF=&amp;ldquo;&amp;ldquo;19CLOCKFLAGS=&amp;quot;$CLOCKFLAGS &amp;ndash;hctosys&amp;quot;20 21case &amp;ldquo;$UTC&amp;rdquo; in22    yes|true)   CLOCKFLAGS=&amp;quot;$CLOCKFLAGS &amp;ndash;utc&amp;quot;23                CLOCKDEF=&amp;quot;$CLOCKDEF (utc)&amp;rdquo; ;;24    no|false)   CLOCKFLAGS=&amp;quot;$CLOCKFLAGS &amp;ndash;localtime&amp;quot;25                CLOCKDEF=&amp;quot;$CLOCKDEF (localtime)&amp;rdquo; ;;26esac27case &amp;ldquo;$ARC&amp;rdquo; in28    yes|true)   CLOCKFLAGS=&amp;quot;$CLOCKFLAGS &amp;ndash;arc&amp;quot;29                CLOCKDEF=&amp;quot;$CLOCKDEF (arc)&amp;rdquo; ;;30esac31case &amp;ldquo;$SRM&amp;rdquo; in32    yes|true)   CLOCKFLAGS=&amp;quot;$CLOCKFLAGS &amp;ndash;srm&amp;quot;33                CLOCKDEF=&amp;quot;$CLOCKDEF (srm)&amp;rdquo; ;;34esac35 36[ -x /sbin/hwclock ] &amp;amp;&amp;amp; /sbin/hwclock $CLOCKFLAGS37 38action $&amp;ldquo;Setting clock $CLOCKDEF: `date`&amp;rdquo; /bin/trueRHEL 6 中，开机启动脚本不再调用hwclock。/etc/rc.d/init.d/haltRHEL 5 中，关机脚本会读取/etc/sysconfig/clock，再传参调用hwclock。将系统时钟写入硬件时钟。01# Sync the system clock.02ARC=003SRM=004UTC=005 06if [ -f /etc/sysconfig/clock ]; then07   . /etc/sysconfig/clock08 09   # convert old style clock config to new values10   if [ &amp;ldquo;${CLOCKMODE}&amp;rdquo; = &amp;ldquo;GMT&amp;rdquo; ]; then11      UTC=true12   elif [ &amp;ldquo;${CLOCKMODE}&amp;rdquo; = &amp;ldquo;ARC&amp;rdquo; ]; then13      ARC=true14   fi15fi16 17CLOCKDEF=&amp;ldquo;&amp;ldquo;18CLOCKFLAGS=&amp;quot;$CLOCKFLAGS &amp;ndash;systohc&amp;quot;19 20case &amp;ldquo;$UTC&amp;rdquo; in21   yes|true)22    CLOCKFLAGS=&amp;quot;$CLOCKFLAGS -u&amp;rdquo;;23    CLOCKDEF=&amp;quot;$CLOCKDEF (utc)&amp;quot;;24    ;;25   no|false)26    CLOCKFLAGS=&amp;quot;$CLOCKFLAGS &amp;ndash;localtime&amp;rdquo;;27    CLOCKDEF=&amp;quot;$CLOCKDEF (localtime)&amp;quot;;28    ;;29esac30 31case &amp;ldquo;$ARC&amp;rdquo; in32   yes|true)33    CLOCKFLAGS=&amp;quot;$CLOCKFLAGS -A&amp;quot;;34    CLOCKDEF=&amp;quot;$CLOCKDEF (arc)&amp;quot;;35    ;;36esac37case &amp;ldquo;$SRM&amp;rdquo; in38   yes|true)39    CLOCKFLAGS=&amp;quot;$CLOCKFLAGS -S&amp;quot;;40    CLOCKDEF=&amp;quot;$CLOCKDEF (srm)&amp;quot;;41    ;;42esac43 44[ -x /sbin/hwclock ] &amp;amp;&amp;amp; action $&amp;ldquo;Syncing hardware clock to system time&amp;rdquo; /sbin/hwclock $CLOCKFLAGSRHEL 6 中，关机脚本不读取/etc/sysconfig/clock，直接调用hwclock。将系统时钟写入硬件时钟。1# Save random seed2touch /var/lib/random-seed3chmod 600 /var/lib/random-seed4action $&amp;ldquo;Saving random seed: &amp;quot; dd if=/dev/urandom of=/var/lib/random-seed count=1 bs=512 2&amp;gt;/dev/null5 6[ -x /sbin/hwclock -a -e /dev/rtc ] &amp;amp;&amp;amp; action $&amp;ldquo;Syncing hardware clock to system time&amp;rdquo; /sbin/hwclock &amp;ndash;systohc/etc/sysconfig/clockRHEL 5:1ZONE=&amp;ldquo;Asia/Shanghai&amp;quot;2UTC=false3ARC=falseRHEL 6:1ZONE=&amp;ldquo;Asia/Shanghai&amp;quot;NTP软件包RHEL 5 中，NTP 只有一个软件包。1ntp-4.2.2p1-9.el5_3.2RHEL 6 中，NTP 有三个软件包。1ntp-4.2.4p8-2.el6.centos.i6862ntp-perl-4.2.4p8-2.el6.centos.i6863ntpdate-4.2.4p8-2.el6.centos.i686内容其实是一样的，RHEL 6 里只是拆分了，这块可以看NTP相关的文档。ntpd启动脚本RHEL 5:/etc/rc.d/init.d/ntpdRHEL 6:/etc/rc.d/init.d/ntpd/etc/rc.d/init.d/ntpdate影响与应对配置文件/etc/sysconfig/clock需要区分，否则 RHEL 6 写了也不生效。RHEL 5:1ZONE=&amp;ldquo;Asia/Shanghai&amp;quot;2UTC=false3ARC=falseRHEL 6:1ZONE=&amp;ldquo;Asia/Shanghai&amp;quot;另外，RHEL 6里，三个包都建议装上。&lt;/p>
- /posts/zz_rhel_56_difference_time_handling_mechanism/ - This is a customized copyright.</description></item><item><title>[zz]“全球最牛”黑客美国暴毙 死前计划表演遥控杀人(图)</title><link>/posts/zz_quotthe_world39s_most_cattlequot_hackers_united_states_plans_to_perform_remote_kill_died_suddenly_died_figure/</link><pubDate>Mon, 29 Jul 2013 10:59:00 +0000</pubDate><guid>/posts/zz_quotthe_world39s_most_cattlequot_hackers_united_states_plans_to_perform_remote_kill_died_suddenly_died_figure/</guid><description>seteuid0's blog /posts/zz_quotthe_world39s_most_cattlequot_hackers_united_states_plans_to_perform_remote_kill_died_suddenly_died_figure/ -&lt;p>“全球最牛”黑客美国暴毙 死前计划表演遥控杀人(图)2013年07月29日 02:32来源：北京晨报分享到：4849人参与566条评论巴纳拜·杰克在黑客会议上，自动提款机不断吐出钞票。原标题：全球最牛黑客暴毙 生前曾让ATM机吐钞票 死前计划表演遥控杀人现年35岁的美国著名黑客巴纳拜·杰克(见图)在2010年“黑帽”黑客会议上利用他独创黑客技术令自动提款机狂吐钞票，一跃成为全球最牛的“明星黑客”。而他本打算在7月31日开幕的2013年“黑帽”黑客会议上，展示一项更为惊人的黑客绝技——遥控杀人。然而蹊跷的是，7月25日，就在这项“黑客绝技”曝光前夕，杰克突然在美国旧金山神秘死亡！据报道，巴纳拜·杰克是一名出生于新西兰的黑客、程序员和计算机安全专家。他曾花了2年时间研究如何破解自动提款机。2010年7月28日，在美国拉斯维加斯举行的一年一度的“黑帽”黑客会议上，杰克将2台ATM搬到“黑帽”会场上，他刚一执行破解程序，自动提款机便不断吐出钞票，在地上堆成一座小山！这段“提款机破解秀”堪称2010年“黑帽”黑客会议上最为轰动的精彩好戏。时隔整整3年之后，身为“明星黑客”的杰克重出江湖，打算在7月31日开幕的“黑帽”黑客会议上，展示一项更为惊人的“黑客绝技”——在9米之外入侵植入式心脏起搏器等无线医疗装置，然后向其发出一系列830V高压电击，从而令“遥控杀人”成为现实！杰克声称，他已经发现了多家厂商生产的心脏起搏器的安全漏洞。由于美国警方拒绝透露杰克死亡细节，杰克的死引发了各种疯狂阴谋论——有阴谋论者指出，杰克最新针对医疗设备的“遥控杀人”技术不仅会对公众的生活安全构成威胁，也将令生产这些存在漏洞的医疗设备的厂商的名誉和经济利益遭到重创，不排除杰克因此惹火烧身，招来杀身之祸。晨报综合消息&lt;/p>
- /posts/zz_quotthe_world39s_most_cattlequot_hackers_united_states_plans_to_perform_remote_kill_died_suddenly_died_figure/ - This is a customized copyright.</description></item></channel></rss>