<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>未分类 on seteuid0's blog</title><link>/tags/%E6%9C%AA%E5%88%86%E7%B1%BB/</link><description>Recent content in 未分类 on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Thu, 29 Mar 2018 00:51:27 +0000</lastBuildDate><atom:link href="/tags/%E6%9C%AA%E5%88%86%E7%B1%BB/index.xml" rel="self" type="application/rss+xml"/><item><title>drm</title><link>/posts/drm/</link><pubDate>Thu, 29 Mar 2018 00:51:27 +0000</pubDate><guid>/posts/drm/</guid><description>DRM - Direct Rendering Manager DRM是一个内核级的设备驱动，既可以编译到内核中也可以作为标准模块进行加载。DRM最初是在FreeBSD中出现的，后来被移植到Linux系统中，并成为Linux系统的标准部分。 DRM可以直接访问DRM clients的硬件。DRM驱动用来处理DMA，内存管理，资源锁以及安全硬件访问。为了同时支持多个3D应用，3D图形卡硬件必须作为一个共享资源，因此需要锁来提供互斥访问。DMA传输和AGP接口用来发送图形操作的buffers到显卡硬件，因此要防止客户端越权访问显卡硬件。 Linux DRM层用来支持那些复杂的显卡设备，这些显卡设备通常都包含可编程的流水线，非常适合3D图像加速。内核中的DRM层，使得这些显卡驱动在进行内存管理，中断处理和DMA操作中变得更容易，并且可以为上层应用提供统一的接口。</description></item><item><title>[zz]Debian / Ubuntu tasksel: Install Group Software (tasks) such As DNS / Web Server In A Single Click</title><link>/posts/zzdebian-ubuntu-tasksel-install-group-software-tasks-such-as-dns-web-server-in-a-single-click/</link><pubDate>Mon, 15 Jun 2015 14:53:19 +0000</pubDate><guid>/posts/zzdebian-ubuntu-tasksel-install-group-software-tasks-such-as-dns-web-server-in-a-single-click/</guid><description>&amp;rsquo;m looking for &amp;lsquo;yum groupinstall group&amp;rsquo; like command under Debian or Ubuntu Linux. How do I install group of softwares such as DNS or LAMP server in a single command? You need to use tasksel command. It is a software installation application that is an integral part of the Debian installer and works under Ubuntu Linux too. It groups some packages by tasks and offers the user an easy way to install the packages for that task.</description></item><item><title>ubuntu安装光盘iso修改方法总结</title><link>/posts/ubuntu%e5%ae%89%e8%a3%85%e5%85%89%e7%9b%98iso%e4%bf%ae%e6%94%b9%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93/</link><pubDate>Wed, 04 Feb 2015 06:19:10 +0000</pubDate><guid>/posts/ubuntu%e5%ae%89%e8%a3%85%e5%85%89%e7%9b%98iso%e4%bf%ae%e6%94%b9%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93/</guid><description>可以使用mount命令查看iso的内容#mkdir iso #mount -o loop ubuntu.iso ./iso把iso里面的内容取出来,iso_modify#mkdir iso\_modify #rsync -az ./iso ./iso\_modifyIso目录里面的casper/filesystem.squashfs就是启动以后的虚拟文件系统，我们要修改的就是这里的内容。#mkdir squashfs #cp iso/casper/filesystem.squashfs ./squashfs #cd squashfs解压squashfs#unsquashfs filesystem.squashfs可以看到解压出的squashfs-root目录就是一个文件系统，针对性的进行修改，如果需要安装deb包，可以chroot进去使用dpkg进行安装。 如果安装了软件包，需要跟新dpkg的列表：#chroot squashfs-root/ dpkg-query -W --showformat='${Package}\\t${Version}\\n' &amp;gt; dpkg\_list #cp dpkg\_list ../../iso\_modify/casper/filesystem.manifest把squashfs-root目录从新制作成squashfs文件#mksquashfs squashfs-root filesystem.squashfs -b 1024k -comp xz -Xbcj x86 -e boot用新的filesystem.squashfs替换原来的文件。 把新的iso-modify打包成iso``` #mkisofs -r -V &amp;ldquo;UbuntuTest&amp;rdquo; -cache-inodes -J -l -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o ../ubuntu-test.iso .</description></item><item><title>SELinux中核外应用查询策略API总结</title><link>/posts/selinux%e4%b8%ad%e6%a0%b8%e5%a4%96%e5%ba%94%e7%94%a8%e6%9f%a5%e8%af%a2%e7%ad%96%e7%95%a5api%e6%80%bb%e7%bb%93/</link><pubDate>Wed, 19 Feb 2014 15:23:31 +0000</pubDate><guid>/posts/selinux%e4%b8%ad%e6%a0%b8%e5%a4%96%e5%ba%94%e7%94%a8%e6%9f%a5%e8%af%a2%e7%ad%96%e7%95%a5api%e6%80%bb%e7%bb%93/</guid><description>SELinux中支持应用使用libselinux库来针对SELinux进行安全扩展（selinux aware application)，这样应用就可以使用SELinux的策略库来实现内部的访问控制，当前的passwd、dbus、udev等都使用selinux进行了扩展。其中passwd使用selinux进行密码修改检查，dbus对收、发进行了权限检查，分成了：acquire_svc和send_msg。 SELinux提供给用户空间的用户计算策略是否允许的接口主要有2类：selinux_check_access和avc_has_perm，下面对这两类接口进行说明。 selinux_check_access的函数原型为：
int selinux_check_access(const security_context_t scon, const security_context_t tcon, const char *class, const char *perm, void *audit‐ data);
需要输入的为主体、客体、客体类、权限集的字符串表示。 avc_has_perm的函数原型为：
int avc_has_perm(security_id_t ssid, security_id_t tsid, security_class_t tclass, access_vector_t requested, struct avc_entry_ref *aeref, void *auditdata);
需要输入的为主体、客体、客体类、权限集对应的id号，因此需要在使用以前将安全上下文与id号进行映射。在/usr/include/selinux/flask.h和/usr/include/selinux/av_permissions.h对客体类和权限集进行了定义，但是如果使用头文件中的编号，就导致应用与默认的refpolicy的编号顺序必须保持一致，否则容易导致编号与实际内容产生冲突。SELinux的开发者创建了selinux_set_mapping函数来动态建立客体类和权限集的映射关系。
int selinux_set_mapping(struct security_class_mapping *map); struct security_class_mapping { const char *name; const char *perms[]; };
例如：
static struct security_class_mapping dbus_map[] = { { &amp;ldquo;dbus&amp;rdquo;, { &amp;ldquo;acquire_svc&amp;rdquo;, &amp;ldquo;send_msg&amp;rdquo;, NULL } }, { NULL } }; #define DBUS__ACQUIRE_SVC 1 #define DBUS__SEND_MSG 2</description></item></channel></rss>