<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dtb on seteuid0's blog</title><link>/tags/dtb/</link><description>Recent content in dtb on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Mon, 23 Mar 2015 02:44:42 +0000</lastBuildDate><atom:link href="/tags/dtb/index.xml" rel="self" type="application/rss+xml"/><item><title>[ZZ]Device Tree（一）：背景介绍 为什么引入dtb</title><link>/posts/zzdevice-tree%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d/</link><pubDate>Mon, 23 Mar 2015 02:44:42 +0000</pubDate><guid>/posts/zzdevice-tree%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d/</guid><description>作者：linuxer 发布于：2014-5-22 16:46 分类：统一设备模型
一、前言 作为一个多年耕耘在linux 2.6.23内核的开发者，各个不同项目中各种不同周边外设驱动的开发以及各种琐碎的、扯皮的俗务占据了大部分的时间。当有机会下载3.14的内核并准备学习的时候，突然发现linux kernel对于我似乎变得非常的陌生了，各种新的机制，各种framework、各种新的概念让我感到阅读内核代码变得举步维艰。 还好，剖析内核的热情还在，剩下的就交给时间的。首先进入视线的是Device Tree机制，这是和porting内核非常相关的机制，如果想让将我们的硬件平台迁移到高版本的内核上，Device Tree是一个必须要扫清的障碍。 我想从下面三个方面来了解Device Tree： 1、为何要引入Device Tree，这个机制是用来解决什么问题的？（这是本文的主题） 2、Device Tree的基础概念（请参考DT基础概念） 3、ARM linux中和Device Tree相关的代码分析（请参考DT代码分析） 阅读linux内核代码就像欣赏冰山，有看得到的美景（各种内核机制及其代码），也有埋在水面之下看不到的基础（机制背后的源由和目的）。沉醉于各种内核机制的代码固然有无限乐趣，但更重要的是注入更多的思考，思考其背后的机理，真正理解软件抽象。这样才能举一反三，并应用在具体的工作和生活中。 本文主要从下面几个方面阐述为何ARM linux会引入Device Tree： 1、没有Device Tree的ARM linux是如何运转的？ 2、混乱的ARM architecture代码和存在的问题 3、新内核的解决之道 二、没有Device Tree的ARM linux是如何运转的？ 我曾经porting内核到两个ARM-based的平台上。一个是小的芯片公司的应用处理器，公司自己购买了CPU core，该CPU core使用ARM兼容的指令集（但不是ARM）加上各种公司自行设计的多媒体外设整合成公司的产品进行销售。而我的任务就是porting 2.4.18内核到该平台上。在黑白屏幕的手机时代，那颗AP（application process）支持了彩屏、camera、JPEG硬件加速、2D/3D加速、MMC/SD卡、各种音频加速（内置DSP）等等特性，功能强大到无法直视。另外一次移植经历是让2.6.23内核跑在一个大公司的冷门BP（baseband processor）上。具体porting的方法是很简单的： 1、自己撰写一个bootloader并传递适当的参数给kernel。除了传统的command line以及tag list之类的，最重要的是申请一个machine type，当拿到属于自己项目的machine type ID的时候，当时心情雀跃，似乎自己已经是开源社区的一份子了（其实当时是有意愿，或者说有目标是想将大家的代码并入到linux kernel main line的）。 2、在内核的arch/arm目录下建立mach-xxx目录，这个目录下，放入该SOC的相关代码，例如中断controller的代码，时间相关的代码，内存映射，睡眠相关的代码等等。此外，最重要的是建立一个board specific文件，定义一个machine的宏：
MACHINE_START(project name, &amp;ldquo;xxx公司的xxx硬件平台&amp;rdquo;) .phys_io = 0x40000000, .boot_params = 0xa0000100, .io_pg_offst = (io_p2v(0x40000000) &amp;raquo; 18) &amp;amp; 0xfffc, .map_io = xxx_map_io, .</description></item></channel></rss>