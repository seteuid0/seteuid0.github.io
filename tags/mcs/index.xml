<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mcs on seteuid0's blog</title><link>/tags/mcs/</link><description>Recent content in mcs on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Mon, 20 Jan 2014 06:57:10 +0000</lastBuildDate><atom:link href="/tags/mcs/index.xml" rel="self" type="application/rss+xml"/><item><title>SELinux策略约束（constrain）里的L与H</title><link>/posts/selinux%e7%ad%96%e7%95%a5%e9%87%8c%e7%9a%84l%e4%b8%8eh/</link><pubDate>Mon, 20 Jan 2014 06:57:10 +0000</pubDate><guid>/posts/selinux%e7%ad%96%e7%95%a5%e9%87%8c%e7%9a%84l%e4%b8%8eh/</guid><description>在SELinux里，除了使用TE（type enforcement）来实现强制访问控制，还可以使用MLS机制的MCS或MLS。 MCS是single-sensitivity的安全机制，通过不同的categories来实现控制效果。 MCS的控制规则只能在base策略里面实现，如果想要修改refpolicy里的默认控制规则，可以修改策略里的mcs文件。MCS的基础内容如下：
mlsconstrain dir { search read ioctl lock } (( h1 dom h2 ) or ( t1 != mcs_constrained_type )); mlsconstrain dir { write setattr append unlink link rename add_name remove_name } (( h1 dom h2 ) or ( t1 != mcs_constrained_type ));
里面的mlsconstrain是约束语法，dir{search &amp;hellip;.}是对应的客体类和权限集。后面的就是MCS约束的定义。分为T、L、H{1/2}，分别表示类型（type），低安全集（L）和高安全集（H），之后的1，或2描述该表达式所限定的主体与客体，即L1表示主体的低安全级，如果上下文system_u:system_r:httpd_t:s0-s0:c0.c1024中，L1就是s0。 在selinux里面，看上面MCS对dir的约束定义，大家可能会有一个疑虑，selinux都是默认对当前级别（low level）进行判断，策略里面怎么是对high level进行判断。 看了下selinux的内核代码才知道缘由。 在selinux进行inode_doinit_with_dentry的时候，security_context_to_sid_default会到用到mls_context_to_sid对mls部分的上下文进行处理。该函数后部分有如下代码
if (l == 0) { context-&amp;gt;range.level[1].sens = context-&amp;gt;range.level[0].sens; rc = ebitmap_cpy(&amp;amp;context-&amp;gt;range.level[1].cat, &amp;amp;context-&amp;gt;range.level[0].cat); if (rc) goto out; }</description></item></channel></rss>