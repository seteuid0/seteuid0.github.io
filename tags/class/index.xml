<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>class on seteuid0's blog</title><link>/tags/class/</link><description>Recent content in class on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Wed, 16 Oct 2013 09:45:00 +0000</lastBuildDate><atom:link href="/tags/class/index.xml" rel="self" type="application/rss+xml"/><item><title>selinux客体类实验分析</title><link>/posts/experimental_analysis_selinux_object_class/</link><pubDate>Wed, 16 Oct 2013 09:45:00 +0000</pubDate><guid>/posts/experimental_analysis_selinux_object_class/</guid><description>内核从2.6.33开始实现对策略的dynamic class/perm discovery,修改了内核中客体类的存放方式，使得class indices不再关联实际值。即策略中的客体类的位置可以随意写。RHEL6系列的内核将该功能下移，在RHEL6.0正式版本的内核中便有该功能（beta版本中没有）。实验：采用dummy策略添加新的客体类使用notebook的security_compute_av_example用例，对自己新加的客体类进行测试。修改notebook.conf文件，添加user_u:base_r:base_t测试一如果采用标准2.6.32.25内核，可以添加新的客体类。但是在如dummy策略中，添加的客体类位置不能影响默认的内核客体类，如必须替代里面用户空间的客体类，或者再最后面添加。自己给里面添加了20个，运行正常。如果覆盖了默认内核客体类的位置,load_policy时提示策略加载失败。Class 1 is incorrect ,found class1 but should be security如果采用新内核，则可以在任意位置添加客体类，系统及策略均运行正常。等有空的时候再研究下策略加载，理解里面class在内核的存放以及使用方式才能真正理解该patch的作用。Perm获取最后通过discover_class通过读取/class/*/index,以及/class/*/perms/下面的内容来获取客体类及权限相关的内容里面涉及到比较多的调用通过实验如果是一个新的，通过策略添加的用户空间的客体类和权限，那么在测试的时候，数据是使用策略中的数据，而不是头文件中定义的数据。所以应该是通过接口文件从策略里面读取出来的。相关的2个patch如下</description></item></channel></rss>