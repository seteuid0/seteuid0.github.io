<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>selinux class on seteuid0's blog</title><link>/tags/selinux-class/</link><description>Recent content in selinux class on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Wed, 06 Nov 2013 13:06:00 +0000</lastBuildDate><atom:link href="/tags/selinux-class/index.xml" rel="self" type="application/rss+xml"/><item><title>selinux支持动态客体类添加</title><link>/posts/adding_support_for_dynamic_object_class_selinux/</link><pubDate>Wed, 06 Nov 2013 13:06:00 +0000</pubDate><guid>/posts/adding_support_for_dynamic_object_class_selinux/</guid><description>现在linux内核大概从2.6.33开始支持动态客体了的添加，即可以不重新编译内核，直接编译selinux策略即可添加客体类，这样做有什么好处呢？如过开发一个selnux aware的应用程序，且该程序引入了一个或多个客体类，则可以直接修改策略，即可以使用。所以现在核外的很多应用都针对的进行了修改，核外请求客体类和操作集的时候应该都是用名字，即“class”和&amp;quot;perm&amp;quot;来传递到内核进行判断，如果是传递flask.h或av_permissions.h中的值，则可能会导致请求的客体类和内核所设定的客体类不匹配的问题。所以核外应该使用selinux_set_mapping或者selinux_access_check来进行检查，而不知直接使用avc_has_perm.</description></item></channel></rss>