<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>selinux on seteuid0's blog</title><link>/tags/selinux/</link><description>Recent content in selinux on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Thu, 20 Nov 2014 14:52:52 +0000</lastBuildDate><atom:link href="/tags/selinux/index.xml" rel="self" type="application/rss+xml"/><item><title>grsecurity系列之一:概述及简易安装部署</title><link>/posts/grsecurity%e7%b3%bb%e5%88%97%e4%b9%8b%e4%b8%80%e6%a6%82%e8%bf%b0%e5%8f%8a%e7%ae%80%e6%98%93%e5%ae%89%e8%a3%85%e9%83%a8%e7%bd%b2/</link><pubDate>Thu, 20 Nov 2014 14:52:52 +0000</pubDate><guid>/posts/grsecurity%e7%b3%bb%e5%88%97%e4%b9%8b%e4%b8%80%e6%a6%82%e8%bf%b0%e5%8f%8a%e7%ae%80%e6%98%93%e5%ae%89%e8%a3%85%e9%83%a8%e7%bd%b2/</guid><description>近日准备分析下grsecurity，把过程总结记录下与大家分享、讨论。 SELinux应该很多人都知道，不错，它是Linux的LSM框架下强制访问控制机制中使用较为普遍的一种，由NSA开发。在RHEL、Fedora系统中可以看到它的身影，而apparmor被ubuntu维护并默认使用。基本上这两种强制访问控制机制是当前Linux系统中使用最为广泛的。grsecurity没有使用LSM框架，而是对应kernel upstream的不同主流版本发布不同的patch。部署起来没有系统默认安装的selinux、apparmor那么方便，但存在即有意义。grsecurity发展有13年之久，这么多年为什么一直都没有进入内核，以及它与selinux、apparmor相比有什么差别，此次暂不评述。不可否认的是由于grsecurity实现时超出LSM框架，所以实现了很多其他强制访问控制机制所不能、或很难实现的功能，本系列文章分别描述，如有不周，请大家批评指正。 grsecurity官网上从Memroy Corruption defenses、Filesystem Hardening、Miscellaneous Protections、RBAC、GCC Plugins几个方面描述其特性，之后做详尽描述。
安装 从http://grsecurity.net/download.php可以看到当前稳定版本所对应的内核版本。下载对应的内核版本及grsecurity的patch。本处使用linux-3.2.64内核版本及grsecurity-3.0-3.2.64-201411150025.patch 补丁。``` #tar xf linux-3.2.64.tar.xz #cd linux-3.2.64 #patch -p1 &amp;lt; ../grsecurity-3.0-3.2.64-201411150025.patch #make menuconfig #make DISABLE_PAX_PLUGINS=y -j8 #make DISABLE_PAX_PLUGINS=y -j8 modules #sudo make DISABLE_PAX_PLUGINS=y -j8 modules_install #sudo make DISABLE_PAX_PLUGINS=y -j8 install
1. 由于安装了gcc-&amp;lt;ver&amp;gt;-plugin-dev，还是提示无法找到，因此本次去除该特性； 2. grsecurity的配置在&amp;quot;security options&amp;quot;-&amp;gt;&amp;quot;grsecurity&amp;quot;里面，本次可以使用Automatic配置，之后在做调整 3. \-j8指定并行编译的进程数，可使用CPU数的2倍 之后大家还可以下载、编译安装gradm。 重启~~~ Ok，可以开始体验grsecurity了～</description></item><item><title>SELinux中核外应用查询策略API总结</title><link>/posts/selinux%e4%b8%ad%e6%a0%b8%e5%a4%96%e5%ba%94%e7%94%a8%e6%9f%a5%e8%af%a2%e7%ad%96%e7%95%a5api%e6%80%bb%e7%bb%93/</link><pubDate>Wed, 19 Feb 2014 15:23:31 +0000</pubDate><guid>/posts/selinux%e4%b8%ad%e6%a0%b8%e5%a4%96%e5%ba%94%e7%94%a8%e6%9f%a5%e8%af%a2%e7%ad%96%e7%95%a5api%e6%80%bb%e7%bb%93/</guid><description>SELinux中支持应用使用libselinux库来针对SELinux进行安全扩展（selinux aware application)，这样应用就可以使用SELinux的策略库来实现内部的访问控制，当前的passwd、dbus、udev等都使用selinux进行了扩展。其中passwd使用selinux进行密码修改检查，dbus对收、发进行了权限检查，分成了：acquire_svc和send_msg。 SELinux提供给用户空间的用户计算策略是否允许的接口主要有2类：selinux_check_access和avc_has_perm，下面对这两类接口进行说明。 selinux_check_access的函数原型为：
int selinux_check_access(const security_context_t scon, const security_context_t tcon, const char *class, const char *perm, void *audit‐ data);
需要输入的为主体、客体、客体类、权限集的字符串表示。 avc_has_perm的函数原型为：
int avc_has_perm(security_id_t ssid, security_id_t tsid, security_class_t tclass, access_vector_t requested, struct avc_entry_ref *aeref, void *auditdata);
需要输入的为主体、客体、客体类、权限集对应的id号，因此需要在使用以前将安全上下文与id号进行映射。在/usr/include/selinux/flask.h和/usr/include/selinux/av_permissions.h对客体类和权限集进行了定义，但是如果使用头文件中的编号，就导致应用与默认的refpolicy的编号顺序必须保持一致，否则容易导致编号与实际内容产生冲突。SELinux的开发者创建了selinux_set_mapping函数来动态建立客体类和权限集的映射关系。
int selinux_set_mapping(struct security_class_mapping *map); struct security_class_mapping { const char *name; const char *perms[]; };
例如：
static struct security_class_mapping dbus_map[] = { { &amp;ldquo;dbus&amp;rdquo;, { &amp;ldquo;acquire_svc&amp;rdquo;, &amp;ldquo;send_msg&amp;rdquo;, NULL } }, { NULL } }; #define DBUS__ACQUIRE_SVC 1 #define DBUS__SEND_MSG 2</description></item><item><title>SELinux策略约束（constrain）里的L与H</title><link>/posts/selinux%e7%ad%96%e7%95%a5%e9%87%8c%e7%9a%84l%e4%b8%8eh/</link><pubDate>Mon, 20 Jan 2014 06:57:10 +0000</pubDate><guid>/posts/selinux%e7%ad%96%e7%95%a5%e9%87%8c%e7%9a%84l%e4%b8%8eh/</guid><description>在SELinux里，除了使用TE（type enforcement）来实现强制访问控制，还可以使用MLS机制的MCS或MLS。 MCS是single-sensitivity的安全机制，通过不同的categories来实现控制效果。 MCS的控制规则只能在base策略里面实现，如果想要修改refpolicy里的默认控制规则，可以修改策略里的mcs文件。MCS的基础内容如下：
mlsconstrain dir { search read ioctl lock } (( h1 dom h2 ) or ( t1 != mcs_constrained_type )); mlsconstrain dir { write setattr append unlink link rename add_name remove_name } (( h1 dom h2 ) or ( t1 != mcs_constrained_type ));
里面的mlsconstrain是约束语法，dir{search &amp;hellip;.}是对应的客体类和权限集。后面的就是MCS约束的定义。分为T、L、H{1/2}，分别表示类型（type），低安全集（L）和高安全集（H），之后的1，或2描述该表达式所限定的主体与客体，即L1表示主体的低安全级，如果上下文system_u:system_r:httpd_t:s0-s0:c0.c1024中，L1就是s0。 在selinux里面，看上面MCS对dir的约束定义，大家可能会有一个疑虑，selinux都是默认对当前级别（low level）进行判断，策略里面怎么是对high level进行判断。 看了下selinux的内核代码才知道缘由。 在selinux进行inode_doinit_with_dentry的时候，security_context_to_sid_default会到用到mls_context_to_sid对mls部分的上下文进行处理。该函数后部分有如下代码
if (l == 0) { context-&amp;gt;range.level[1].sens = context-&amp;gt;range.level[0].sens; rc = ebitmap_cpy(&amp;amp;context-&amp;gt;range.level[1].cat, &amp;amp;context-&amp;gt;range.level[0].cat); if (rc) goto out; }</description></item><item><title>编码版b374k实现分析</title><link>/posts/%e7%bc%96%e7%a0%81%e7%89%88b374k%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</link><pubDate>Fri, 10 Jan 2014 09:54:37 +0000</pubDate><guid>/posts/%e7%bc%96%e7%a0%81%e7%89%88b374k%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</guid><description>实验PHP+SELINUX的时候，使用B374k，发现PHP文件的上下文意外的发生了变化，Inode号却没有发生变化，审计日志里也找不到relabel相关信息，就想一探究竟。 看代码发现上下文变化的这个版本是代码进行了编码处理的，从google code里找到的那些没有编码处理的版本上下文不会发生变化，看来只能对解码处理。 第一层使用了简单的“.&amp;ldquo;符号把字符串进行了分割，将$b374k=@create_function('$x',&amp;lsquo;ev&amp;rsquo;.&amp;lsquo;al&amp;rsquo;.'(gz'.&amp;lsquo;inf&amp;rsquo;.&amp;lsquo;late&amp;rsquo;.'(bas'.&amp;lsquo;e64&amp;rsquo;.'_de'.&amp;lsquo;co&amp;rsquo;.&amp;lsquo;de($x)));');处理后就可以看到(gzinflate(base64_decode($x)))；使用这个函数把后面的解码就可以得到解密后的代码。将代码格式化处理下，可以看到前半部分还是编码后的代码，后半部分有一些功能代码。
eval(gzinflate(base64_decode($x7774cacf))); rebirth(); eval(gzinflate(base64_decode(hate($xc3a649b2,$xec8e9aa2))));
同样，去掉eval，通过gzinflate(base64_decode($x7774cacf))解码，得到上面的功能代码，将解码后的内容格式化可以得到
里面是基础的编码、解码、生成随机数功能函数，可以注意到里面的rebirth函数，该函数将该PHP文件重新编码后替换当前的PHP文件。而随后的代码便调用了rebirth()函数，实现了这个webshell的rebirth。 而eval(gzinflate(base64_decode(hate($xc3a649b2,$xec8e9aa2))));就是执行本次请求的功能。可以找一个文件将该解码后的内容拷贝进去进行验证，功能与预期一致。 目前知道了上下文改变是由于用新生成的文件替换了之前的老文件，但是为什么inode号会保持一致？对该文件进行审计,将日志处理后可以看到。
syscall=4 ppid=2563 pid=2617 syscall=2 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13403 syscall=21 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13403 syscall=87 ppid=2563 pid=13403 syscall=82 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13404 syscall=2 ppid=2563 pid=13405 syscall=2 ppid=2563 pid=13405 syscall=2 ppid=2563 pid=13404 syscall=87 ppid=2563 pid=13405 syscall=82 ppid=2563 pid=13405 syscall=87 ppid=2563 pid=13404 syscall=82 ppid=2563 pid=13404 syscall=2 ppid=2563 pid=13406 syscall=2 ppid=2563 pid=13406 syscall=87 ppid=2563 pid=13406 syscall=82 ppid=2563 pid=13406 syscall=2 ppid=2563 pid=13407 syscall=2 ppid=2563 pid=13407 syscall=87 ppid=2563 pid=13407 syscall=82 ppid=2563 pid=13407</description></item><item><title>sudo对selinux的支持及用法</title><link>/posts/sudo_for_selinux_support_and_usage/</link><pubDate>Mon, 02 Dec 2013 02:42:00 +0000</pubDate><guid>/posts/sudo_for_selinux_support_and_usage/</guid><description>sudo已经主持selinux，这样就可以在切换uid的同时切换上下文。实现的方式大致如下：再selinux.c的文件里面，提到了借鉴newrole的代码， 实验创建test用户 semanage login -a -s staff_u test修改sudoers文件，test ALL=(ALL) ROLE=sysadm_r TYPE=sysadm_t ALL然后使用test用户登陆,在执行sudo -Es后便转换上下文</description></item><item><title>selinux支持动态客体类添加</title><link>/posts/adding_support_for_dynamic_object_class_selinux/</link><pubDate>Wed, 06 Nov 2013 13:06:00 +0000</pubDate><guid>/posts/adding_support_for_dynamic_object_class_selinux/</guid><description>现在linux内核大概从2.6.33开始支持动态客体了的添加，即可以不重新编译内核，直接编译selinux策略即可添加客体类，这样做有什么好处呢？如过开发一个selnux aware的应用程序，且该程序引入了一个或多个客体类，则可以直接修改策略，即可以使用。所以现在核外的很多应用都针对的进行了修改，核外请求客体类和操作集的时候应该都是用名字，即“class”和&amp;quot;perm&amp;quot;来传递到内核进行判断，如果是传递flask.h或av_permissions.h中的值，则可能会导致请求的客体类和内核所设定的客体类不匹配的问题。所以核外应该使用selinux_set_mapping或者selinux_access_check来进行检查，而不知直接使用avc_has_perm.</description></item><item><title>selinux客体类实验分析</title><link>/posts/experimental_analysis_selinux_object_class/</link><pubDate>Wed, 16 Oct 2013 09:45:00 +0000</pubDate><guid>/posts/experimental_analysis_selinux_object_class/</guid><description>内核从2.6.33开始实现对策略的dynamic class/perm discovery,修改了内核中客体类的存放方式，使得class indices不再关联实际值。即策略中的客体类的位置可以随意写。RHEL6系列的内核将该功能下移，在RHEL6.0正式版本的内核中便有该功能（beta版本中没有）。实验：采用dummy策略添加新的客体类使用notebook的security_compute_av_example用例，对自己新加的客体类进行测试。修改notebook.conf文件，添加user_u:base_r:base_t测试一如果采用标准2.6.32.25内核，可以添加新的客体类。但是在如dummy策略中，添加的客体类位置不能影响默认的内核客体类，如必须替代里面用户空间的客体类，或者再最后面添加。自己给里面添加了20个，运行正常。如果覆盖了默认内核客体类的位置,load_policy时提示策略加载失败。Class 1 is incorrect ,found class1 but should be security如果采用新内核，则可以在任意位置添加客体类，系统及策略均运行正常。等有空的时候再研究下策略加载，理解里面class在内核的存放以及使用方式才能真正理解该patch的作用。Perm获取最后通过discover_class通过读取/class/*/index,以及/class/*/perms/下面的内容来获取客体类及权限相关的内容里面涉及到比较多的调用通过实验如果是一个新的，通过策略添加的用户空间的客体类和权限，那么在测试的时候，数据是使用策略中的数据，而不是头文件中定义的数据。所以应该是通过接口文件从策略里面读取出来的。相关的2个patch如下</description></item></channel></rss>