<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on seteuid0's blog</title><link>/tags/linux/</link><description>Recent content in linux on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Wed, 18 Dec 2019 13:17:15 +0000</lastBuildDate><atom:link href="/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Run macOS on QEMU/KVM</title><link>/posts/run-macos-on-qemu-kvm/</link><pubDate>Wed, 18 Dec 2019 13:17:15 +0000</pubDate><guid>/posts/run-macos-on-qemu-kvm/</guid><description>有需要跑macOS，遂找资料进行下初期的技术验证。看了一些网页后大多都基于https://github.com/kholia/OSX-KVM 来做，简单验证流程如下： 使用fedora30系统（系统运行qemu的操作省略）``` git clone https://github.com/kholia/OSX-KVM.git cd OSX-KVM ./fetch-macOS.py
ProductID Version Build Post Date Title 1 041-91758 10.13.6 17G66 2019-10-19 macOS High Sierra 2 041-88800 10.14.4 18E2034 2019-10-23 macOS Mojave 3 061-26589 10.14.6 18G103 2019-10-14 macOS Mojave 4 061-10700 10.15.2 19C57 2019-12-10 macOS Catalina 5 041-90855 10.13.5 17F66a 2019-10-23 Install macOS High Sierra Beta 6 061-26578 10.14.5 18F2059 2019-10-14 macOS Mojave 7 061-44345 10.15.2 19C39d 2019-11-15 macOS Catalina Beta Choose a product to download (1-7): 2</description></item><item><title>Rockchip linux sdk buildroot使用记录</title><link>/posts/rockchip-linux-sdk-buildroot%e4%bd%bf%e7%94%a8%e8%ae%b0%e5%bd%95/</link><pubDate>Sat, 02 Nov 2019 08:55:07 +0000</pubDate><guid>/posts/rockchip-linux-sdk-buildroot%e4%bd%bf%e7%94%a8%e8%ae%b0%e5%bd%95/</guid><description>Rockchip Linux SDK里面的buildroot可以制作一个简洁的rootfs，但按照文档还是有一些问题，以下是使用时大致的一个记录及代码修改记录。 SDK从 http://opensource.rock-chips.com/wiki_Linux_SDK 获取。http://opensource.rock-chips.com/wiki_Source 里面有使用方法。 先要获取repogit clone https://github.com/rockchip-linux/repo mkdir linux cd linux而后同步代码，我这里使用的是RK3399的代码，由于网络原因可能会有超时发生，可以使用后面的脚本进行多次获取。``` ../repo/repo init &amp;ndash;repo-url=https://github.com/rockchip-linux/repo -u https://github.com/rockchip-linux/manifests -b master -m rk3399_linux_release.xml ../repo/repo sync
#!/bin/sh ../repo/repo sync -c while \[ $? -ne 0 \] ; do ../repo/repo sync -c; done ```代码就绪后就可以开始动手编译了。``` #cd u-boot #./make.sh evb-rk3399 $ source buildroot/build/envsetup.sh You're building on Linux Lunch menu...pick a combo: 1. rockchip\_rk3308\_release 2. rockchip\_rk3308\_debug 3. rockchip\_rk3308\_robot\_release 4. rockchip\_rk3308\_robot\_debug 5. rockchip\_rk3308\_mini\_release Which would you like?</description></item><item><title>[ZZ]v4l2的学习建议和流程解析</title><link>/posts/zzv4l2%e7%9a%84%e5%ad%a6%e4%b9%a0%e5%bb%ba%e8%ae%ae%e5%92%8c%e6%b5%81%e7%a8%8b%e8%a7%a3%e6%9e%90/</link><pubDate>Tue, 20 Aug 2019 13:28:31 +0000</pubDate><guid>/posts/zzv4l2%e7%9a%84%e5%ad%a6%e4%b9%a0%e5%bb%ba%e8%ae%ae%e5%92%8c%e6%b5%81%e7%a8%8b%e8%a7%a3%e6%9e%90/</guid><description>最近设计摄像头相关工作，之前虽然断断续续对V4L有些了解但不系统，在网上搜索了下发现V4L2应用还是非常广泛，所以资料也非常多，转载一片整理的比较全面的，就不重复造轮子了。 原文地址：https://www.cnblogs.com/silence-hust/p/4464291.html v4l2，一开始听到这个名词的时候，以为又是一个很难很难的模块，涉及到视频的处理，后来在网上各种找资料后，才发现其实v4l2已经分装好了驱动程序，只要我们根据需要调用相应的接口和函数，从而实现视频的获取和处理。只要认真的看几篇文章就对v4l2有一定的了解了，由于是第一次接触，网上的资料良莠不齐，难得可以找到几篇自己感觉很不错的。记录下来：（没必要看太多，很多都是一样的意思） http://www.embedu.org/Column/Column320.htm 这篇是不错的介绍，很讨厌有弹窗 http://www.cnblogs.com/emouse/archive/2013/03/04/2943243.html 这个可以作为第一篇来看，博主整理的不错 http://blog.chinaunix.net/uid-11765716-id-2855735.html 这篇也比较详细 http://blog.csdn.net/ddddwant/article/details/8475211 这篇提到的问题和我遇到的一样，花屏了，内存没有读取好 http://my.oschina.net/u/1024767/blog/210801#OSC_h2_14 对capture.c文件的解读 http://blog.csdn.net/g_salamander/article/details/8107692 对各个结构体有比较好的说明 一、Video for Linux two v4l2为linux下视频设备程序提供了一套接口规范。包括一套数据结构和底层V4L2驱动接口。只能在linux下使用。它使程序有发现设备和操作设备的能力。它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。当然也可以用于其他多媒体的开发，如音频等。 在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文是/dev/v4l/video0。为了通用，可以建立一个到/dev/video0的链接。V4L2支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)。V4L2在include/linux/videodev.h文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。V4L2从Linux 2.5.x版本的内核中开始出现。
　V4L2规范中不仅定义了通用API元素(Common API Elements)，图像的格式(Image Formats)，输入/输出方法(Input/Output)，还定义了Linux内核驱动处理视频信息的一系列接口(Interfaces)，这些接口主要有：
　视频采集接口——Video Capture Interface; 视频输出接口—— Video Output Interface; 视频覆盖/预览接口——Video Overlay Interface; 视频输出覆盖接口——Video Output Overlay Interface; 编解码接口——Codec Interface。
二、v4l2结构体介绍 1、常用的结构体在内核目录include/linux/videodev2.h中定义
 struct v4l2_requestbuffers //申请帧缓冲，对应命令VIDIOC_REQBUFS struct v4l2_capability //视频设备的功能，对应命令VIDIOC_QUERYCAP struct v4l2_input //视频输入信息，对应命令VIDIOC_ENUMINPUT struct v4l2_standard //视频的制式，比如PAL，NTSC，对应命令VIDIOC_ENUMSTD struct v4l2_format //帧的格式，对应命令VIDIOC_G_FMT、VIDIOC_S_FMT等 struct v4l2_buffer //驱动中的一帧图像缓存，对应命令VIDIOC_QUERYBUF struct v4l2_crop //视频信号矩形边框 v4l2_std_id //视频制式</description></item><item><title>After upgrade to Fedora 28 cannot set locale</title><link>/posts/after-upgrade-to-fedora-28-cannot-set-locale/</link><pubDate>Sun, 29 Jul 2018 15:45:50 +0000</pubDate><guid>/posts/after-upgrade-to-fedora-28-cannot-set-locale/</guid><description>升级F28以后出现类似如下错误``` [root@KlausPC opt]# LC_ALL=C [root@KlausPC opt]# LC_ALL=CX -bash: warning: setlocale: LC_ALL: cannot change locale (CX): No such file or directory [root@KlausPC opt]# LC_ALL=de_DE.utf8 -bash: warning: setlocale: LC_ALL: cannot change locale (de_DE.utf8): No such file or directory [root@KlausPC opt]# exit logout [testuser@KlausPC ~]$ LC_ALL=de_DE.utf8 bash: warning: setlocale: LC_ALL: cannot change locale (de_DE.utf8): No such file or directory [testuser@KlausPC ~]$ su - Password: -bash: Warnung: setlocale: LC_TIME: Kann die Standorteinstellungen nicht ��ndern (de_DE.</description></item><item><title>基于Aliyun自己实现DDNS</title><link>/posts/%e5%9f%ba%e4%ba%8ealiyun%e8%87%aa%e5%b7%b1%e5%ae%9e%e7%8e%b0ddns/</link><pubDate>Fri, 20 Jul 2018 18:37:01 +0000</pubDate><guid>/posts/%e5%9f%ba%e4%ba%8ealiyun%e8%87%aa%e5%b7%b1%e5%ae%9e%e7%8e%b0ddns/</guid><description>很多时候需要在外面访问家里的电脑资源（如PC、NAS等），但由于个人宽带一般都是拨号上网没有固定的IP，所以如何实现随时获取家里IP是一个刚需。 开始前还是补充点前提条件，
你的网络必须有一个公网IP，否则DDNS也无法解决你从其他地方访问的需求。如果是使用路由器拨号的可以在路由器界面上看到请求的IP地址。一般电信、联通可以提供公网的IP（如果分配的是局域网地址可以打服务号申请调整哦～），其他可能就不行了。 一般家里都会用一个路由器上多个设备同时上网，因此你需要掌握如果把一个机器的端口通过路由器暴露给公网，现在一般80端口都被封了，所以请选择其他端口测试。 其实实现随时获取网络IP有多种方式，例如可以自己写一个服务程序来获取请求者的IP地址，再在家里常开机器（如NAS或其他设备）上运行一个定时请求的客户端（如curl），这样你就可以通过这个服务做中转来随时获取家里的IP。 当然这个方案要求你有一个固定的IP来提供服务。这里主要介绍下基于aliyun sdk来实现自己的ddns。 花生壳等服务提供的就是DDNS功能，但要收费之类的， 如果你自己已经有一个域名，那为什么不自己动手来实现一个呢？说干就干。 简单搜索，发现网上有很多类似内容，以下简单记录下自己的实现方式。 首先， 登录（如果没有需要注册）aliyun管理控制台， 获取到AccessKey ID和AccessKey Secret ，这个可以理解成是程序通过sdk请求aliyun服务器的凭证。 方法参考[1] 然后，在你准备运行aliyun sdk接口的机器上安装aliyun的sdk``` pip install aliyunsdkcore pip install aliyun-python-sdk-alidns</description></item><item><title>firewalld配置到虚拟机的端口转发</title><link>/posts/firewalld%e9%85%8d%e7%bd%ae%e5%88%b0%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91/</link><pubDate>Tue, 29 May 2018 02:57:58 +0000</pubDate><guid>/posts/firewalld%e9%85%8d%e7%bd%ae%e5%88%b0%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91/</guid><description>场景如下，假定服务器有公网IP，不同的业务可能运行到不同的虚拟机上，通过在服务器上配置不同的端口转发使请求转发到不同的虚拟机中。 实验环境如下：
host： fedora27 guest: fedora27，ip是192.0.2.55 步骤：``` #获取当前zone firewall-cmd &amp;ndash;get-active-zones #假定获取的zone为external,fedora返回的是FedoraWorkstation firewall-cmd &amp;ndash;zone=external &amp;ndash;add-masquerade #把host上的22端口转到192.0.2.55地址的2055端口 firewall-cmd &amp;ndash;zone=external &amp;ndash;add-forward-port=port=22:proto=tcp:toport=2055:toaddr=192.0.2.55 firewall-cmd &amp;ndash;reload #需要确认ip_forward处于开启状态 net.ipv4.ip_forward = 1 检查虚拟机的防火墙开起来对应的端口，或者干脆关闭防火墙。 #其他的命令 firewall-cmd &amp;ndash;zone=external &amp;ndash;add-forward-port=port=22:proto=tcp:toport=3753 firewall-cmd &amp;ndash;zone=external &amp;ndash;add-forward-port=port=22:proto=tcp:toaddr=192.0.2.55 查看： firewall-cmd &amp;ndash;list-all firewall-cmd &amp;ndash;zone=external &amp;ndash;list-forward-ports 当然也可以使用qemu来实现端口转发，这里就不展开了。</description></item><item><title>drm</title><link>/posts/drm/</link><pubDate>Thu, 29 Mar 2018 00:51:27 +0000</pubDate><guid>/posts/drm/</guid><description>DRM - Direct Rendering Manager DRM是一个内核级的设备驱动，既可以编译到内核中也可以作为标准模块进行加载。DRM最初是在FreeBSD中出现的，后来被移植到Linux系统中，并成为Linux系统的标准部分。 DRM可以直接访问DRM clients的硬件。DRM驱动用来处理DMA，内存管理，资源锁以及安全硬件访问。为了同时支持多个3D应用，3D图形卡硬件必须作为一个共享资源，因此需要锁来提供互斥访问。DMA传输和AGP接口用来发送图形操作的buffers到显卡硬件，因此要防止客户端越权访问显卡硬件。 Linux DRM层用来支持那些复杂的显卡设备，这些显卡设备通常都包含可编程的流水线，非常适合3D图像加速。内核中的DRM层，使得这些显卡驱动在进行内存管理，中断处理和DMA操作中变得更容易，并且可以为上层应用提供统一的接口。</description></item><item><title>[转]linux图形显示相关内容</title><link>/posts/%e8%bd%aclinux%e5%9b%be%e5%bd%a2%e6%98%be%e7%a4%ba%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9/</link><pubDate>Tue, 27 Feb 2018 12:19:05 +0000</pubDate><guid>/posts/%e8%bd%aclinux%e5%9b%be%e5%bd%a2%e6%98%be%e7%a4%ba%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9/</guid><description>1. 前言 图形子系统是linux系统中比较复杂的子系统之一：对下，它要管理形态各异的、性能各异的显示相关的器件；对上，它要向应用程序提供易用的、友好的、功能强大的图形用户界面（GUI）。因此，它是linux系统中少有的、和用户空间程序（甚至是用户）息息相关的一个子系统。 本文是图形子系统分析文章的第一篇，也是提纲挈领的一篇，将会从整体上，对linux显示子系统做一个简单的概述，进而罗列出显示子系统的软件构成，后续的文章将会围绕这些软件一一展开分析。 注1：本文所有的描述将以原生linux系统为例（如Ubuntu、Debian等），对其它基于linux的系统（如Android），部分内容会不适用。 注2：本文很多图片都是从网上搜集而来的（很多是从维基百科）。虽然蜗窝的宗旨是用自己的语言表述，尽量自己画图，但是linux图形子系统太复杂了，蜗蜗的理解有限，而老外的图画的实在太好，蜗蜗觉得，再怎么努力，也画不出更好的了，因此本着为读者负责的态度，就直接copy了。
2. 概念介绍 2.1 GUI（Graphical User Interface，图形用户界面） linux图形子系统的本质，是提供图形化的人机交互（human-computer interaction）界面，也即常说的GUI（Graphical User Interface）。而人机交互的本质，是人脑通过人的输出设备（动作、声音等），控制电脑的输入设备，电脑经过一系列的处理后，经由电脑的输出设备将结果输出，人脑再通过人的输入设备接收电脑的输出，最终实现“人脑&amp;lt;&amp;ndash;&amp;gt;电脑”之间的人机交互。下面一幅摘自维基百科的图片（可从“这里”查看比较清晰的SVG格式的原始图片），对上述过程做了很好的总结：
该图以一个非常前卫的应用场景&amp;mdash;-虚拟现实（VR，Virtual Reality）游戏，说明了以图形化为主的人机交互过程： 1）人脑通过动作、声音（对人脑而言，是output），控制电脑的输入设备，包括键盘、鼠标、操作杆、麦克风、游戏手柄（包含加速度计、陀螺仪等传感器）。 2）电脑通过输入设备，接收人脑的指令，这些指令经过kernel Input subsystem、Middleware Gesture/Speech recognition等软件的处理，转换成应用程序（Game）可以识别的、有意义的信息。 3）应用程序（Game）根据输入信息，做出相应的反馈，主要包括图像和声音。对VR游戏而言，可能需要3D rendering，这可以借助openGL及其相应的用户空间driver实现。 4）应用程序的反馈，经由kernel的Video subsystem（如DRM/KMS）、audio subsystem（如ALSA），输出到电脑的输出设备上，包括显示设备（2D/3D）、扬声器/耳机（3D Positional Audio）、游戏手柄（力的反馈）等。 5）输出到显示设备上时，可能会经过图形加速模块（Graphics accelerator）。 注3：图中提到了VR场景的典型帧率（1280×800@95fps for VR），这是一个非常庞大的信息输出，要求图形子系统能10.5ms的时间内，生成并输出一帧，以RGBA的数据格式为例，每秒需要处理的数据量是1280x800x95x4x8=3.11296Gb，压力和挑战是相当大的（更不用提1080P了）。
有关GUI更为详细的解释，请参考：https://en.wikipedia.org/wiki/Graphical_user_interface。
2.2 Windowing system（窗口系统） 窗口系统，是GUI的一种（也是当前计算机设备、智能设备广泛使用的一种），以WIMP （windows、icons、menus、pointer) 的形式，提供人机交互接口。Linux系统中有很多窗口系统的实现，如X Window System、Wayland、Android SurfaceFlinger等，虽然形态各异，但思路大致相同，包含如下要点：
1）一般都使用client-server架构，server（称作display server，或者windows server、compositor等等）管理所有输入设备，以及用于输出的显示设备。 2）应用程序作为display server的一个client，在自己窗口（window）中运行，并绘制自己的GUI。 3）client的绘图请求，都会提交给display server，display server响应并处理这些请求，以一定的规则混合、叠加，最终在有限的输出资源上（屏幕），显示多个应用程序的GUI。 3）display server和自己的client之间，通过某种类型的通信协议交互，该通信协议通常称作display server protocol。 4）display server protocol可以是基于网络的，甚至是网络透明的（network transparent），如X Window System所使用的。也可以是其它类型的，如Android SurfaceFlinger所使用的binder。
有关Windowing system的详细解释，请参考：https://en.</description></item><item><title>Qemu-kvm下运行Android x86</title><link>/posts/qemu-kvm%e4%b8%8b%e8%bf%90%e8%a1%8candroid-x86/</link><pubDate>Thu, 25 Jan 2018 16:53:13 +0000</pubDate><guid>/posts/qemu-kvm%e4%b8%8b%e8%bf%90%e8%a1%8candroid-x86/</guid><description>Android-x86 project 已经将x86架构的android系统准备继续，所以使用Qemu-kvm来安装Android系统就非常容易了。
准备Android-x86的iso镜像，可以在http://www.android-x86.org/download 处下载 准备qemu kvm虚拟化环境，例如安装fedora或centos等系统，安装virt-manager来运行qemu-kvm 按照虚拟机创建流程来安装android x86的镜像。（我验证是下载的是7.1的镜像，安装时不要使用GPT分区） 这样Android x86就可以在虚拟机下运行了，验证了下默认的网络也是ok的，如果配置了spice，还可以通过remote-viewer等工具来访问该Android x86虚拟机，非常方便。</description></item><item><title>Linux下通过命令行关闭、开启显示器的方法</title><link>/posts/linux%e4%b8%8b%e9%80%9a%e8%bf%87%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%85%b3%e9%97%ad%e3%80%81%e5%bc%80%e5%90%af%e6%98%be%e7%a4%ba%e5%99%a8%e7%9a%84%e6%96%b9%e6%b3%95/</link><pubDate>Tue, 31 Oct 2017 11:45:40 +0000</pubDate><guid>/posts/linux%e4%b8%8b%e9%80%9a%e8%bf%87%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%85%b3%e9%97%ad%e3%80%81%e5%bc%80%e5%90%af%e6%98%be%e7%a4%ba%e5%99%a8%e7%9a%84%e6%96%b9%e6%b3%95/</guid><description>Linux下关闭、开启显示器有如下的方案，原理各不相同，将来载补充，先列出来：
xrandr需要指定display和输出的设备，所以该命令可以制定具体关闭的显示器，实例如下： xrandr -display :0 &amp;ndash;output DP1 &amp;ndash;off xrandr -display :0 &amp;ndash;output DP1 &amp;ndash;auto xset，xset关闭以后有键盘或鼠标输入时屏幕会被唤醒，命令如下： xset dpms force off -display :0 xset dpms force on -display :0 vbetool，vbetool是一个较老的工具，在现在主流的系统中可能默认不会集成，此外该工具和intel i915驱动不兼容，所以如果使用i915驱动请不要使用该工具 vbetool dpms on vbetool dpms off</description></item><item><title>Fedora 26无法锁屏</title><link>/posts/fedora-26%e6%97%a0%e6%b3%95%e9%94%81%e5%b1%8f/</link><pubDate>Wed, 26 Jul 2017 10:54:05 +0000</pubDate><guid>/posts/fedora-26%e6%97%a0%e6%b3%95%e9%94%81%e5%b1%8f/</guid><description>Lock screen doesn&amp;rsquo;t work after upgrading to F26 It doesn&amp;rsquo;t work when SUPER+L, when suspending or when hibernating, in GNOME. Any idea on how to solve this? UPDATE/SOLVED: OK, it was disabled in dconf, although I didn&amp;rsquo;t do it, so I post the solution here in case someone looks for it, learnt from here:``` gsettings set org.gnome.desktop.lockdown disable-lock-screen false</description></item><item><title>Fedora 25 vim右键无菜单解决办法</title><link>/posts/fedora-25-vim%e5%8f%b3%e9%94%ae%e6%97%a0%e8%8f%9c%e5%8d%95%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95/</link><pubDate>Thu, 29 Dec 2016 17:03:46 +0000</pubDate><guid>/posts/fedora-25-vim%e5%8f%b3%e9%94%ae%e6%97%a0%e8%8f%9c%e5%8d%95%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95/</guid><description>不知道什么时候开始，fedora 25里vim右键菜单突然消失了，而且点击右键时切换到“视图”模式。平常也只是使用一些简单的vim，感觉基本够用了。现在看不折腾不行了，搜索、试验了下。方法如下：
Stop sourcing $VIMRUNTIME/vimrc_example.vim. Add set mouse-=a to .vimrc as you did. Use another shortcuts. E.g. Shift + Insert, Shift + right click, or etc. (It depends on your terminal software.) 我是创建了一个~/.vimrc文件：set mouse-=a 问题解决。 参考：https://github.com/vim/vim/issues/1326</description></item><item><title>[转]基于 Open vSwitch 的 OpenFlow 实践</title><link>/posts/%e8%bd%ac%e5%9f%ba%e4%ba%8e-open-vswitch-%e7%9a%84-openflow-%e5%ae%9e%e8%b7%b5/</link><pubDate>Tue, 06 Dec 2016 08:22:52 +0000</pubDate><guid>/posts/%e8%bd%ac%e5%9f%ba%e4%ba%8e-open-vswitch-%e7%9a%84-openflow-%e5%ae%9e%e8%b7%b5/</guid><description>Open vSwitch 概述 Open vSwitch（下面简称为 OVS）是由 Nicira Networks 主导的，运行在虚拟化平台（例如 KVM，Xen）上的虚拟交换机。在虚拟化平台上，OVS 可以为动态变化的端点提供 2 层交换功能，很好的控制虚拟网络中的访问策略、网络隔离、流量监控等等。 OVS 遵循 Apache 2.0 许可证, 能同时支持多种标准的管理接口和协议。OVS 也提供了对 OpenFlow 协议的支持，用户可以使用任何支持 OpenFlow 协议的控制器对 OVS 进行远程管理控制。
Open vSwitch 概述 在 OVS 中, 有几个非常重要的概念：
Bridge: Bridge 代表一个以太网交换机（Switch），一个主机中可以创建一个或者多个 Bridge 设备。 Port: 端口与物理交换机的端口概念类似，每个 Port 都隶属于一个 Bridge。 Interface: 连接到 Port 的网络接口设备。在通常情况下，Port 和 Interface 是一对一的关系, 只有在配置 Port 为 bond 模式后，Port 和 Interface 是一对多的关系。 Controller: OpenFlow 控制器。OVS 可以同时接受一个或者多个 OpenFlow 控制器的管理。 datapath: 在 OVS 中，datapath 负责执行数据交换，也就是把从接收端口收到的数据包在流表中进行匹配，并执行匹配到的动作。 Flow table: 每个 datapath 都和一个“flow table”关联，当 datapath 接收到数据之后， OVS 会在 flow table 中查找可以匹配的 flow，执行对应的操作, 例如转发数据到另外的端口。 Open vSwitch 实验环境配置 OVS 可以安装在主流的 Linux 操作系统中，用户可以选择直接安装编译好的软件包，或者下载源码进行编译安装。 在我们的实验环境中，使用的操作系统是 64 位 Ubuntu Server 12.</description></item><item><title>Fedora23上无法运行vmware解决办法</title><link>/posts/fedora23_vmware_run_error/</link><pubDate>Sat, 30 Apr 2016 05:51:17 +0000</pubDate><guid>/posts/fedora23_vmware_run_error/</guid><description>运行如下脚本：``` #!/bin/bash cp -aiv /usr/lib64/libgio-2.0.so.0.4600.2 /usr/lib/vmware/lib/libgio-2.0.so.0/libgio-2.0.so.0
cp -aiv /usr/lib64/libglib-2.0.so.0.4600.2 /usr/lib/vmware/lib/libglib-2.0.so.0/libglib-2.0.so.0
cp -aiv /usr/lib64/libgmodule-2.0.so.0.4600.2 /usr/lib/vmware/lib/libgmodule-2.0.so.0/libgmodule-2.0.so.0
cp -aiv /usr/lib64/libgobject-2.0.so.0.4600.2 /usr/lib/vmware/lib/libgobject-2.0.so.0/libgobject-2.0.so.0
cp -aiv /usr/lib64/libgthread-2.0.so.0.4600.2 /usr/lib/vmware/lib/libgthread-2.0.so.0/libgthread-2.0.so.0</description></item><item><title>ubuntu 15.10上运行无法vmware解决办法</title><link>/posts/how-to-run-vmware-on-ubuntu15-10/</link><pubDate>Mon, 02 Nov 2015 13:37:37 +0000</pubDate><guid>/posts/how-to-run-vmware-on-ubuntu15-10/</guid><description>今天把ubuntu系统升级到15.10，突然发现vmware虚拟机无法运行了，之前是11版本的，看之前一直提示12版本已经发布，就先把vmware升级了一下，结果还是没有办法运行（运行vmware没有显示）。 研究、搜索了半天，解决办法如下： 方法1：在终端执行如下动态库设置，然后再运行vmware或vmplayerexport LD_LIBRARY_PATH=/usr/lib/vmware/lib/libglibmm-2.4.so.1/:$LD_LIBRARY_PATH方法2：编辑/usr/bin/vmware，添加export LD\_LIBRARY\_PATH=/usr/lib/vmware/lib/libglibmm-2.4.so.1再运行vmware，当然方法2一劳永逸^_^。 原来是vmware和vmplayer需要一些特殊的动态库，而这些动态库无疑和系统的动态库是冲突的，因此也只能是使用vmware的时候配置这些动态库，如果修改到环境变量里面，无疑会对其他的应用产生影响。 参考：``` https://communities.vmware.com/message/2547319 http://askubuntu.com/questions/689123/vmware-wont-work-after-ubuntu-upgrade</description></item><item><title>Linux使用ＨＰ打印机配置方式总结</title><link>/posts/linux%e4%bd%bf%e7%94%a8%ef%bc%a8%ef%bc%b0%e6%89%93%e5%8d%b0%e6%9c%ba%e9%85%8d%e7%bd%ae%e6%96%b9%e5%bc%8f%e6%80%bb%e7%bb%93/</link><pubDate>Thu, 17 Sep 2015 10:02:01 +0000</pubDate><guid>/posts/linux%e4%bd%bf%e7%94%a8%ef%bc%a8%ef%bc%b0%e6%89%93%e5%8d%b0%e6%9c%ba%e9%85%8d%e7%bd%ae%e6%96%b9%e5%bc%8f%e6%80%bb%e7%bb%93/</guid><description>Linux下处理打印机的服务是CUPS，但支持不通型号的打印机还是需要各个打印机相关的一些驱动做支撑。最近就使用ubuntu链接一台HP LaserJet Pro MFP M226dw，把中间碰到问题的解决办法记录如下： 连接打印机的方法有很多种，USB、网络、无线等，我使用的方法是网线，即笔记本和HP打印机都连接在一个交换机上面。 1、打印问题 使用cups添加设备的时候，cups可以自动找到打印机，但是连接的类型里面只有&amp;quot;AppSocket/HP JetDirect&amp;quot;等方式，没有办法看到HPLIP的连接类型。这个时候就需要安装HP相关的“驱动” 去网页：http://hplipopensource.com/hplip-web/install_wizard/index.html 依据自己的打印机型号寻找hplip文件，下载后进行安装。 安装以后使用cups就可以看到HPLIP的连接选项了，使用该连接选项连接打印机。打印测试页，一切正常，所以打印机已经工作正常。 2、扫描功能 有时难免会用到扫描功能，cups缺少相关的功能。 使用hp-toolbox命令就可以调出刚刚hplip包提供的工具集了，点击Actions-&amp;gt;Scan里面的就会出现扫描工具。 这时可能会提示需要安装二进制的插件。我用的是hplip-3.15.9，plugin安装貌似有问题，自动下载安装无法完成。搜寻半天，发现可以在https://www.openprinting.org/download/printdriver/auxfiles/HP/plugins/ 页面里找到对应的plugins，下载安装。scan功能一切正常。 搜索关键字：“ERROR:Plug-in file does not match its digital signature.”</description></item><item><title>vmware安装Centos7虚拟机网络不识别解决方案</title><link>/posts/vmware%e5%ae%89%e8%a3%85centos7%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%b8%8d%e8%af%86%e5%88%ab%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88/</link><pubDate>Thu, 30 Jul 2015 07:23:30 +0000</pubDate><guid>/posts/vmware%e5%ae%89%e8%a3%85centos7%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%b8%8d%e8%af%86%e5%88%ab%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88/</guid><description>今天使用vmware安装centos 7虚拟机，安装完毕以后发现网络无法识别。 通过lspci发现网卡没有加载驱动，猜测可能是由于centos 7默认的内核没有编译该虚拟网卡的驱动。 因此，想到通过如下方式解决，经验证，可以解决问题。 编辑虚拟机的*.vmx文件，添加ethernet0.virtualDev = &amp;ldquo;e1000&amp;rdquo;，把该虚拟机的网卡设定成e1000。再开机验证，发现网路正常。 此外还有一个方法，就是修改guest os的类型，在安装的时候就选择centos，或者同样通过修改配置文件完成。 guestOS = &amp;ldquo;centos&amp;rdquo;</description></item><item><title>linux-3.19下运行vmware解决方案</title><link>/posts/linux-3-19-vmware-vmnet-error/</link><pubDate>Thu, 30 Apr 2015 02:32:59 +0000</pubDate><guid>/posts/linux-3-19-vmware-vmnet-error/</guid><description>由于linux3.19内核升级导致接口变化，vmnet无法编译通过。解决办法如下，可以把附件的vmnet替换掉原来的，即可使用。下载后执行：``` cp vmnet.tar /usr/lib/vmware/modules/source/vmnet.tar</description></item><item><title>[转]U-boot 之TFTP服务器配置</title><link>/posts/u-boot-tftp-server-config/</link><pubDate>Wed, 15 Apr 2015 16:27:38 +0000</pubDate><guid>/posts/u-boot-tftp-server-config/</guid><description>一.PC端配置 1.关闭防火墙 [root@gliethttp root]# /etc/init.d/iptables stop 2.使用setup启动tftp [root@gliethttp root]# setup -&amp;gt;System services-&amp;gt;选中tftp 3.如果setup中找不到tftp选项，那么你需要rpm包来安装 在redhat9的CD3里可以找到tftp-server-0.32-4.i386.rpm文件 [root@gliethttp root]# rpm -ivh tftp-server-0.32-4.i386.rpm 4.修改tftp服务器配置 [root@gliethttp root]# vim /etc/xinetd.d/tftp 将server_args配置项为你自己的tftpboot根目录 将disable 配置为no service tftp { socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /tftpboot disable = no per_source = 11 cps = 100 2 flags = IPv4 } 5.启动tftp服务器 [root@gliethttp root]# /etc/init.d/xinetd restart 6.下载文件准备 [root@gliethttp root]# mkdir /tftpboot [root@gliethttp root]# cp usb1-uImage /tftpboot ；拷贝预下载的内核文件到/tftpboot目录下 [root@gliethttp root]# cp minigui9200.</description></item><item><title>串口登陆类ubuntu系统设置方法</title><link>/posts/serail_console_login_ubuntu_howto/</link><pubDate>Tue, 24 Mar 2015 16:22:51 +0000</pubDate><guid>/posts/serail_console_login_ubuntu_howto/</guid><description>在调试嵌入式等设备的时候，难免需要使用串口来登陆系统，ubuntu模式配置是没有启用串口登陆的，以下将简要介绍如何开启串口登陆。 在较高（12.04以后？）中，基于upstart的启动环境中使用/etc/init下面创建的启动脚本。如tty0～tty7都有相关的配置文件tty[0&amp;hellip;7].conf。如果需要启用串口登陆，只需要对应的创建一个新的文件，例如你使用的串口是ttyS0,则新建ttyS0.conf文件。 填写如下内容到该配置文件(注意里面的115200即串口的波特率。``` # ttyS0 - getty
This service maintains a getty on ttyS0 from the point the system is started until it is shut down again. start on stopped rc or RUNLEVEL=[12345] stop on runlevel [!12345]
respawn exec /sbin/getty -L 115200 ttyS0 vt102 这样连接串口重新启动进行验证吧，当然也可以不重启，通过执行以下命令实现： sudo start ttyS0</description></item><item><title>[ZZ]Device Tree（一）：背景介绍 为什么引入dtb</title><link>/posts/zzdevice-tree%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d/</link><pubDate>Mon, 23 Mar 2015 02:44:42 +0000</pubDate><guid>/posts/zzdevice-tree%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d/</guid><description>作者：linuxer 发布于：2014-5-22 16:46 分类：统一设备模型
一、前言 作为一个多年耕耘在linux 2.6.23内核的开发者，各个不同项目中各种不同周边外设驱动的开发以及各种琐碎的、扯皮的俗务占据了大部分的时间。当有机会下载3.14的内核并准备学习的时候，突然发现linux kernel对于我似乎变得非常的陌生了，各种新的机制，各种framework、各种新的概念让我感到阅读内核代码变得举步维艰。 还好，剖析内核的热情还在，剩下的就交给时间的。首先进入视线的是Device Tree机制，这是和porting内核非常相关的机制，如果想让将我们的硬件平台迁移到高版本的内核上，Device Tree是一个必须要扫清的障碍。 我想从下面三个方面来了解Device Tree： 1、为何要引入Device Tree，这个机制是用来解决什么问题的？（这是本文的主题） 2、Device Tree的基础概念（请参考DT基础概念） 3、ARM linux中和Device Tree相关的代码分析（请参考DT代码分析） 阅读linux内核代码就像欣赏冰山，有看得到的美景（各种内核机制及其代码），也有埋在水面之下看不到的基础（机制背后的源由和目的）。沉醉于各种内核机制的代码固然有无限乐趣，但更重要的是注入更多的思考，思考其背后的机理，真正理解软件抽象。这样才能举一反三，并应用在具体的工作和生活中。 本文主要从下面几个方面阐述为何ARM linux会引入Device Tree： 1、没有Device Tree的ARM linux是如何运转的？ 2、混乱的ARM architecture代码和存在的问题 3、新内核的解决之道 二、没有Device Tree的ARM linux是如何运转的？ 我曾经porting内核到两个ARM-based的平台上。一个是小的芯片公司的应用处理器，公司自己购买了CPU core，该CPU core使用ARM兼容的指令集（但不是ARM）加上各种公司自行设计的多媒体外设整合成公司的产品进行销售。而我的任务就是porting 2.4.18内核到该平台上。在黑白屏幕的手机时代，那颗AP（application process）支持了彩屏、camera、JPEG硬件加速、2D/3D加速、MMC/SD卡、各种音频加速（内置DSP）等等特性，功能强大到无法直视。另外一次移植经历是让2.6.23内核跑在一个大公司的冷门BP（baseband processor）上。具体porting的方法是很简单的： 1、自己撰写一个bootloader并传递适当的参数给kernel。除了传统的command line以及tag list之类的，最重要的是申请一个machine type，当拿到属于自己项目的machine type ID的时候，当时心情雀跃，似乎自己已经是开源社区的一份子了（其实当时是有意愿，或者说有目标是想将大家的代码并入到linux kernel main line的）。 2、在内核的arch/arm目录下建立mach-xxx目录，这个目录下，放入该SOC的相关代码，例如中断controller的代码，时间相关的代码，内存映射，睡眠相关的代码等等。此外，最重要的是建立一个board specific文件，定义一个machine的宏：
MACHINE_START(project name, &amp;ldquo;xxx公司的xxx硬件平台&amp;rdquo;) .phys_io = 0x40000000, .boot_params = 0xa0000100, .io_pg_offst = (io_p2v(0x40000000) &amp;raquo; 18) &amp;amp; 0xfffc, .map_io = xxx_map_io, .</description></item><item><title>ubuntu安装光盘iso修改方法总结</title><link>/posts/ubuntu%e5%ae%89%e8%a3%85%e5%85%89%e7%9b%98iso%e4%bf%ae%e6%94%b9%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93/</link><pubDate>Wed, 04 Feb 2015 06:19:10 +0000</pubDate><guid>/posts/ubuntu%e5%ae%89%e8%a3%85%e5%85%89%e7%9b%98iso%e4%bf%ae%e6%94%b9%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93/</guid><description>可以使用mount命令查看iso的内容#mkdir iso #mount -o loop ubuntu.iso ./iso把iso里面的内容取出来,iso_modify#mkdir iso\_modify #rsync -az ./iso ./iso\_modifyIso目录里面的casper/filesystem.squashfs就是启动以后的虚拟文件系统，我们要修改的就是这里的内容。#mkdir squashfs #cp iso/casper/filesystem.squashfs ./squashfs #cd squashfs解压squashfs#unsquashfs filesystem.squashfs可以看到解压出的squashfs-root目录就是一个文件系统，针对性的进行修改，如果需要安装deb包，可以chroot进去使用dpkg进行安装。 如果安装了软件包，需要跟新dpkg的列表：#chroot squashfs-root/ dpkg-query -W --showformat='${Package}\\t${Version}\\n' &amp;gt; dpkg\_list #cp dpkg\_list ../../iso\_modify/casper/filesystem.manifest把squashfs-root目录从新制作成squashfs文件#mksquashfs squashfs-root filesystem.squashfs -b 1024k -comp xz -Xbcj x86 -e boot用新的filesystem.squashfs替换原来的文件。 把新的iso-modify打包成iso``` #mkisofs -r -V &amp;ldquo;UbuntuTest&amp;rdquo; -cache-inodes -J -l -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o ../ubuntu-test.iso .</description></item><item><title>ubuntu下initramfs相关内容记录</title><link>/posts/ubuntu%e4%b8%8binitramfs%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9%e8%ae%b0%e5%bd%95/</link><pubDate>Mon, 02 Feb 2015 16:54:53 +0000</pubDate><guid>/posts/ubuntu%e4%b8%8binitramfs%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9%e8%ae%b0%e5%bd%95/</guid><description>为了适应不同的运行环境，Linux发行版的启动基本都分为两个阶段，第一阶段使用initramfs文件系统，加载所需要的硬件驱动、文件系统驱动等；当完成根文件系统挂载后执行chroot，进入真实的文件系统。 initramfs类似与一个极其简化的文件系统，里面包含了系统启动时驱动的最小集合，这样使得initramfs的体积尽可能的变小。但不同发行版本的initramfs中内容的制作方式不尽相同，例如在fedora、rhel、centos的版本中，使用dracut工具包来生成相对应的initrd，而在ubuntu系统中使用initramfs-tools工具包所提供的相关工具。 当安装内核、内核升级的时候，内核的postinst脚本会在安装结束后调用update-initramfs工具更新相关的initramfs文件。查看update-initramfs文件发现，其主要调用mkinitramfs来完成相关操作。 update-initramfs与mkinitramfs文件都是BASH脚本文件，mkinitramfs文件基于事先约定的规则拷贝相关的程序、库、脚本、配置等到特定的目录，然后打包成initramfs格式的文件。mkinitramfs文件会引用/usr/share/initramfs-tools/hook-functions中事先约定好的函数，例如copy_exec可以完成二进制程序的拷贝，同时拷贝该程序所以来的动态库。/usr/share/initramfs-tools/scripts/目录中存放着生成initramfs中所需要的脚本。 修改//usr/sbin/mkinitramfs或者其他相关的内容，自己重新生成一个initramfs文件和之前的对比下，就可以看到效果。 例如：mkinitramfs -o test.img即可使用当前运行的内核版本生成一个对应的initramfs文件。 initramfs-tools软件包中除了mkinitramfs、update-initramfs工具外还有lsinitramfs等工具来帮助用户进行操作。 当然，最后生成的initramfs.img文件只是一种打包好的文件而已，方便grub加载及运行，我们也可自行进行解压、修改、再打包。 命令大致如下： 解压：zcat in.img |cpio -dium 打包：find . |cpio -H newc -o |gzip -9 &amp;gt; out.img</description></item><item><title>搭建linux0.11系统环境</title><link>/posts/%e6%90%ad%e5%bb%balinux0-11%e7%b3%bb%e7%bb%9f%e7%8e%af%e5%a2%83/</link><pubDate>Wed, 14 Jan 2015 16:17:56 +0000</pubDate><guid>/posts/%e6%90%ad%e5%bb%balinux0-11%e7%b3%bb%e7%bb%9f%e7%8e%af%e5%a2%83/</guid><description>要学习Linux0.11的内核代码必须要有一个运行环境来做实验，本文简要介绍如何搭建该环境。 环境：ubuntu14.10 x86_64 Linux0.11的内核可以说是古董级的，所以必须要祭出模拟器了，有2中搭建方案bochs或qemu
使用bochs仿真器： 1、使用发行版的bochs，通过apt-get安装，需要安装如下软件包，如果缺包在之后的运行中就会有各种问题，此处忽略。当然你也可以从http://sourceforge.net/projects/bochs/files/Disk%20Images/ 处下载安装。ii bochs 2.6-2 amd64 IA-32 PC emulator ii bochs-doc 2.6-2 all Bochs upstream documentation ii bochs-term 2.6-2 amd64 Terminal (ncurses-based) plugin for Bochs ii bochs-wx 2.6-2 amd64 WxWindows plugin for Bochs ii bochs-x 2.6-2 amd64 X11 plugin for Bochs ii bochsbios 2.6-2 all BIOS for the Bochs emulator2、下载虚拟文件系统：地址：http://www.oldlinux.org/Linux.old/bochs/linux-0.11-devel-040329.zip 3、由于bochs的变化，所以需要修改配置文件，我修改bochsrc-hd.bxrc后的内容如下：``` megs: 16 floppya: 1_44=&amp;ldquo;bootimage-0.11-hd&amp;rdquo;, status=inserted floppyb: 1_44=diskb.img, status=inserted ata0-master: type=disk, path=&amp;ldquo;hdc-0.11.img&amp;rdquo;, mode=flat, cylinders=121, heads=16, spt=63 boot: a log: bochsout.</description></item><item><title>grsecurity系列之一:概述及简易安装部署</title><link>/posts/grsecurity%e7%b3%bb%e5%88%97%e4%b9%8b%e4%b8%80%e6%a6%82%e8%bf%b0%e5%8f%8a%e7%ae%80%e6%98%93%e5%ae%89%e8%a3%85%e9%83%a8%e7%bd%b2/</link><pubDate>Thu, 20 Nov 2014 14:52:52 +0000</pubDate><guid>/posts/grsecurity%e7%b3%bb%e5%88%97%e4%b9%8b%e4%b8%80%e6%a6%82%e8%bf%b0%e5%8f%8a%e7%ae%80%e6%98%93%e5%ae%89%e8%a3%85%e9%83%a8%e7%bd%b2/</guid><description>近日准备分析下grsecurity，把过程总结记录下与大家分享、讨论。 SELinux应该很多人都知道，不错，它是Linux的LSM框架下强制访问控制机制中使用较为普遍的一种，由NSA开发。在RHEL、Fedora系统中可以看到它的身影，而apparmor被ubuntu维护并默认使用。基本上这两种强制访问控制机制是当前Linux系统中使用最为广泛的。grsecurity没有使用LSM框架，而是对应kernel upstream的不同主流版本发布不同的patch。部署起来没有系统默认安装的selinux、apparmor那么方便，但存在即有意义。grsecurity发展有13年之久，这么多年为什么一直都没有进入内核，以及它与selinux、apparmor相比有什么差别，此次暂不评述。不可否认的是由于grsecurity实现时超出LSM框架，所以实现了很多其他强制访问控制机制所不能、或很难实现的功能，本系列文章分别描述，如有不周，请大家批评指正。 grsecurity官网上从Memroy Corruption defenses、Filesystem Hardening、Miscellaneous Protections、RBAC、GCC Plugins几个方面描述其特性，之后做详尽描述。
安装 从http://grsecurity.net/download.php可以看到当前稳定版本所对应的内核版本。下载对应的内核版本及grsecurity的patch。本处使用linux-3.2.64内核版本及grsecurity-3.0-3.2.64-201411150025.patch 补丁。``` #tar xf linux-3.2.64.tar.xz #cd linux-3.2.64 #patch -p1 &amp;lt; ../grsecurity-3.0-3.2.64-201411150025.patch #make menuconfig #make DISABLE_PAX_PLUGINS=y -j8 #make DISABLE_PAX_PLUGINS=y -j8 modules #sudo make DISABLE_PAX_PLUGINS=y -j8 modules_install #sudo make DISABLE_PAX_PLUGINS=y -j8 install
1. 由于安装了gcc-&amp;lt;ver&amp;gt;-plugin-dev，还是提示无法找到，因此本次去除该特性； 2. grsecurity的配置在&amp;quot;security options&amp;quot;-&amp;gt;&amp;quot;grsecurity&amp;quot;里面，本次可以使用Automatic配置，之后在做调整 3. \-j8指定并行编译的进程数，可使用CPU数的2倍 之后大家还可以下载、编译安装gradm。 重启~~~ Ok，可以开始体验grsecurity了～</description></item><item><title>CVE-2013-1959内核漏洞原理与本地提权利用代码实现分析</title><link>/posts/cve-2013-1959%e5%86%85%e6%a0%b8%e6%bc%8f%e6%b4%9e%e5%8e%9f%e7%90%86%e4%b8%8e%e6%9c%ac%e5%9c%b0%e6%8f%90%e6%9d%83%e5%88%a9%e7%94%a8%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</link><pubDate>Thu, 17 Apr 2014 11:58:21 +0000</pubDate><guid>/posts/cve-2013-1959%e5%86%85%e6%a0%b8%e6%bc%8f%e6%b4%9e%e5%8e%9f%e7%90%86%e4%b8%8e%e6%9c%ac%e5%9c%b0%e6%8f%90%e6%9d%83%e5%88%a9%e7%94%a8%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</guid><description>关键字：CVE-2013-1959，cve，kernel vulnerability，内核漏洞，POC，利用代码，本地提权，exploit， analysis,user namespace,capabilities 2013年4月28日，Andy Lutomirski在oss-security披露了该cve的细节。CVE-2013-1959是当前内核稳定版本安全补丁修复所对应的一个CVE。这个CVE的原因是在user namespace中，/proc/uid_map存多个不正确的权限检查。如果启用相关的配置，Linux 3.8和很多3.9rcs将受到影响。利用者可以获取root权限。 修复这个CVE对应的有3个patch，以下先大致介绍这三个Patch所修改的内容。 Patch1：Add file_ns_capable() helper function for open-time capability checking``` From 935d8aabd4331f47a89c3e1daa5779d23cf244ee Mon Sep 17 00:00:00 2001 From: Linus Torvalds torvalds@linux-foundation.org Date: Sun, 14 Apr 2013 10:06:31 -0700 Subject: [PATCH] Add file_ns_capable() helper function for open-time capability checking
Nothing is using it yet, but this will allow us to delay the open-time checks to use time, without breaking the normal UNIX permission semantics where permissions are determined by the opener (and the file descriptor can then be passed to a different process, or the process can drop capabilities).</description></item><item><title>Linux下线程pthread实现suspend、resume的一种方式</title><link>/posts/linux_pthread_suspend_resume/</link><pubDate>Tue, 11 Mar 2014 13:22:58 +0000</pubDate><guid>/posts/linux_pthread_suspend_resume/</guid><description>Linux下线程pthread没有实现suspend,resume的相关功能，这几天项目需要，自己就使用pthread_cond_wait实现了下，把主要代码逻辑如下，贴出来供大家参考。 功能如下。 主线程监听用户消息，子线程完成实际任务。主线程需要依据用户输入控制工作子线程的暂停（suspend）和继续运行（resume）。 使用CTRL+C控制暂停、继续运行。 使用CTRL+\使程序退出，主线程先cancel，然后自己退出。 代码如下：
#include &amp;lt;pthread.h&amp;gt; #include &amp;lt;signal.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; typedef enum \_RUN\_STATUS{ STATUS\_RUNNING = 0, STATUS\_PAUSE, }RUN\_STATUS; sigset\_t mask; RUN\_STATUS run\_status; pthread\_mutex\_t lock = PTHREAD\_MUTEX\_INITIALIZER; pthread\_cond\_t waitloc = PTHREAD\_COND\_INITIALIZER; void cleanup\_handler(void\*arg) { printf(&amp;quot;child thread cleanup\\n&amp;quot;); pthread\_mutex\_unlock(&amp;amp;lock); } void \* thread\_func(void\*arg) { int err, signo; pthread\_cleanup\_push(cleanup\_handler, NULL); for(;;){ pthread\_mutex\_lock(&amp;amp;lock); if(run\_status == STATUS\_RUNNING){ pthread\_mutex\_unlock(&amp;amp;lock); printf(&amp;quot;child pthread task running-&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;\\n&amp;quot;); sleep(1); }else{ while(run\_status != STATUS\_RUNNING){ pthread\_cond\_wait(&amp;amp;waitloc, &amp;amp;lock); printf(&amp;quot;running again\\n&amp;quot;); } pthread\_mutex\_unlock(&amp;amp;lock); } } pthread\_cleanup\_pop(0); return 0; } int main() { int ret; run\_status = STATUS\_RUNNING; sigset\_t oldmask; pthread\_t tid; int err, signo; sigemptyset(&amp;amp;mask); sigaddset(&amp;amp;mask, SIGINT); sigaddset(&amp;amp;mask, SIGQUIT); pthread\_t tid\_self = pthread\_self(); if((ret = pthread\_sigmask(SIG\_BLOCK, &amp;amp;mask, &amp;amp;oldmask)) !</description></item><item><title>简要ClamAV安装、使用与实现分析</title><link>/posts/clamav_use_implement/</link><pubDate>Thu, 06 Mar 2014 10:52:57 +0000</pubDate><guid>/posts/clamav_use_implement/</guid><description>ClamAV使用广泛且开源的杀毒软件，支持windows、linux、Unix等主流操作系统，除自身具有病毒查杀功能外，还支持邮件、http代理扫描等插件方式。
安装 由于ClamAV的广泛使用，很多发行版的源里都有clamav，只需要使用相应的包管理工具进行安装即可。如fedora或ubuntu下只需执行：
yum install -y clamav-* sudo apt-get install clamav-*
但然，你也可以源码包安装，网上有很多教程，这里就不在多说。
使用 杀毒软件最终要的当然是病毒库，使用前当然是更新最新的病毒库。
freshclam
ClamAv有2种使用模式，单个程序查杀和前、后台模式查杀。 clamscan就是单个程序查杀的程序，它调用libclamav库完成对指定目录、文件的扫描检查。 clamd、clamdscan是前、后台模式的查杀工具。从名字就可以看出clamd是提供查杀服务的daemon程序，clamdscan是调用查杀服务的客户端。 最简单的使用方式就是命令后加你要扫描的文件或目录，如：
 clamdscan ～/
ClamAv当然也支持很多参数进行扫描定制，这里略过。 除了命令行的工具外还有很多第三方的图形化工具，如clamtk，更多的见：http://www.clamav.net/lang/en/download/third-party-tools/3rdparty-gui/
实现分析 ClamAv实现的是最原始的特征码扫描，而加载特征码库与实现扫描功能的代码都在libclamav库中实现，两种使用模式都是调用该库完成对应的扫描功能。 libclamav库API提供了病毒扫描的各种函数接口。从病毒中提取的特征字符串被用一定的格式组织在一起并加上签名保护就形成了病毒库，clamav使用的病毒库一般后缀为.cvd文件。 libclamav库的病毒扫描法使用Aho-Corasick精确字符串匹配算法，将病毒库中的特征码与文件中的字符串进行比较，以确定文件中是否有字符串精确匹配上病毒库中的特征码，从而确定是否感染病毒。 Aho-Corasick在Boyer-Moore算法基础上进行了的多种改进，Boyer Moore算法对要搜索的字符串进行逆序字符比较，当被搜索的字符串中的字符在特征字符串中不存在时，将跳过搜索字符串中一个子段。Boyer Moore算法还利用上一次比较的结果来确定下一次的比较位置，Boyer Moore算法与线性搜索比起来每次移动的步长比较多，线性搜索每次移动一个字符，因此，Boyer Moore算法比线性搜索快得多。Aho-Corasick通过创建一种状态图并采用由软件实现的有限状态机来确定字符串在文本中的位置，消除了搜索性能与字符串数量的相关性。 当然ClamAV必须实现相应的两个算法，看如下数据结构：
struct cli_matcher { unsigned int type; /* Extended Boyer-Moore */ uint8_t *bm_shift; struct cli_bm_patt **bm_suffix, **bm_pattab; uint32_t *soff, soff_len; /* for PE section sigs */ uint32_t bm_offmode, bm_patterns, bm_reloff_num, bm_absoff_num; /* HASH */ struct cli_hash_patt hm; /* Extended Aho-Corasick */ uint32_t ac_partsigs, ac_nodes, ac_patterns, ac_lsigs; struct cli_ac_lsig **ac_lsigtable; struct cli_ac_node *ac_root, **ac_nodetable; struct cli_ac_patt **ac_pattable; struct cli_ac_patt **ac_reloff; uint32_t ac_reloff_num, ac_absoff_num; uint8_t ac_mindepth, ac_maxdepth; struct filter *filter; uint16_t maxpatlen; uint8_t ac_only; #ifdef USE_MPOOL mpool_t *mempool; #endif };</description></item><item><title>file not recognized: File truncated错误解决办法</title><link>/posts/file-not-recognized-file-truncated%e9%94%99%e8%af%af%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95/</link><pubDate>Mon, 03 Mar 2014 02:30:17 +0000</pubDate><guid>/posts/file-not-recognized-file-truncated%e9%94%99%e8%af%af%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95/</guid><description>使用rpmbuild重新编译clamav，遇到了：file not recognized: File truncated。感觉不像时程序代码问题，找到以下解决办法：
when the compilation line looks like:c++ -Dmylib\_EXPORTS -Wall -Werror -g -fPIC -I/home/user/dev/mygit/build -I/home/user/dev/mygit/src -o CMakeFiles/mylib.dir/MyCppClass.cpp.o -c /home/user/dev/mygit/src/MyCppClass.cppcomes from the fact that, as stated, the generated object (.o) file is empty (or just truncated). A quick look can also tell it:ls -l CMakeFiles/mylib.dir/Now, when the issue remains even though you re-run the compilation line, it may come from the fact that the object (.o) file is empty/truncated within the compilation cache (ccache) itself.</description></item><item><title>cvechecker实现原理分析</title><link>/posts/cvechecker%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</link><pubDate>Thu, 27 Feb 2014 09:00:20 +0000</pubDate><guid>/posts/cvechecker%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</guid><description>cvechecker是由Sven Vermeulen编写的可以用来扫描检查系统软件cve情况的软件，在SF上的下载量非常高。自己在fedora上使用了下，对比yum的信息发现存在比较严重的漏报和误报，抽空分析了下其实现方式，总结如下 。 使用过cvechecker的用户都会猜测使用的是nist的cve(Common Vulnerabilities and Exposures)[1]信息获取软件的cve列表，但是怎么和系统上的软件联系在一起呢？ 各个发行版都有自己的软件包管理系统，如redhat系列的rpm、yum。redhat、fedora负责维护rhel和fedora上各个软件包的cve信息，当执行软件包升级时，使用新的软件包替换存在cve的软件包。基于deb包的ubuntu和debian类似。因此，在特定的发行版中，只需要通过包管理器便可知道软件包的版本号，再辅以发行版提供的漏洞信息或者直接使用类似yum update的方式升级便可知道当前版本的CVE信息。 cvechecker是怎么做的呢？Sven没有依赖于包版本管理器，而是直接通过查找软件包的版本号，然后构造CPE（Common Platform Enumeration）[2]信息，通过在cve数据库中查找给CPE信息来提取CVE信息。 每个软件包都包含了众多的软件，如ls和cat都属于coreutils,那么如何从系统软件列表差找到软件包列表及版本号便是Sven方法的关键所在。通过查看代码发现，Sven自己维护了一个软件包和各个命令的映射关系表。（https://raw.github.com/sjvermeu/cvechecker/master/versions.dat）内容类似与：
,perlivp,1,perlivp$,# perlivp v([0-9][0-9]*(\.[0-9]+)+),a,perl,perl,\1,,, ,libvorbis.so,1,libvorbis.so.*,Xiph.Org libVorbis ([0-9][0-9]*(\.[0-9]+)+),a,xiph,libvorbis,\1,,,
看过cvechecker帮助文档的用户都知道，用户自己也可以定义添加这种映射表，而默认的映射表是由Sven自己维护的，默认只有650条，因此这里就是漏报的一处主要原因。 这个隐射表解决了从命令到软件包的映射，但怎么获取软件包的版本号呢？继续看代码：
/** * Here is where the various version extraction methods are supported. * We currently still only support a single method (1, which is the * &amp;ldquo;strings -n 3 &amp;rdquo; command execution) but now we can see if we can * support additional methods as well. */ if (filetype == 1) { char buffer[BUFFERSIZE]; int ret; zero_string(buffer, BUFFERSIZE); ret = strings_extract_version(ws, &amp;amp;preg, pmatch, &amp;amp;cpe_data); if (ret == 0) { add_to_sqlite_database(ws, cpe_data); cpe_to_string(buffer, BUFFERSIZE, cpe_data); fprintf(stdout, &amp;quot; - Found match for %s/%s:\t%s\n&amp;quot;, ws-&amp;gt;currentdir, ws-&amp;gt;currentfile, buffer); }; } else { fprintf(stderr, &amp;quot; !</description></item><item><title>SELinux中核外应用查询策略API总结</title><link>/posts/selinux%e4%b8%ad%e6%a0%b8%e5%a4%96%e5%ba%94%e7%94%a8%e6%9f%a5%e8%af%a2%e7%ad%96%e7%95%a5api%e6%80%bb%e7%bb%93/</link><pubDate>Wed, 19 Feb 2014 15:23:31 +0000</pubDate><guid>/posts/selinux%e4%b8%ad%e6%a0%b8%e5%a4%96%e5%ba%94%e7%94%a8%e6%9f%a5%e8%af%a2%e7%ad%96%e7%95%a5api%e6%80%bb%e7%bb%93/</guid><description>SELinux中支持应用使用libselinux库来针对SELinux进行安全扩展（selinux aware application)，这样应用就可以使用SELinux的策略库来实现内部的访问控制，当前的passwd、dbus、udev等都使用selinux进行了扩展。其中passwd使用selinux进行密码修改检查，dbus对收、发进行了权限检查，分成了：acquire_svc和send_msg。 SELinux提供给用户空间的用户计算策略是否允许的接口主要有2类：selinux_check_access和avc_has_perm，下面对这两类接口进行说明。 selinux_check_access的函数原型为：
int selinux_check_access(const security_context_t scon, const security_context_t tcon, const char *class, const char *perm, void *audit‐ data);
需要输入的为主体、客体、客体类、权限集的字符串表示。 avc_has_perm的函数原型为：
int avc_has_perm(security_id_t ssid, security_id_t tsid, security_class_t tclass, access_vector_t requested, struct avc_entry_ref *aeref, void *auditdata);
需要输入的为主体、客体、客体类、权限集对应的id号，因此需要在使用以前将安全上下文与id号进行映射。在/usr/include/selinux/flask.h和/usr/include/selinux/av_permissions.h对客体类和权限集进行了定义，但是如果使用头文件中的编号，就导致应用与默认的refpolicy的编号顺序必须保持一致，否则容易导致编号与实际内容产生冲突。SELinux的开发者创建了selinux_set_mapping函数来动态建立客体类和权限集的映射关系。
int selinux_set_mapping(struct security_class_mapping *map); struct security_class_mapping { const char *name; const char *perms[]; };
例如：
static struct security_class_mapping dbus_map[] = { { &amp;ldquo;dbus&amp;rdquo;, { &amp;ldquo;acquire_svc&amp;rdquo;, &amp;ldquo;send_msg&amp;rdquo;, NULL } }, { NULL } }; #define DBUS__ACQUIRE_SVC 1 #define DBUS__SEND_MSG 2</description></item><item><title>[zz]redhat/centos 6.3 搭建git/gitosis/gitweb详细过程</title><link>/posts/zzredhatcentos-6-3-%e6%90%ad%e5%bb%bagitgitosisgitweb%e8%af%a6%e7%bb%86%e8%bf%87%e7%a8%8b/</link><pubDate>Thu, 13 Feb 2014 00:53:51 +0000</pubDate><guid>/posts/zzredhatcentos-6-3-%e6%90%ad%e5%bb%bagitgitosisgitweb%e8%af%a6%e7%bb%86%e8%bf%87%e7%a8%8b/</guid><description>1. gitweb安装
 注意：redhat的iso源是没有gitweb安装包，但是centos的源中有，在上一篇文章中给出了如何让redhat使用centos的源，那么，只需采用如下命令即可安装。
# yum install gitweb 2. gitweb配置
 gitweb默认安装到了/var/www/git下，其配置文件在/etc/gitweb.conf下，另外，httpd的配置文件/etc/httpd/conf.d/git.conf。
（1）修改/etc/gitweb.conf
$projectroot = &amp;ldquo;/var/www/git&amp;rdquo; //将projectroot修改为/var/www/git (2)修改/etc/httpd/conf.d/git.conf
Alias /git /var/www/git &amp;lt;Directory /var/www/git&amp;gt; Allow from all AllowOverride all Order allow,deny Options +ExecCGI AddHandler cgi-script .cgi DirectoryIndex gitweb.cgi SetEnv GITWEB_CONFIG /etc/gitweb.conf Dav On RewriteEngine Off （3）重启httpd
/etc/init.d/httpd restart （4）将gitosis仓库连接到/var/www/git下，完成web显示
ln -s /home/git/repositories/test_repo.git /var/www/git/ (5)通过浏览器浏览
http://xxxx/git/
注意： 如果git clone http://xxx/git/test_repo.git时出现git update-server-info错误，则在test_repos.</description></item><item><title>SELinux策略约束（constrain）里的L与H</title><link>/posts/selinux%e7%ad%96%e7%95%a5%e9%87%8c%e7%9a%84l%e4%b8%8eh/</link><pubDate>Mon, 20 Jan 2014 06:57:10 +0000</pubDate><guid>/posts/selinux%e7%ad%96%e7%95%a5%e9%87%8c%e7%9a%84l%e4%b8%8eh/</guid><description>在SELinux里，除了使用TE（type enforcement）来实现强制访问控制，还可以使用MLS机制的MCS或MLS。 MCS是single-sensitivity的安全机制，通过不同的categories来实现控制效果。 MCS的控制规则只能在base策略里面实现，如果想要修改refpolicy里的默认控制规则，可以修改策略里的mcs文件。MCS的基础内容如下：
mlsconstrain dir { search read ioctl lock } (( h1 dom h2 ) or ( t1 != mcs_constrained_type )); mlsconstrain dir { write setattr append unlink link rename add_name remove_name } (( h1 dom h2 ) or ( t1 != mcs_constrained_type ));
里面的mlsconstrain是约束语法，dir{search &amp;hellip;.}是对应的客体类和权限集。后面的就是MCS约束的定义。分为T、L、H{1/2}，分别表示类型（type），低安全集（L）和高安全集（H），之后的1，或2描述该表达式所限定的主体与客体，即L1表示主体的低安全级，如果上下文system_u:system_r:httpd_t:s0-s0:c0.c1024中，L1就是s0。 在selinux里面，看上面MCS对dir的约束定义，大家可能会有一个疑虑，selinux都是默认对当前级别（low level）进行判断，策略里面怎么是对high level进行判断。 看了下selinux的内核代码才知道缘由。 在selinux进行inode_doinit_with_dentry的时候，security_context_to_sid_default会到用到mls_context_to_sid对mls部分的上下文进行处理。该函数后部分有如下代码
if (l == 0) { context-&amp;gt;range.level[1].sens = context-&amp;gt;range.level[0].sens; rc = ebitmap_cpy(&amp;amp;context-&amp;gt;range.level[1].cat, &amp;amp;context-&amp;gt;range.level[0].cat); if (rc) goto out; }</description></item><item><title>Apparmor的前世今生</title><link>/posts/apparmor%e7%9a%84%e5%89%8d%e4%b8%96%e4%bb%8a%e7%94%9f/</link><pubDate>Wed, 01 Jan 2014 14:51:44 +0000</pubDate><guid>/posts/apparmor%e7%9a%84%e5%89%8d%e4%b8%96%e4%bb%8a%e7%94%9f/</guid><description>Apparmor是linux下安全机制的一种，使用LSM（Linux security modules），在2.6.36进入内核。以下介绍下Apparmor项目的发展历程。 1998～2003时，Apparmor在Immunix Linux中使用，当时名称是Subdomain。2005年5月10日，Immunix作为Novell的长期合作伙伴，被Novell收购，其中Apparmor是Novell的主要关注重点，而且被命名为Novell Apparmor。从2005年到2007年9月由Novell进行维护。2007年4月，Ubuntu进入Apparmor，进入Ubuntu 7.10包，作为Ubuntu8.04的一部分发布。 2007年9月，Novell将维护Apparmor的团队解散了。而Suse也在OpenSUSE11.1中引入了对SELinux的支持。作为Apparmor的founder和leader，Crispin Cowan和其他四个同事丢掉了在Novell的工作，当时Crispin表示会继续Apparmor的开发，他和其他2个同事Steve Beattie和Dominic Reynolds开办了Mercenary Linux公司，专注于Apparmor咨询工作。好景不长，2008年8月，有人发出了Apparmor is Dead的博文，引发讨论。随后 Crispin Cowan也在2008年加入了Windows Security Team。 从2009年开始，Canonical开始开发apparmor。现在的Maintainer是John Johansen john.johansen@canonical.com 参考资料： 1、blogs.msdn.com/b/michael_howard/archive/2008/01/17/crispin-cowan-joins-the-windows-security-team.aspx 2、en.wikipedia.org/wiki/Immunix 3、news.cnet.com/8301-13580_3-9796140-39.html 4、etbe.coker.com.au/2008/08/23/apparmor-is-dead/ 5、http://en.wikipedia.org/wiki/AppArmor</description></item><item><title>开发PHP扩展（extension)或模块(module)简介</title><link>/posts/%e5%bc%80%e5%8f%91php%e6%89%a9%e5%b1%95%ef%bc%88extension%e6%88%96%e6%a8%a1%e5%9d%97module%e7%ae%80%e4%bb%8b/</link><pubDate>Tue, 31 Dec 2013 02:17:57 +0000</pubDate><guid>/posts/%e5%bc%80%e5%8f%91php%e6%89%a9%e5%b1%95%ef%bc%88extension%e6%88%96%e6%a8%a1%e5%9d%97module%e7%ae%80%e4%bb%8b/</guid><description>PHP的插件分为两种:PHP extensions 和Zend Extensions.其中PHP extensions 被当作modules，而Zend extensions被当作extensions.这两个的主要差异在于Engine中注册了不同的钩子。（当然在插件代码编写和使用的配置文件中也存在一定差异，这是后话）
环境搭建 首先需要搭建基础的php环境，我采用Fedora自带的库，然后下载系统对应的rpm源码包编译后使用，这样就可以保证和系统自带版本一致。
yundownload &amp;ndash;source php rpm -ivh php-*.src.rpm Cd ~/rpmbuild/SPEC/ rpmbuild -ba php.spec
这样就有了php的源码环境。
代码编写 开发PHP插件可以使用源码中的ext_skel快速的生成框架代码，只需要简单的修改框架代码就可以生成一个可用的PHP插件。 最简单的使用模式就是 Php_src/ext/ext_skel &amp;ndash;extname=module 执行后生成了由你制定的module关联的几个文件，module.c和php_module.h,以及config.m4工程配置文件 对应的修改这几个文件就可以了。 如果是要开发zend_extension则记得添加如下内容
/* This is a Zend extension */ #ifndef ZEND_EXT_API #define ZEND_EXT_API ZEND_DLEXPORT #endif ZEND_EXTENSION(); ZEND_DLEXPORT zend_extension zend_extension_entry = {
编译测试 编译测试： 执行phpize生成configure文件 然后执行./configure和make 将module目录下的so文件拷贝到你要的目录，然后配置一个php配置文件 添加extension=path/module_name.so,如果是zend extensions，则是 Zend_extension=path/module_name.so 这样，就可以开始你的调试之旅了。</description></item><item><title>Fedora20上安装wps</title><link>/posts/fedora20%e4%b8%8a%e5%ae%89%e8%a3%85wps/</link><pubDate>Sat, 28 Dec 2013 08:26:49 +0000</pubDate><guid>/posts/fedora20%e4%b8%8a%e5%ae%89%e8%a3%85wps/</guid><description>日常使用难免需要用到处理文档，以下介绍如何在feodra20类似的系统上安装wps
下载最新版本的wps linux版本 可以从http://community.wps.cn/download/中下载。 例如wget http://wdl1.cache.wps.cn/wps/download/Linux/unstable/kingsoft-office-9.1.0.4244-0.1.a12p3.i686.rpm 3. 使用yum安装该rpm包（当然可以不下载，直接使用网络地址安装） sudo yum install kingsoft-office-9.1.0.4244-0.1.a12p3.i686.rpm 4.下载font文件，可以使用http://pan.baidu.com/share/link?shareid=3371036765&amp;amp;uk=505215462 rpm2cpio ../symbol-fonts-1.2-1.noarch.rpm |cpio -dium sudo cp -r usr/share/fonts/symbol-fonts/ /usr/share/fonts/ （详情参见http://linuxsec.net/?p=78） 可以了，开始使用吧。</description></item><item><title>主机名bogon问题</title><link>/posts/host_name_bogon_problem/</link><pubDate>Wed, 04 Dec 2013 16:13:00 +0000</pubDate><guid>/posts/host_name_bogon_problem/</guid><description>有时会发现主机名变成bogon了，偶然用nslookup发现了原因 172.16.141.139Server:61.234.254.5Address:61.234.254.5#53Non-authoritative answer:139.141.16.172.in-addr.arpaname = bogon.Authoritative answers can be found from:16.172.in-addr.arpanameserver = localhost.localhostinternet address = 127.0.0.1localhosthas AAAA address ::1&amp;gt;</description></item><item><title>sudo对selinux的支持及用法</title><link>/posts/sudo_for_selinux_support_and_usage/</link><pubDate>Mon, 02 Dec 2013 02:42:00 +0000</pubDate><guid>/posts/sudo_for_selinux_support_and_usage/</guid><description>sudo已经主持selinux，这样就可以在切换uid的同时切换上下文。实现的方式大致如下：再selinux.c的文件里面，提到了借鉴newrole的代码， 实验创建test用户 semanage login -a -s staff_u test修改sudoers文件，test ALL=(ALL) ROLE=sysadm_r TYPE=sysadm_t ALL然后使用test用户登陆,在执行sudo -Es后便转换上下文</description></item><item><title>Fedora20启用wayland</title><link>/posts/fedora20_enable_wayland/</link><pubDate>Sat, 30 Nov 2013 10:10:00 +0000</pubDate><guid>/posts/fedora20_enable_wayland/</guid><description>wayland开发正如火如荼，不久的将来就会代替现在的x，好奇就再f20上实验了以下，方法如下：更新xorg-x11-server,xorg-x11-drv-intel 和mutter-wayland然后有2中方法启用：1、在一个虚拟终端执行“mutter-wayland &amp;ndash;wayland&amp;quot;2、切换到控制台，登陆有执行,gnome-session &amp;ndash;session=gnome-wayland现在当然还有一些bug，而且只支持intel的显卡？毕竟还没有开发完成。。。</description></item><item><title>[zz]wayland and fedora</title><link>/posts/zzwayland_and_fedora/</link><pubDate>Thu, 28 Nov 2013 12:16:00 +0000</pubDate><guid>/posts/zzwayland_and_fedora/</guid><description>Wayland and Fedora Matthias Clasen Wed Mar 20 12:29:28 UTC 2013 Previous message:rawhide report: 20130320 changesNext message:Wayland and FedoraMessages sorted by: [ date ] [ thread ] [ subject ] [ author ]</description></item><item><title>Dbus学习总结</title><link>/posts/dbus_learning_summary/</link><pubDate>Tue, 19 Nov 2013 12:34:00 +0000</pubDate><guid>/posts/dbus_learning_summary/</guid><description>dbus使用的人比较多，在csdn上有几个人都介绍的比较详细，跟着走一次基本就可以掌握。推介http://blog.csdn.net/flowingflying/article/details/5512222系列的。可以掌握dbus-binding相关的使用方式，比较简单。对于method通信方式中，2端的连接，核心见如下的API：也就是必须要知道对方的destination (也就是bus name,object path,interface name和method。一个程序因该对应一个bus name,连接dbus-daemon的时候请求获得，一个应用可以有几个object path。interface 就是可以比较好的将method分类，方便使用。</description></item><item><title>[zz]Red Hat正与Intel紧密协作，力争在Fedora 21中默认加入Wayland</title><link>/posts/zz_red_hat_are_working_in_close_collaboration_with_intel_and_strive_to_default_in_fedora_21_added_wayland/</link><pubDate>Fri, 15 Nov 2013 05:55:00 +0000</pubDate><guid>/posts/zz_red_hat_are_working_in_close_collaboration_with_intel_and_strive_to_default_in_fedora_21_added_wayland/</guid><description>Red Hat正与Intel紧密协作，力争在Fedora 21中默认加入Wayland2013-9-22 12:45| 发布者: linux| 查看数: 190| 评论数: 3|赞0摘要: 为了使Wayland支持GNOME，Red Hat与Intel的开发者紧密合作，希望能为Wayland加入Fedora21做好及时准备。 Ubuntu曾企图征服FOSS（Free and Open Source Software自由和开源软件）世界的秘密计划被Intel的一纸声明挫败 &amp;hellip;为了使Wayland支持GNOME，Red Hat与Intel的开发者紧密合作，希望能为Wayland加入Fedora21做好及时准备。Ubuntu曾企图征服FOSS（Free and Open Source Software自由和开源软件）世界的秘密计划被Intel的一纸声明挫败，至少到现在为止，Ubuntu仍未能翻身。但如今，Intel开发者的真正计划也被揭露了。抛开那些戏剧化的剧情，实际上Intel为Wayland的未来投入巨资已不是秘密，Intel的开发者们正加紧与Red Hat的合作，争取将GNOME Shell变为一个&amp;quot;码农&amp;quot;（译注，意指GNOME Shell只完成表层的外围工作）。来自Red Hat的Christian Schaller在他的个人博客中写道：“我们在Red Hat的团队一直在和我们的同行Intel紧密协作，合并并稳固相关的补丁包，保证Wayland能够支持GNOME，同时查看堆栈中还有哪些地方需要进一步改进。”看起来这个小组当前的目标是为Fedora 20准备一个足够的技术预览版本，至少目前是这样。这不是一个正式项目，但至少应该会给人们一个值得期待的idea。Ubuntu13.10预定于10月份发布，在这个特殊的时间点上，Canonical是否会急切的使出全力力推Mir，目前还并不明朗。Schaller在他的博客中还写道，“因此，一旦确信用户不会感到负面影响，我们才会最终用Wayland替代X服务器。所以，在Fedora 21中默认采用Wayland还是X服务器，这仍然是一个悬而未决的问题。”这场显示服务端之间的“战争”即将决出一个赢家，那就是终端用户。为了提供更好的用户体验，决战双方，Intel和Canonical都更加充满斗志。无论谁胜谁负，最终受益的都将是我们这些用户。 via:http://news.softpedia.com/news/Red-Hat-and-Intel-Working-Closely-to-Bring-Wayland-as-Default-for-Fedora-21-383119.shtml</description></item><item><title>[zz]linux如何查看CPU，内存，机器型号，网卡信息</title><link>/posts/zz_linux_how_to_view_cpu_memory_machine_type_card_information/</link><pubDate>Fri, 08 Nov 2013 05:52:00 +0000</pubDate><guid>/posts/zz_linux_how_to_view_cpu_memory_machine_type_card_information/</guid><description>中国蓝天linux如何查看CPU，内存，机器型号，网卡信息查看CPU信息（型号）# cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 8 Intel(R) Xeon(R) CPU E5410 @ 2.33GHz(看到有8个逻辑CPU, 也知道了CPU型号)# cat /proc/cpuinfo | grep physical | uniq -c 4 physical id : 0 4 physical id : 1(说明实际上是两颗4核的CPU)PS：Jay added on 10th, May, 2011# 其实是可能有超线程HT技术，不一定是有4核，也可能是2核4线程；当时还理解不清楚# getconf LONG_BIT 32(说明当前CPU运行在32bit模式下, 但不代表CPU不支持64bit)# cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 8(结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit)再完整看cpu详细信息, 不过大部分我们都不关心而已.# dmidecode | grep -A81 &amp;lsquo;Processor Information&amp;rsquo;查看主板型号：# dmidecode |grep -A16 &amp;ldquo;System Information$&amp;ldquo;内存槽及内存条：# dmidecode |grep -A16 &amp;ldquo;Memory Device$&amp;ldquo;查看内存信息# cat /proc/meminfo# uname -aLinux euis1 2.</description></item><item><title>[zz]Fedora 18 安装fcitx</title><link>/posts/zz_fedora_18_install_fcitx/</link><pubDate>Wed, 06 Nov 2013 16:16:00 +0000</pubDate><guid>/posts/zz_fedora_18_install_fcitx/</guid><description>之前配置过fcitx,后来系统升级下就无法使用了，一直看不到输入选词框。后来就采用ibus了。看到了下面的文章，有空再配下。用ibus用了一段时间后苦于对其输入准确性的蛋疼换了fcitx，感觉fcitx-cloudpinyin + fcitx-sunpinyin+搜狗词库的体验要比ibus好很多了。下面给上安装方法。1、卸载ibus相关组件感觉这个没啥好说的，命令类似yum remove ibus*啥的自己看着搞，注意别误卸载一些其他重要软件就好2、安装 fcitx fcitx-sunpinyin fcitx-cloudpinyinsudo yum -y install fcitx fcitx-sunpinyin fcitx-cloudpinyin fcitx-config这里安装config是为了配置方便，既然已经决定在图形下了，也没必要非得去用vim修改配置文件这种方法对吧，虽然vim修改起来定制性更多，但是感觉config提供的功能已经足够了3、在自己的.bashrc文件里添加fcitx相关条目，同时在gnome里给fcitx添加开机启动.bashrc里的内容如下:export XMODIFIERS=@im=fcitxexport QT_IM_MODULE=ximexport GTK_IM_MODULE=xim然后alt+f2 输入gnome-session-properties，添加一个启动条目，名称命令都是fcitx4、注销或者重启后应该就ok了。</description></item><item><title>[zz]fedora18升级到fedora19</title><link>/posts/zz_fedora18_upgraded_to_fedora19/</link><pubDate>Wed, 06 Nov 2013 16:08:00 +0000</pubDate><guid>/posts/zz_fedora18_upgraded_to_fedora19/</guid><description>升级fedora 18到fedora 19猫终于发布了，之前看过gnome 3.8的介绍视频，感觉比3.6比起来要好太多了，所以很期待，全新安装也太麻烦，所以准备升级安装。fedora提供有升级工具fedup，升级起来还是比较方便的。下面结合官方文档和自己升级的经验说说升级流程。1、准备工作首先把系统彻底的更新一遍sudo yum -y upgrade安装fedupsudo yum -y install fedup2、开始升级这里要分两部，首先下载更新需要的包，有三个途径可以选择，网络，本地镜像，或者做好的启动光、U盘，这里我用网络更新，这也是官方推荐的更新方式，因为这样可以直接更新到目前最新的包sudo fedup &amp;ndash;network 19下载完毕后会提示你结果，正常的话就会提示你让你重启reboot接下来就比较漫长了，一切都不用管，以为内fedup会在你的grub.cfg里添加一个入口，不管你之前默认的是那个，只要你不在reboot前更新你的grub.cfg，那就可以放手喝杯茶静静的等了，开始升级的时候就是一个fedora蓝水滴呼吸闪烁下方一个进度条，进度条滚完再等一会，然后可能会重启，之后就能进入fedora 19了。但是这里要注意的是，如果你装了闭源驱动的话，我是nvidia的闭源驱动，在进度条滚完后可能会卡死，这里没什么，等一会，没反映强制关机就好了，关机时候不会听到硬盘急停的声音，说明进度条滚完确实要重启的，只不过我们因为驱动被卡在重启那里不动了。。不过要记得重启后赶快重装驱动，省得一些不比要的麻烦。3、清理工作这里比较恶心的就是fedup可能在更新完后不能正确清理，只能手动来清理了sudo fedup &amp;ndash;resetbootloadersudo fedup &amp;ndash;clean这样grub.cfg和升级后的一些临时文件就能清理掉一些，接着sudo yum clean allsudo yum distro-sync来把包都更成最新的，然后要清理fedora 18的残留内核，因为是版本升级，所以18的内核就都没用了，都要清掉，命令如下:sudo package-cleanup &amp;ndash;oldkernels &amp;ndash;count 1成功后升级你的配置文件，如果不失败，估计是你装得什么东西还对内核有依赖，yum删掉后再清除内核，然后更新grub2配置文件sudo grub2-mkconfig -o /boot/grub2/grub.cfg更新你的grub2配置文件,重启reboot如果发现grub2变得很丑的话，进入系统后sudo yum -y reinstall gurb2*sudo grub2-mkconfig -o /boot/grub2/grub/cfg这样就能解决问题然后再更新一边你的配置文件sudo grub2-mkconfig -o /boot/grub2/grub/cfg重启看看，是不是一切都回到原样了～哈哈到这里升级就搞定了。值得说的是gnome 3.8里面im-chooser依然是不能用的。我是升级安装，不知到这个玩意在19的liveCD里还有没有。但是顶部状态栏现在即使只有一个输入源的情况下依然显示输入法图标，为输入和设置添加不少方便。启动器可以通过dconf-tool来自己创建app folder，不过名字却要是那几个给定的名字，我只能一个个的试，现在可用的有DeveloperTools,Office,Accessories,总之和win Eng里的名字都差不多，自己慢慢去搞吧，这里就说这么多了，和猫玩去咯～</description></item><item><title>selinux支持动态客体类添加</title><link>/posts/adding_support_for_dynamic_object_class_selinux/</link><pubDate>Wed, 06 Nov 2013 13:06:00 +0000</pubDate><guid>/posts/adding_support_for_dynamic_object_class_selinux/</guid><description>现在linux内核大概从2.6.33开始支持动态客体了的添加，即可以不重新编译内核，直接编译selinux策略即可添加客体类，这样做有什么好处呢？如过开发一个selnux aware的应用程序，且该程序引入了一个或多个客体类，则可以直接修改策略，即可以使用。所以现在核外的很多应用都针对的进行了修改，核外请求客体类和操作集的时候应该都是用名字，即“class”和&amp;quot;perm&amp;quot;来传递到内核进行判断，如果是传递flask.h或av_permissions.h中的值，则可能会导致请求的客体类和内核所设定的客体类不匹配的问题。所以核外应该使用selinux_set_mapping或者selinux_access_check来进行检查，而不知直接使用avc_has_perm.</description></item><item><title>[zz]cgit安装部署</title><link>/posts/zz_cgit_installation_and_deployment/</link><pubDate>Wed, 30 Oct 2013 16:05:00 +0000</pubDate><guid>/posts/zz_cgit_installation_and_deployment/</guid><description>[how to] 如何在ubuntu上安装cgit分类： git2010-07-03 16:38 1688人阅读 评论(0) 收藏 举报ubuntuapachedeb工具gitcss cgit 是一种git 代码浏览工具，类似gitweb ，但是更快速，openembedded ,freedeskop 等项目都在采用cgit。我就尝试在我的ubuntu 10.04安装了cgit，感觉不错。步骤如下:安装cgit两种选择:1 直接用deb二进制包安装，点击这里 去下载 2 编译源代码,参考官方readme安装apache2假设你的DocumentRoot 是/var/www$ sudo mkdir /var/www/cgit$ sudo cp /usr/share/cgit/cgit.css /var/www/cgit$ sudo cp /usr/share/cgit/cgit.pnf /var/www/cgit建立一个cgit配置文件在/etc/apache2/conf.d/目录下面[cpp] view plaincopyalias /cgit /var/www/cgit &amp;lt;Directory &amp;ldquo;/var/www/cgit/&amp;quot;&amp;gt; AllowOverride None Options ExecCGI DirectoryIndex /cgi-bin/cgit.cgi Order allow,deny Allow from all cgit 配置文件cgitrc在/etc下面[c-sharp] view plaincopycss=/cgit/cgit.css logo=/cgit/cgit.png repo.url=cgit.git repo.path=/home/lynn/cgit.git repo.desc=demo repo.owner=lynn 重启apache2然后打开 http://localhost/cgit 就可以了</description></item><item><title>[zz]负载和性能测试的工具汇总</title><link>/posts/zz_load_and_performance_testing_tools_summary/</link><pubDate>Fri, 18 Oct 2013 05:32:00 +0000</pubDate><guid>/posts/zz_load_and_performance_testing_tools_summary/</guid><description>负载和性能测试的工具汇总时间:13-10-15 栏目:web测试, 测试 作者:admin, admin 评论:0 点击: 10 次本文标签： web测试Agileload - 敏捷负载SA测试所有类型的网络和移动应用的负载测试工具。主要功能包括自动记录测试场景，分布式的负载注射器，拓扑和阈值分析异常，基础设施监控，为每个用户配置文件中创建自定义的测试报告。也可在Amazon EC2上。对于Web服务， HTML / AJAX ， Web 2.0的，如Adobe的Flash / Flex中， J2EE ， 。NET ， PHP，大型门户网站， ERP / CRM门户网站，微软的Silverlight ，微软SharePoint 。 负载测试仪LITE - 自由/低成本的负载测试工具从Web性能股份有限公司 - 精简其负载测试仪PRO ™ 5软件版本。运行测试用例1,000,000虚拟用户没有从用户托管的服务器的成本，或从云服务器在每小时1美元。为了测试网站的性能，如原始带宽，防火墙和负载平衡器吞吐量，特别是单页面加载时间的基本方面。 LoadZen - 基于云计算负载测试服务从LoadZen ，使仿真数万数以千计的虚拟化的并发用户。其功能包括可变斜坡上升利率来改变测试的流量模式，随机虚拟用户的行为，定期测试，并更多。免费使用多达25个并发用户。 崇 - 免费开放源码的多协议分布式负载测试工具支持的流程之一。可以用来强调HTTP ， WebDAV的， SOAP和PostgreSQL ， MySQL和LDAP的Jabber / XMPP服务器。还支持SSL 。 OS监控（ CPU，内存和网络流量）使用远程服务器上的SNMP ，穆宁或二郎山剂。可以使用XML配置系统;几个会话，以模拟不同类型的用户。动态会话可以在XML描述。网友认为时间和到达率可以是随机的，使用的概率分布。在装载过程中，可以生成HTML报告，查看响应时间测量，服务器CPU ，等在Erlang开发。 Telerik测试的工作室 - Telerik测试的工作室附加的负载测试。负载测试可以利用现有的功能测试或Fiddler日志创建或可以从头捕获。设有一个单一的的VU许可证类型覆盖范围和极其强大的技术和协议能够产生极端增加硬件/系统要求高的用户负载，而不加载代理。 Loadster - 负载测试工具，测试网站， Web应用程序和HTTP web服务为导向，以从砖厂科技公司，包括图形脚本编辑器，现场报道，和无限的虚拟用户。同时执行多个脚本，多个虚拟用户群，坡道用户加载了上下几乎无限的可能性，模拟虚拟用户的网络带宽，调整或随机等待时间，并添加阈值微调测试输入。免费版本。 Loadtracer - Web负载测试工具，从跟踪技术列兵。公司包括录像机，模拟和分析仪。刻录机支持参数化，变量管理，响应验证;模拟器支持多达几千个虚拟用户，分析仪可以生成图表和报告可汇出成各种格式。 HttpRider - 一个轻量级的，开源的工具，网站负载，性能和压力测试。 NET开发的亚历博泰兹。创建HTTP场景分析HTTP请求使用提琴手和复制他们根据用户的配置。可以自定义它们绑定到自定义数据源模仿不相同请求的查询字符串和POST参数。需要Windows NET 4.</description></item><item><title>【zz】linux内核e820来源及相关知识</title><link>/posts/zz_linux_kernel_sources_and_relevant_knowledge_e820/</link><pubDate>Wed, 16 Oct 2013 16:57:00 +0000</pubDate><guid>/posts/zz_linux_kernel_sources_and_relevant_knowledge_e820/</guid><description>http://hi.baidu.com/ballmillsap/item/c2f3cf6f43d3220aa1cf0fe4e820简介操作系统内存布局中断 int 0x15e820简介 收藏本文系转载，原文地址：http://wangcong.org/blog/?p=320，其中附录部分 为本人所加&amp;hellip; e820是和BIOS的一个中断相关的，具体说是int 0x15。之所以叫e820是因为在用这个中断时ax必须是0xe820。这个中断的作用是得到系统的内存布局。因为系统内存会有很多段，每段的类型属性 也不一样，所以这个查询是“迭代式”的，每次求得一个段。 我们看内核源代码。主要涉及两个文件：arch/x86/boot/memory.c和arch/x86/kernel /e820_32.c。我们 已经很幸运了，这部分代码已经用C重写过了。你可能会奇怪，启动调用e820时我们还在实模式，怎么能用C呢？答案是，这里用的是16位的C。gcc早已 经支持.code16 gcc模式了。 看detect_memory_e820()函数，里面就是e820的本质。它把int 0x15放到一个do-while循环里，每次得到的一个内存段放到struct e820entry里，而struct e820entry的结构正是e820返回结果的结构！而像其它启动时获得的结果一样，最终都会被放到boot_params里，e820被放到了 boot_params.e820_map。如果你对struct e820entry还有疑问，你可以看一下arch/x86/kernel/e820_32.c::print_memory_map()，看看里面是怎 么使用它的。 当然了，在arch/x86/boot/memory.c里，你还会看到另外两个利用int 0x15查询内存的函数，不过用途不一样了。附：boot_params 结构体定义，其中E820MAX 定义为128:struct e820entry {__u64 addr; /* start of memory segment */__u64 size; /* size of memory segment */__u32 type; /* type of memory segment */} __attribute__((packed));struct boot_params { struct screen_info screen_info; /* 0x000 */ struct apm_bios_info apm_bios_info; /* 0x040 */ __u8 _pad2[12]; /* 0x054 */ struct ist_info ist_info; /* 0x060 */ __u8 _pad3[16]; /* 0x070 */ __u8 hd0_info[16]; /* obsolete!</description></item><item><title>selinux客体类实验分析</title><link>/posts/experimental_analysis_selinux_object_class/</link><pubDate>Wed, 16 Oct 2013 09:45:00 +0000</pubDate><guid>/posts/experimental_analysis_selinux_object_class/</guid><description>内核从2.6.33开始实现对策略的dynamic class/perm discovery,修改了内核中客体类的存放方式，使得class indices不再关联实际值。即策略中的客体类的位置可以随意写。RHEL6系列的内核将该功能下移，在RHEL6.0正式版本的内核中便有该功能（beta版本中没有）。实验：采用dummy策略添加新的客体类使用notebook的security_compute_av_example用例，对自己新加的客体类进行测试。修改notebook.conf文件，添加user_u:base_r:base_t测试一如果采用标准2.6.32.25内核，可以添加新的客体类。但是在如dummy策略中，添加的客体类位置不能影响默认的内核客体类，如必须替代里面用户空间的客体类，或者再最后面添加。自己给里面添加了20个，运行正常。如果覆盖了默认内核客体类的位置,load_policy时提示策略加载失败。Class 1 is incorrect ,found class1 but should be security如果采用新内核，则可以在任意位置添加客体类，系统及策略均运行正常。等有空的时候再研究下策略加载，理解里面class在内核的存放以及使用方式才能真正理解该patch的作用。Perm获取最后通过discover_class通过读取/class/*/index,以及/class/*/perms/下面的内容来获取客体类及权限相关的内容里面涉及到比较多的调用通过实验如果是一个新的，通过策略添加的用户空间的客体类和权限，那么在测试的时候，数据是使用策略中的数据，而不是头文件中定义的数据。所以应该是通过接口文件从策略里面读取出来的。相关的2个patch如下</description></item><item><title>[zz]Why Sailfish is better as a modern OS? Here is a comparison</title><link>/posts/zzwhy_sailfish_is_better_as_a_modern_os_here_is_a_comparison/</link><pubDate>Sat, 12 Oct 2013 09:59:00 +0000</pubDate><guid>/posts/zzwhy_sailfish_is_better_as_a_modern_os_here_is_a_comparison/</guid><description>Why Sailfish is better as a modern OS? Here is a comparisonAhoy sailors!Ever since Sailfish is known to us as an operating system not an actual “fish”, there were a lot of demos on YouTube; many people were literally amazed by the work of Finnish, some went: “This’ll be a failure like MeeGo-Harmattan” Which in fact wasn’t a failure and you’ll only know when you own a Nokia N9/50!On one hand the truth is, that “if” MeeGo-Harmattan had a fair bit of support, none of this would have happened to it and we didn’t know what’s Jolla and Sailfish at the moment, on the other hand; if Nokia had supported Harmattan and we were satisfied enough, we probably were spending our time playing with Windows Phone UI as we were convinced that MeeGo is dead, and were using an old school back button!</description></item><item><title>[zz] linux常见发行版和kernel版本对应关系</title><link>/posts/zz_linux_kernel_version_releases_and_common_correspondence_between/</link><pubDate>Sat, 12 Oct 2013 04:43:00 +0000</pubDate><guid>/posts/zz_linux_kernel_version_releases_and_common_correspondence_between/</guid><description>linux常见发行版和kernel版本对应关系 2010-06-22 13:47:08分类： LINUXDebian 5.04 2.6.26Fedora 62.6.18Fedora 82.6.23Fedora 92.6.25Fedora 102.6.27Fedora 112.6.29Fedora 122.6.31mandriva 20102.6.31openSUSE 10.32.6.22suse 10.12.6.16suse 11.22.6.31redhat Enter 4.32.6.9redhat 9.02.4.20redhat Enter 5.42.6.18ubuntu 8.042.6.24ubuntu 9.042.6.28ubuntu 9.102.6.31</description></item><item><title>[zz]bash脚本中出现[[:not found错误的解决方法--bash脚本总结</title><link>/posts/bash_script_summary_-_not_found_error_solution_zz_bash_script_appears/</link><pubDate>Thu, 10 Oct 2013 03:31:00 +0000</pubDate><guid>/posts/bash_script_summary_-_not_found_error_solution_zz_bash_script_appears/</guid><description>今天在写脚本的时候，发生了一个奇怪的问题：在脚本中使用[[的时候报错“[[: not found”。遇到问题自然是解决问题。1. 使用的bash版本太低？bash &amp;ndash;version查看bash版本信息如下lee@lee:~$bash &amp;ndash;versionGNU bash, version 3.2.39(1)-release (i486-pc-linux-gnu)Copyright (C) 2007 Free Software Foundation, Inc.在google bash手册，3.2.39已经不算低了，完全支持[[这样的扩展。看来不是版本问题。2.是脚本中[[使用错误？写测试脚本进行测试。test.sh测试脚本内容如下#!/bin/bash[[ 1 ]] &amp;amp;&amp;amp; echo &amp;ldquo;successful&amp;quot;执行后仍然是“[[: not found”。但是，在bash交互模式下执行[[ 1 ]] &amp;amp;&amp;amp; echo &amp;ldquo;successful&amp;quot;命令，却是成功的，执行结果如下lee@lee:~$ [[ 1 ]] &amp;amp;&amp;amp; echo &amp;ldquo;successful&amp;quot;successfullee@lee:~$看来bash是支持[[扩展的，那么，问题应该就是出在脚本上。3.脚本里的问题存在于哪里呢？显然，那条孤零零的命令是没问题的，因为已经在交互模式下验证过了。脚本里还有一行#!/bin/bash用来指定运行该脚本所使用的shell类型。显然，我们这里就是要使用bash，所以这一行也没有问题。4.既然脚本的内容没有问题了，那问题究竟在哪里呢？从编写和运行等几个环节仔细思考，脚本既然没问题，那问题是不是出在 运行环节上？出于习惯，我经常喜欢$ sh test.sh这样的运行脚本的 方式，那么，换一种运行方式是不是能解决问题呢？在终端下用./test.sh运行，果然，运行成功！至此，问题的症结找到。4.1下面的问题是，为什么sh test.sh与./test.sh有着不同的运行结果。通过查看(ls -l /bin)得知，sh只是一个符号链接，最终指向是一个叫做dash的程序lee@lee:~$ ls -hl /bin | grep sh-rwxr-xr-x 1 root root 686K 2008-05-13 02:33 bash-rwxr-xr-x 1 root root 79K 2009-03-09 21:03 dashlrwxrwxrwx 1 root root 4 2010-03-03 01:52 rbash -&amp;gt; bashlrwxrwxrwx 1 root root 4 2010-03-03 01:53 sh -&amp;gt; dashlrwxrwxrwx 1 root root 4 2010-03-03 01:53 sh.</description></item><item><title>kerberos中wrong principal in request的一个可能原因，#define KRB5KRB_AP_WRONG_PRINC (-1765328240L)</title><link>/posts/kerberos_the_wrong_principal_in_one_of_the_possible_causes_request__define_krb5krb_ap_wrong_princ_-1765328240l/</link><pubDate>Thu, 19 Sep 2013 18:56:00 +0000</pubDate><guid>/posts/kerberos_the_wrong_principal_in_one_of_the_possible_causes_request__define_krb5krb_ap_wrong_princ_-1765328240l/</guid><description>最近配置kerberos，配置后用sclient测试的时候遇到wrong principal in request，搜了下没有找到解决办法，用gdb调了下发现原来是我的主机名配置的有问题。错误信息如下。修复方式为：如使用kerberos.example.com则主机名也为kerberos.example.com主机名的修改方式为：Fedora上是修改&amp;quot;/etc/hostname&amp;quot; 文件rhel主机名配置为/etc/sysconfig/network</description></item><item><title>[zz]Fedora 18的变化</title><link>/posts/zz_changes_in_fedora_18/</link><pubDate>Thu, 19 Sep 2013 15:39:00 +0000</pubDate><guid>/posts/zz_changes_in_fedora_18/</guid><description>fedora每次发布新版本都会发生巨变，本次变化&amp;ndash;/etc/sysconfig 已停止使用/etc/sysconfig/clock 由 /etc/localtime 代替/etc/sysconfig/i18n 已由 /etc/locale.conf 代替/etc/sysconfig/keyboard 变为 /etc/vconsole.conf主机名配置由 /etc/sysconfig/network 移至 /etc/hostnameFedora 18 支持 UEFI 安全引导。即在启用了安全引导的计算机上能够引导 Fedora.有工具可让管理员创建自定义证书，以签署本地环境下对 GRUB 和内核的修改。通过默认启用 rngd 改善了随机数生成。使用 SELinux 和 virt-sandbox 后，服务可在安全沙盒中运行，即使是 root 用户也是如此。virt-sandbox-service 软件包将创建挂载点和 libvirt 容器。现在有了 libseccomp 库，提供给应用程序一个简单的方式来减少误用内核 kernel syscall 过滤器带来的伤害。得益于此，虚拟机软件比如 QEMU/KVM 已经开始使用 libseccomp 了。usermode,一个为无特权用户提供特权访问的封装器，已经被更好的 polkit 所取代。Fedora 18 将 Kerberos 证书缓存的标准位置变更到 /run/user/$UID 来增强安全性并简化用于 NFSv4 的缓存的定位。Fedora 的 Kerberos 支持将允许用户维护适用于多个身份的证书，且允许GSSAPI 客户端代码可以依据目标服务和主机名自动选择证书。无特权用户能否使用 halt（8）， poweroff（8） 和 reboot（8） 命令现在由 polkit 控制。参看 /usr/share/polkit-1/actions/org.freedesktop.login1.policy 中的行为描述。将不再使用放置在 /etc/pam.d/{halt,poweroff,reboot} 中的 PAM 配置文件。里面的内容，如果有的话，也将被忽略。Fedora 18 新增 FedFS,该程序用来为多个文件服务器提供一致的命名空间。/tmp 默认会位于 tempfs.</description></item><item><title>django中添加xmlrpc支持</title><link>/posts/django_add_xmlrpc_support/</link><pubDate>Mon, 16 Sep 2013 13:44:00 +0000</pubDate><guid>/posts/django_add_xmlrpc_support/</guid><description>实现一个xmlrpc功能模块，代码如下add the following to urls.pyThat&amp;rsquo;s it!You can pretty much write a standard python function in there, just be sure to register it with the dispatcher when you&amp;rsquo;re done.Here&amp;rsquo;s a quick and dirty client example for testing:Based on experience, I do recommend that you use Dictionaries for your args rather than long args, but I think that&amp;rsquo;s personal preference (It allows named arguments, eliminates &amp;lsquo;out of order&amp;rsquo; argument issues and it makes the code more self-documenting).</description></item><item><title>django中使用xmlrpc报403问题解决办法</title><link>/posts/django_403_problems_reported_using_the_xmlrpc_solution/</link><pubDate>Mon, 16 Sep 2013 13:40:00 +0000</pubDate><guid>/posts/django_403_problems_reported_using_the_xmlrpc_solution/</guid><description>Django&amp;rsquo;s CSRF protection is turned on by default now, and is quite effective at blocking cross site requests, including RPC requests like this.Symptoms:Valid XMLRPC requests to the xmlrpc endpoint are greeted with a 403 Forbidden response. This is generated by the CSRF middleware because a CSRF token isn&amp;rsquo;t being included in the POST.Resolution:Turn of CSRF for the handle_xmlrpc method.In django_xmlrpc/views.py, add the csrf_exempt decorator to the handle_xmlrpc method:from django.views.decorators.csrf import csrf_exempt&amp;hellip;@csrf_exemptdef handle_xmlrpc(request): &amp;hellip;.</description></item><item><title>ubuntu13.4server安装及图形安装</title><link>/posts/ubuntu134server_installation_and_graphical_installation/</link><pubDate>Sun, 15 Sep 2013 17:20:00 +0000</pubDate><guid>/posts/ubuntu134server_installation_and_graphical_installation/</guid><description>非CD安装ubuntu13.4server有一个方法，就是把下载的iso写到u盘里，然后用u盘启动安装。我采用的utraliso写的u盘，还有其他的工具可以使用。非常方便。之前使用硬盘安装12.4desktop的方法无法安装13.4servers。所以采用了上面的方法。安装后发现没有图形，有时候又需要图形来进行调试、显示。故又搜索安装图形的方法，可以通过一下方式解决。apt-get install ubuntu-desktop然后重启就可以了。</description></item><item><title>openstack重启br-ex丢失解决办法</title><link>/posts/openstack_restart_br-ex_missing_solution/</link><pubDate>Thu, 12 Sep 2013 09:15:00 +0000</pubDate><guid>/posts/openstack_restart_br-ex_missing_solution/</guid><description>安装RDO成功后，如果重启系统，br-ex就会丢失，没有开机启动，导致网络有问题，只要手工添加配置文件就可以解决该问题一下是我的配置文件/etc/sysconfig/network-scripts/ifcfg-br-ex/etc/sysconfig/network-scripts/ifcfg-eth1/etc/sysconfig/network-scripts/ifcfg-eth2相应的按照你的配置修改配置文件，重启网络服务、或系统即可正常使用。</description></item><item><title>openstack简单使用</title><link>/posts/openstack_simple_to_use/</link><pubDate>Thu, 12 Sep 2013 05:44:00 +0000</pubDate><guid>/posts/openstack_simple_to_use/</guid><description>openstack的界面虽然还不完善，但是基本功能都已经有了，而且比较明了。下面简要记录下使用流程，为刚刚接触openstack的一些指引。简单使用：登录系统点击“Images&amp;amp;Snapshots”点击Images列表右边的Launch输入instance name,实例名字Flavor选择smallInstance count是实例个数Access&amp;amp;security为导入实例的keyNetworking选择private然后点击launch点击instances查看当前的实例运行情况点击实例，在对应的实例上点击”more“-》”associate floating ip”等分配成功后，可以通过该floating ip访问该虚拟机Ssh -i key.pem fedora@ip</description></item><item><title>ubuntu12.4硬盘安装</title><link>/posts/ubuntu124_hard_disk_installation/</link><pubDate>Tue, 10 Sep 2013 13:16:00 +0000</pubDate><guid>/posts/ubuntu124_hard_disk_installation/</guid><description>下载镜像后，提取下载镜像casper文件夹下的vmlinuz initrd.lz放到系统盘的根目录下，ubuntu12.04的安装镜像则保存为linux.iso也放在系统盘下。然后修改或手工收入grub参数启动如果是grub2.0,则为set root=(hd0&amp;hellip;.)使用自动补全即可linux /vmlinuz&amp;hellip;其他相同</description></item><item><title>Fedora19上安装rdo-openstack-havana</title><link>/posts/fedora19_install_rdo-openstack-havana/</link><pubDate>Tue, 10 Sep 2013 12:19:00 +0000</pubDate><guid>/posts/fedora19_install_rdo-openstack-havana/</guid><description>最小化安装fedora19,只使用fedora源，把update和update-testing关掉。更新系统（好像也没有必要）后按照文档进行安装。我安装了havana版本安装后再更新解决horizon报错问题。详情见：https://bugzilla.redhat.com/show_bug.cgi?id=1000391这样系统就可以使用了floating ip好像还有点问题，等解决了再更新。</description></item><item><title>openstack安装试用</title><link>/posts/openstack_installation_trial/</link><pubDate>Fri, 06 Sep 2013 06:51:00 +0000</pubDate><guid>/posts/openstack_installation_trial/</guid><description>近期准备学习下openstack，便自己实验openstack安装。把这几天的过程记录下来。由于openstack组建众多，对于一个新手来说还是比较复杂的。当前有很多种安装openstack的方式。最早我在fedora19上实验了devstack,安装后有问题，安装过程有一个服务链接timeout，手动没有问题；创建的虚拟机也无法正常使用，便告一段落，现在回想也可能是当时使用不怎么正确。然后使用RDO在fedora19上安装，不管使用update-testing源，还是稳定的yum源，解决了安装过程中各种报错后的系统无法使用。认证错误。最后使用redhat openstack,终于顺利的安装成功，可以体验openstack了。使用redhat openstack安装非常简单，只需要注册一个redhat帐号，然后跟着文档一步一步来就可以了。等对openstack熟悉了，再尝试其他的安装方式。</description></item><item><title>fedora19中使用wps：No necessary symbol fonts</title><link>/posts/fedora19_use_the_wps_no_necessary_symbol_fonts/</link><pubDate>Wed, 21 Aug 2013 08:15:00 +0000</pubDate><guid>/posts/fedora19_use_the_wps_no_necessary_symbol_fonts/</guid><description>1下载如下内容文件名： symbol-fonts-1.2-1.noarch.rpmbox网盘下载链接： https://app.box.com/s/wmsdpn8x9qpcbcnekke1金山快盘下载链接： http://www.kuaipan.cn/file/id_19418406138675465.htm百度网盘下载链接： http://pan.baidu.com/share/link?shareid=3371036765&amp;amp;uk=505215462文件大小： 246 KB (252,171 字节)md5码： 4a7649c69e15983a6e69c31f38f64c62sha1码： 9d00e765169bba5f1351cf7f21a15ae3e26dcb082、把rpm包里面的文件解到mkdir /usr/share/fonts/symbol-fonts目录rpm2cpio ~/下载/symbol-fonts-1.2-1.noarch.rpm |cpio -idum然后执行fc-cache -fv再打开wps就没有问题了。参考地址：http://community.wps.cn/wiki/No_necessary_symbol_fontshttp://bbs.wps.cn/thread-22355435-1-1.html</description></item><item><title>fedora19系统t430s使用小红帽</title><link>/posts/fedora19_system_t430s_use_little_red_riding_hood/</link><pubDate>Tue, 20 Aug 2013 15:19:00 +0000</pubDate><guid>/posts/fedora19_system_t430s_use_little_red_riding_hood/</guid><description>执行以下命令，或者放入开机启动的脚本中即可：set -euid=$(xinput list | sed -n &amp;lsquo;/TPPS/2 IBM TrackPoint/s/.*id=([0-9]+).*/1/p&amp;rsquo;)emu=$(xinput list-props &amp;ldquo;$id&amp;rdquo; | sed -n &amp;lsquo;/Evdev Wheel Emulation (/s/.*(([0-9]+)).*/1/p&amp;rsquo;)but=$(xinput list-props &amp;ldquo;$id&amp;rdquo; | sed -n &amp;lsquo;/Evdev Wheel Emulation Button (/s/.*(([0-9]+)).*/1/p&amp;rsquo;)axs=$(xinput list-props &amp;ldquo;$id&amp;rdquo; | sed -n &amp;lsquo;/Evdev Wheel Emulation Axes (/s/.*(([0-9]+)).*/1/p&amp;rsquo;)xinput set-int-prop &amp;ldquo;$id&amp;rdquo; &amp;ldquo;$emu&amp;rdquo; 8 1xinput set-int-prop &amp;ldquo;$id&amp;rdquo; &amp;ldquo;$but&amp;rdquo; 8 2不同的型号可能值不同，可以通过工具gpointing-device-settings设置。</description></item><item><title>linux 下如何通过软件模拟按键[转-修改]</title><link>/posts/how_software_under_linux_analog_buttons_turn_-_modify/</link><pubDate>Wed, 14 Aug 2013 17:13:00 +0000</pubDate><guid>/posts/how_software_under_linux_analog_buttons_turn_-_modify/</guid><description>其实在/dev/input/by-path目录下面的文件名有表明是什么设备，键盘还是鼠标，可以通过文件名来确认键盘所对应的dev设别，然后对该文件进行处理。然后按以下的内容进行操作即可。linux 下如何通过软件模拟按键[转-修改]转自：http://zhgw01.blog.163.com/blog/static/10414812200992854628702/参考http://www.linuxdiyf.com/viewarticle.php?id=104221名词解释：scancode: 驱动对硬件的标记keycode： 上层应用程序所见的标记，跟硬件的标记不同， 一般为KEY_F1之类的宏一般驱动将scancode绑定到keycode对未绑定的scancode, 可以通过setkeycodes将将其绑定到未使用的keycode注： 有些按键会被解释成acpi event, 可以通过acpi_listen来监听，但不一定成功，目前还没具体了解模 拟按键是上层应用程序的行为， 所以不需要编译成模块，只需要想平常的应用程序那样编译就可以了， 不过它要包含&amp;lt;linux/input.h&amp;gt;这个文件， 同时要明确键盘对应的/dev/input/event[0-4]到底是哪个文件， 此外还需要以root权限来运行赖半仙注解：运行命令 cat /proc/bus/input/devices 在输出里面查找 xxx keyboard 对应的文件是/dev/input/event几。我开始想当然的以为键盘文件是event1,结果死人都调不出来，弄了很久最后从event0开始一个一个试，才发现我的手提电脑键盘文件对应的是event4。在我的电脑上运行命令 ls /dev/input/event* 发现有好多输入设备…………/dev/input/event0 /dev/input/event10 /dev/input/event2 /dev/input/event4 /dev/input/event6 /dev/input/event8/dev/input/event1 /dev/input/event11 /dev/input/event3 /dev/input/event5 /dev/input/event7 /dev/input/event9下面是 cat /proc/bus/input/devices 命令对应键盘文件的一段输出I: Bus=0011 Vendor=0001 Product=0001 Version=ab41N: Name=&amp;ldquo;AT Translated Set 2 keyboard&amp;quot;P: Phys=isa0060/serio0/input0S: Sysfs=/devices/platform/i8042/serio0/input/input4U: Uniq=H: Handlers=kbd event4 B: EV=120013B: KEY=8000 0 0 0 0 0 5007 2002000 380307c f800d001 feffffdf ffefffff ffffffff ffffffffB: MSC=10B: LED=7下面的程序是模拟按键NumLock，就是控制小键盘灯的那个按键，按下去（运行程序没有问题）后小键盘灯就会点亮或者熄灭。 #include &amp;lt;linux/input.h&amp;gt;#include &amp;lt;time.</description></item><item><title>rhel6.4/Fedora18/19上kerberos安装实验</title><link>/posts/kerberos_install_experimental_rhel64fedora1819/</link><pubDate>Wed, 31 Jul 2013 06:05:00 +0000</pubDate><guid>/posts/kerberos_install_experimental_rhel64fedora1819/</guid><description>在rhel6.4上安装kerberos实验，理解kerberos原理。安装步骤如下：安装krb，yum install krb5-*修改hosts文件：添加ip kerberos.example.com kerberos主要是修改主机名，修改host是为了找到地址在fedora18/19等系统还需要修改/etc/hostname，添加主机名：kerberos.example.com在rhel的系统中在 /etc/sysconfig/network文件中如果以上修改有误，可能会提示默认的krb配置基本就可以使用了，krb初始化kdb5_util create -r EXAMPLE.COM -s启动服务service krb5kdc start安装完毕，可以使用你的Krb服务了。测试方法：创建一个sample的principal，用来给服务程序使用kadmin.local:addprinc sample/kerberos.example.com@EXAMPLE.COMkadmin.local:ktadd -k /etc/krb5.keytab sample/kerberos.example.com@EXAMPLE.COM创建一个用户的principalkadmin.local:addprinc test1/kerberos.example.com@EXAMPLE.COM运行测试服务程序：sserver -p 8899 -s sample登录系统，执行kinit获取principal:kinit test1/kerberos.example.comklist查看相关内容sclient kerberos.example.com 8899 sample返回success，说明配置正确。其他测试程序1、sim_serversim_server -p 8888 -s samplesim_client -p 8888 -h kerberos.example.com -m hello2、uuserver修改/etc/services添加uu-sample 8888/tcp #uu-sample添加一个新的pricipal,使用该principal登录，然后执行uuserver用另外一个principal登录，然后执行uuclient kerberos.example.com message</description></item><item><title>install vmware 9.0.2 on fedora 19</title><link>/posts/install_vmware_902_on_fedora_19/</link><pubDate>Tue, 30 Jul 2013 13:20:00 +0000</pubDate><guid>/posts/install_vmware_902_on_fedora_19/</guid><description>不能用，需要修改vmware的驱动，在http://forums.fedoraforum.org/showthread.php?t=292907找到了解决办法，内容如下。Re: vmware player 5.0.2 onf fc19 (3.10.3-300.fc19.x86_64) - who got it running?I have 5.0.2 running. To get it running at all, I first had to do a tweak to the /usr/bin/vmplayer file to allow VMPlayer to run in Fedora 19.1. Open /usr/bin/vmplayer in nano or other text editor of your choice, using sudo or su.2. Look for the lines that read as follows:Code:3. Add the following after the above lines:Code:4. Save the file.</description></item><item><title>[zz]RHEL 5/6 差异：时间处理机制</title><link>/posts/zz_rhel_56_difference_time_handling_mechanism/</link><pubDate>Mon, 29 Jul 2013 17:13:00 +0000</pubDate><guid>/posts/zz_rhel_56_difference_time_handling_mechanism/</guid><description>when you use different linux system,you will find the time&amp;rsquo;s different between the systems,here is the reason.RHEL 5/6 差异：时间处理机制06.29.2012, 系统服务 , by Roger.RHEL 5/6 差异：时间处理机制作者：Roger简介本文介绍了在 RHEL5 和 RHEL 6 两个版本系统中，对待时间的差异。目的在于帮助我们了解系统，应对OS升级的改动。概述RHEL 5/6 时间机制差异类别RHEL 5RHEL 6建议Anaconda 参数timezone &amp;ndash;utc修改/etc/sysconfig/clock修改/etc/adjtime对用户透明，不用调整开机初始化脚本，硬件时钟到系统时钟/etc/rc.d/rc.sysinit传参调用hwclock内核直接读取rtc_cmos获取时间/etc/sysconfig/clock需要区分关机脚本，系统时钟到硬件时钟/etc/rc.d/init.d/halt传参数调用hwclock/etc/rc.d/init.d/halt直接调用hwclock/etc/sysconfig/clock需要区分NTP软件包一个包：ntp-4.2.2p1-9.el5_3.2三个包：ntp-4.2.4p8-2.el6.centos.i686ntp-perl-4.2.4p8-2.el6.centos.i686ntpdate-4.2.4p8-2.el6.centos.i686RHEL 6 把 RHEL 5 一个包拆成了三个RHEL 6 建议三个包都安装ntpd启动脚本一个脚本：/etc/rc.d/init.d/ntpd两个脚本：/etc/rc.d/init.d/ntpd/etc/rc.d/init.d/ntpdateRHEL 6 中添加了ntpdate启动脚本，相当于额外多了一个服务，需要注意RHEL 5 与 RHEL 6 中，时间这块，外围软件包改动并不大，例如hwclock，NTP。改动比较大的是：Anaconda安装系统时，timezone &amp;ndash;utc的处理方式。开机读取硬件时钟的机制。关机写入硬件时钟的机制。linux 时间存储 原理分析首先需要了解的概念：硬件时钟系统时钟其次，BIOS里硬件时钟存的仅是一个UNIX时间戳。这个时间戳，有UTC时钟和LOCAL时钟两钟存法。UTC时间LOCAL时间（本地时间）注意点：我们所说的system clock use UTC (timezone &amp;ndash;utc) 实际上就是指BIOS里的时钟存法。与系统的“时区”没有关系。这点不要混淆。这里举一个你常见的例子：笔记本双系统，win+linux，如果linux使用了UTC时间，那么两个系统就会差8小时。原因：Unix规范里BIOS时钟存UTC时间戳，但windows改成了只支持存LOCAL时间戳（就是你墙上的时间），而linux两个格式都支持。这时，如果你linux使用了UTC时间，就会把BIOS的时间戳当作UTC时间，而你的windows把BIOS时间戳当作LOCAL时间。所以无论你怎么调，两个系统时间都不会一致。hwclock说到linux下的时钟，一定不能忽略hwclock，硬件时钟和系统时钟的互写就全靠它了。后续我们详解hwclock的工作机制。推荐看 man clock。开机对时钟的处理我们电脑关机状态时，硬件上的晶振会持续保存一个时间，这个时间就是硬件时钟。进入BIOS便可以看到。开机后，系统将硬件时钟读入系统，然后开始维持时间的增长。硬件时钟仅开机读取一次，由于进入了OS，我们有很多途径让时钟更准确，比如NTP等，这时的硬件时钟对我们是没有用的。关机对时钟的处理要关机了，系统会把时间写入硬件时钟，相当于更新硬件时钟。RHEL 5/6 都是/etc/rc.d/init.d/halt调用hwclock来写入硬件时钟，细节上略有不同，但都是做一样的事情。hwclockRHEL 5/6 中hwclock机制并没有变化：这里需要注意的是：hwclock维护一个文件，/etc/adjtime，用来确定硬件时钟是UTC还是LOCAL。hwclock原理分析：我们直接执行hwclock，就是读取硬件时钟。01[root@centos6 install]# strace -e trace=open hwclock02open(&amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY) = 303open(&amp;quot;/lib/libaudit.</description></item><item><title>Linux 下的文件加密</title><link>/posts/file_encryption_under_linux/</link><pubDate>Tue, 14 May 2013 16:23:00 +0000</pubDate><guid>/posts/file_encryption_under_linux/</guid><description>Linux 下的文件加密2009-06-26 xiao H Posted in 系统管理 以前我在blog 写过两篇关于linux 下目录加密的文章用Cryptkeeper和EncFS 完成目录加密和用Cryptsetup LUKS 加密目录，今天我想说说文件加密，先说简单的用VIM 加密文本文件：vim 加密使用 -x 参数，即vim -x myfile然后会提示让你输入两次密码，这样就算给你的文件加上密码了，下次要看文件用VIM 打开会要求输入密码，输入错误密码则会得到一堆乱码，用其他编辑器打开也是一堆乱码。要清除密码只要在正确打开文件后用 “:X” 指令，然后给一个空密码就行。当然vim 加密还是有很多局限的，算法弱并且中间会有交换文件，交换文件是不加密的，虽然有”-n” 参数可以不使用交换文件但不用交换文件让我不得不时刻记得要存盘。vim加密的算法很弱所以要更好的保护你的文件你需要专业的加密工具，如openssl，gpg。对称加密：a.用openssl 加密文件:加密openssl enc -aes-128-ecb -e -in myfile-out myfile-aes解密openssl enc -aes-128-ecb -d -in myfile-aes -out myfileenc 后面跟你具体的加密算法-aes-128-ecb 所使用的算法-e/-d 加密/解密-in 要被加/解密的文件-out 被加/解密后的文件b.用GnuPG加密文件关于GnuPG 之前有另一篇博文 我的GnuPG 使用笔记有关于GnuPG 更多的内容这里只说一下加密。加密gpg -c myfile #输入密码后会产生一个myfile.gpg 文件，这就是加密后的文件。解密gpg -o myfile -d myfile.gpg #解密文件myfile.gpg 并将解密后的文件输出为myfile。非对称加密前面说的都是对称加密，现在说一下非对称加密，这个应该说是我们目前使用的最安全的方法了。加密gpg -ea -r &amp;ldquo;lily.yu&amp;rdquo; hello.txt #使用lily.yu 这个密钥加密hello.txt，你会得到一个加密后的文件hello.txt.asc。-a 表示已ASCII 输出.解密gpg -o new.txt -d hello.txt.asc #解密hello.txt.asc 文件并输出到 new.</description></item><item><title>网络流量数据</title><link>/posts/network_traffic_data/</link><pubDate>Mon, 21 Jan 2013 05:10:00 +0000</pubDate><guid>/posts/network_traffic_data/</guid><description>2012 年1月1日，铁道部网络订票上线。刚上线时，12306网站的同时在线访问人数高达500多万，对火车票巨大的需求造成刚上线的网站几度瘫痪。当时，就有 几款抢票浏览器和软件出现。但由于12306网站刚刚诞生，并没有太多人注意到这类软件，也并没有企业大规模宣传和推广抢票插件。但今年春运开始后，火车 票重新回到人们视野之中。一些软件公司也开始在浏览器的抢票功能上大做文章。不过，12306每年数百万的订单并非网站承受的极限。 2012年11月11日，阿里巴巴旗下淘宝和天猫“双十一”购物节上，在这个被称为有史以来最大规模的“交易攻击”上，1分钟内，超过1000万人涌入天 猫，带来了上亿的PV，网站交易系统的订单创建峰值达到了惊人的 1秒45万笔订单，其瞬间并发量也创了历史纪录。24小时内有2.13亿消费者上天猫网站，整体系统经受了最高每秒2.1Tb的网络流量。在这样规模冲击 下，天猫与支付宝系统均未出现宕机等事故，保障了交易进程的完整与可靠。阿里巴巴集团技术共享平台负责人刘振飞说，阿里巴巴很早就开始相关的技术筹备，约有3000多位工程师参与，硬件上有10多万台服务器。罗马不是一日建成的，事实上，在2010和2011年的购物节上，网银宕机，网页刷新缓慢时有发生。有业界人士认为，比起9岁的淘宝天猫，刚刚1岁的12306网站前端和架构都有优化的空间。但也有分析认为，淘宝与12306是不同的平台。人们在淘宝平台抢购，商品相对分散，而火车票相对集中在一些主干地区。</description></item><item><title>[zz]俄罗斯推出新款Linux桌面：ROSA</title><link>/posts/zz_russia_launch_new_linux_desktop_rosa/</link><pubDate>Tue, 15 Jan 2013 12:18:00 +0000</pubDate><guid>/posts/zz_russia_launch_new_linux_desktop_rosa/</guid><description>4月12日，位于俄罗斯联邦首府莫斯科市的技术开发团体ROSA推出一款新的GNU/Linux桌面（目前还是Beta测试版），名为“ROSA Linux”发行版，吸引了不少人的目光。令人感到惊奇是，ROSA发行版的支持年限是5年，是所谓的“LTS版本”。下面是其截图：从上图可见，ROSA的桌面背景很凝重，具有俄罗斯的传统特色。同时，我们可以清楚地看出，ROSA发行版所绑定的办公套件是LibreOffice软件包，但是，其模块的图标与我们常见的不一样。毫无疑问，ROSA采用了最新款式的GNOME3.4。另一方面，ROSA是基于源自法国的Mandriva版本开发的KDE桌面。2010年12月28日，俄国总理普京（Vladimir Putin ）已经签署政府命令（实际12月17日已经签署）要求俄罗斯联邦各级政府机关及相关部门按照既定日程表全面采用自由软件包括GNU/Linux。该命令共计有25项内容，其中第5项要求俄罗斯通讯部准备一份针对典型问题的基本自由软件解决方案包，以供联邦各执行机关部门使用。第20项要求各政府部门使用自由软件（free software ）的具体计划应包括其下属各级机构在内。第25项要求在2015年第三季度全面完成该项转移计划。当今，在俄罗斯境内，由Linux所代表自由软件扬终于眉吐气，可神气了。特别是，自由办公套件LibreOffice大行其道，无人非议。在这种社会大背景下，作为自由软件GNU/Linux的发行版ROSA终于诞生了。祝贺她（ROSA）的诞生！3月1日，英国“馅饼”小电脑发布的第二天，一位俄罗斯朋友急切地在网络上四处询问：他这样写到：Дайтедве，Addme twice!I need 20 these computers! Where to pay &amp;amp; Where can I get it?it&amp;rsquo;s coooool !老外往往喜欢用一个“Cooooooooooool”字来表示“非常非常非常的酷”。在此，我希望再说一遍：在俄罗斯境内，GNU/Linux（自由软件）已经被社会大众所接受，不像在我们国内，自由软件GNU/Linux让人感到很别扭、很难受。</description></item><item><title>[zz]Linus大神又怒了 我为什么要说“又”？</title><link>/posts/zz_linus_great_god_angry_why_i_say_the_quotandquot/</link><pubDate>Wed, 26 Dec 2012 11:32:00 +0000</pubDate><guid>/posts/zz_linus_great_god_angry_why_i_say_the_quotandquot/</guid><description>Linus大神实乃性情中人，口无遮拦。继称OpenBSD开发者是一帮自慰的猴子、 调侃digg用户是“手淫的海象”、以及 对 Nvidia 比中指爆粗 后，又有不懂事的人惹大神发怒了。这回是由在于Linus认为Mauro违反了内核维护的基本原则。他的原话很好理解：Linus大神实乃性情中人，口无遮拦。继称OpenBSD开发者是一帮自慰的猴子、 调侃digg用户是“手淫的海象”、以及 对 Nvidia 比中指爆粗 后，又有不懂事的人惹大神发怒了。闭上你的臭嘴，Mauro！这明显是一个bug，Kernel中的bug！你做了多长时间的维护人员了，为什么还不明白Kernel维护的第一原则？如果修改会导致用户程序的破坏，那问题一定是在Kernel上！永远不可以归咎用户程序的责任，学会这点真的很难吗？更糟糕的是，commit f0ed2ce840b3虽然并没有破坏程序，但它完全是废话。……永远不可以破坏USERSPACE！或许有人觉得Linus的批评太过严厉，但这也正反映出他对Kernel设计、维护原则的坚持，如果没有这种信念，相信Linux很难有今天的地位。希望各位程序员引以为戒！http://thread.gmane.org/gmane.linux.kernel/1413835/focus=1414106From: Linus Torvalds &amp;lt;torvalds linux-foundation.org&amp;gt; Subject: Re: [Regression w/ patch] Media commit causes user space to misbahave (was: Re: Linux 3.8-rc1) Newsgroups: gmane.linux.kernel Date: 2012-12-23 17:36:15 GMT (1 day, 17 hours and 45 minutes ago) On Sun, Dec 23, 2012 at 6:08 AM, Mauro Carvalho Chehab &amp;lt;mchehab redhat.com&amp;gt; wrote: &amp;gt; &amp;gt; Are you saying that pulseaudio is entering on some weird loop if the &amp;gt; returned value is not -EINVAL?</description></item><item><title>fedora-Rawhide</title><link>/posts/fedora-rawhide/</link><pubDate>Tue, 18 Dec 2012 06:17:00 +0000</pubDate><guid>/posts/fedora-rawhide/</guid><description>Rawhide is the name given to the current development head of Fedora. It consists of a package repository called &amp;ldquo;rawhide&amp;rdquo; and contains the latest build of all Fedora packages updated on a daily basis. Nightly builds are also available during the early portion of the Fedora Release Life Cycle.Rawhide is the name given to the current development head of Fedora. It consists of a package repository called &amp;ldquo;rawhide&amp;rdquo; and contains the latest build of all Fedora packages updated on a daily basis.</description></item><item><title>【zz】红帽RHEL7新功能前瞻</title><link>/posts/zz_preview_new_features_of_red_hat_rhel7/</link><pubDate>Sat, 01 Dec 2012 09:17:00 +0000</pubDate><guid>/posts/zz_preview_new_features_of_red_hat_rhel7/</guid><description>http://www.serverwatch.com/server-trends/the-future-of-red-hat-enterprise-linux-7.htmlhttp://www.linuxdiyf.com/viewarticle.php?id=298912来源：51CTO差不多从2011年8月以来，红帽就一直在暗示有关红帽企业级Linux 7（RHEL 7）的各种情况。在红帽最近于波士顿举行的峰会活动（Summit Event）期间，这家Linux开发商极其详细地透露了下一代Linux会提供什么样的功能特性。RHEL 6在2010年11月正式发布。由于红帽企业级Linux大概每隔两年会有一次重大更新，RHEL 7定于2013年某个时候发布。红帽公司Linux工程副总裁Tim Burke强调，除了集成开发工具方面的改进外，RHEL 7的几个重要主题还包括数据中心运营效率、虚拟化和云计算等方面的改进。Burke说：“目前的状况是，我们现已完成了产品规划工作；会在2013年上半年发布RHEL7公共测试版。”不过，用户没必要等到2013年。Burke证实，RHEL 7的许多新的功能特性已出现在最近发布的Fedora 17中，还有一些新的RHEL 7功能特性会出现在定于今年年底之前发布的Fedora 18中。有望出现在版本7中的新的功能特性包括：全面支持目前RHEL 6中的几项预览技术；Linux容器虚拟化（Container virtualization）；新的SELinux及安全方面的其他改进。至于存储方面，逻辑卷管理器（LVM）快照在RHEL 7中也将得到全面支持，之前它被证实为是RHEL 6中的一项预览技术。LVM还将因LVM自动精简配置功能的推出而得到提升。只有数据被写入时，精简逻辑卷才耗用卷组空间——数据被丢弃后，随后就会返回该空间。从文件系统的角度来看，RHEL 7用户将来可以在ext4、xfs和Btrfs之间进行选择。Btrfs目前同样处于技术预览阶段，提供了新的回退和快照功能，而Ext4（目前Linux的默认文件系统）不具备这些功能。用户界面RHEL 7还将采用一种新的用户界面。红帽开发人员Denise Duman解释，新的界面采用了中心辐射式（hub and spoke）模型。所以现在有三个主要的中心（hub），再也不需要进行大量的配置以便启动和运行起来，而不是有14个屏幕。另外，安装系统所需的内存占用空间已大幅缩减，所需的最小内存空间是512 MB；这样一来，就能支持比较小的访客系统。在桌面端，RHEL 7还提供了GNOME 3用户体验，这对RHEL用户来说将是全新的体验。红帽的开发人员Jonathan Bandford说：“Gnome 3是一个巨大的改变，我们在这方面已作了一些激动人心的改进。”原文：The Future of Red Hat Enterprise Linux 7</description></item><item><title>【zz】Linux终端下的ASCII艺术</title><link>/posts/ascii_art_zz_under_linux_terminal/</link><pubDate>Wed, 21 Nov 2012 00:52:00 +0000</pubDate><guid>/posts/ascii_art_zz_under_linux_terminal/</guid><description>Linux终端下的ASCII艺术作者：chen-xiao | 出处：博客园 | 2012/5/16 17:01:02 | 阅读79次（原文请访问我的个人博客 http://chen-xiao.com/?p=26 ）在电脑前工作的人们，相信每天对着黑糊糊的代码屏幕也会有感到心烦意躁的时候。这个时候，我们需要来点某些调剂，给无聊的代码工作加点料。Linux下有许多复活节彩蛋类似的程序，但大部分是在GUI下面工作的。对于没有GUI的我们来说怎么办？那当然是可爱的ASCII类程序啦1. banner xxx，将字符转化成*号表示的大写字符，效果如下2. figlet xxx，这个和banner类似，不过转化出来的是空心的大写字，效果如下3. cowsay xxx，无聊人做出来的牛比东东，把你输入的字符当作一头牛的话说出来，这就是所谓的吹牛皮？当然cowsay不仅仅只有这一个动物而已，通过-f参数指定不同的形状，还可以通过-e设定眼睛字符，通过-T设定舌头字符等等。这里有一条牛掰的命令，直接打印出所有的形状，然后用less定义翻页来观看cowsay -l | grep -v “^Cow” | sed -e “s% %n%g” | sed -e “s%(.*)%cowsay -f 1 Now I am a 1%” | sh | less4. sl，你没看错，我也没打错，对了，不是ls，而是sl。估计是哪位代码负责人对团队内成员老敲错命令的惩罚而作出来的一款程序。如果你安装过并不幸的敲错了列举文件的命令，那么在接下来的一分钟内就什么都干不了，只能眼睁睁的看着一辆火车在你屏幕上驶过。。。（不过好像最新的版本已经能Ctrl+C取消了）相关图片如下，还有更变态的sl-h你也可以试试5. jp2a，这是一个把jpg图像文件转化为ASCII并显示出来的软件，只能支持jpg。。。不过在linux下转换图片格式也容易6. bb，如果你知道aalib，你就应该不会错过这个牛鼻到变态的玩意儿。这款程序是对aalib里面所有技术的一个展示，它想要向人们倾诉：没有什么是不能由ASCII来完成的7. mplayer，提到mplayer，你不可能不知道。但是说到它在ASCII方面的牛比之处，估计你会吓一跳。让我们先来看一下它所支持的视频输出格式看到那个aalib了没有，这就是上面介绍的bb demo所使用的ASCII图像库。使用这种输出方式，你就能通过跳动的ASCII来欣赏各种视频文件了，只要你敢，在公共场合看爱情动作片都没人能发现。当然，首先你自己的想象力也必须得达到一定级别才行。看下面的youtube视频就是用aalib播放动画文件的效果：</description></item><item><title>fedora18试用</title><link>/posts/fedora18_trial/</link><pubDate>Mon, 19 Nov 2012 15:01:00 +0000</pubDate><guid>/posts/fedora18_trial/</guid><description>fedora18马上就要beta了，今天试用了一下alpha，果然bug多啊</description></item><item><title>fedora18-new features-syscall filters</title><link>/posts/fedora18-new_features-syscall_filters/</link><pubDate>Fri, 16 Nov 2012 06:29:00 +0000</pubDate><guid>/posts/fedora18-new_features-syscall_filters/</guid><description>看fedora18的新特性列表，发现了syscall filters功能，感觉挺有意思，然后用空尝试一下。Syscall FiltersSummarySyscall filtering is a security mechanism that allows applications to define which syscalls they should be allowed to execute.OwnerName: Cole RobinsonEmail: crobinso@redhat.comName: Paul MooreEmail: pmoore@redhat.comCurrent statusTargeted release: Fedora 18Last updated: August 16, 2012Percentage of completion: 100%Detailed DescriptionThe syscall filtering concept, and the motivation behind it, is fairly simple; the Linux Kernel supports a very large number of system calls (syscalls), over 300 on x86_64 for the 64 bit implementations alone, with applications typically requiring only a very small subset of these syscalls to function normally.</description></item></channel></rss>