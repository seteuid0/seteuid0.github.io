<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>php on seteuid0's blog</title><link>/tags/php/</link><description>Recent content in php on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Fri, 10 Jan 2014 09:54:37 +0000</lastBuildDate><atom:link href="/tags/php/index.xml" rel="self" type="application/rss+xml"/><item><title>编码版b374k实现分析</title><link>/posts/%e7%bc%96%e7%a0%81%e7%89%88b374k%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</link><pubDate>Fri, 10 Jan 2014 09:54:37 +0000</pubDate><guid>/posts/%e7%bc%96%e7%a0%81%e7%89%88b374k%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</guid><description>实验PHP+SELINUX的时候，使用B374k，发现PHP文件的上下文意外的发生了变化，Inode号却没有发生变化，审计日志里也找不到relabel相关信息，就想一探究竟。 看代码发现上下文变化的这个版本是代码进行了编码处理的，从google code里找到的那些没有编码处理的版本上下文不会发生变化，看来只能对解码处理。 第一层使用了简单的“.&amp;ldquo;符号把字符串进行了分割，将$b374k=@create_function('$x',&amp;lsquo;ev&amp;rsquo;.&amp;lsquo;al&amp;rsquo;.'(gz'.&amp;lsquo;inf&amp;rsquo;.&amp;lsquo;late&amp;rsquo;.'(bas'.&amp;lsquo;e64&amp;rsquo;.'_de'.&amp;lsquo;co&amp;rsquo;.&amp;lsquo;de($x)));');处理后就可以看到(gzinflate(base64_decode($x)))；使用这个函数把后面的解码就可以得到解密后的代码。将代码格式化处理下，可以看到前半部分还是编码后的代码，后半部分有一些功能代码。
eval(gzinflate(base64_decode($x7774cacf))); rebirth(); eval(gzinflate(base64_decode(hate($xc3a649b2,$xec8e9aa2))));
同样，去掉eval，通过gzinflate(base64_decode($x7774cacf))解码，得到上面的功能代码，将解码后的内容格式化可以得到
里面是基础的编码、解码、生成随机数功能函数，可以注意到里面的rebirth函数，该函数将该PHP文件重新编码后替换当前的PHP文件。而随后的代码便调用了rebirth()函数，实现了这个webshell的rebirth。 而eval(gzinflate(base64_decode(hate($xc3a649b2,$xec8e9aa2))));就是执行本次请求的功能。可以找一个文件将该解码后的内容拷贝进去进行验证，功能与预期一致。 目前知道了上下文改变是由于用新生成的文件替换了之前的老文件，但是为什么inode号会保持一致？对该文件进行审计,将日志处理后可以看到。
syscall=4 ppid=2563 pid=2617 syscall=2 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13403 syscall=21 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13403 syscall=87 ppid=2563 pid=13403 syscall=82 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13404 syscall=2 ppid=2563 pid=13405 syscall=2 ppid=2563 pid=13405 syscall=2 ppid=2563 pid=13404 syscall=87 ppid=2563 pid=13405 syscall=82 ppid=2563 pid=13405 syscall=87 ppid=2563 pid=13404 syscall=82 ppid=2563 pid=13404 syscall=2 ppid=2563 pid=13406 syscall=2 ppid=2563 pid=13406 syscall=87 ppid=2563 pid=13406 syscall=82 ppid=2563 pid=13406 syscall=2 ppid=2563 pid=13407 syscall=2 ppid=2563 pid=13407 syscall=87 ppid=2563 pid=13407 syscall=82 ppid=2563 pid=13407</description></item><item><title>开发PHP扩展（extension)或模块(module)简介</title><link>/posts/%e5%bc%80%e5%8f%91php%e6%89%a9%e5%b1%95%ef%bc%88extension%e6%88%96%e6%a8%a1%e5%9d%97module%e7%ae%80%e4%bb%8b/</link><pubDate>Tue, 31 Dec 2013 02:17:57 +0000</pubDate><guid>/posts/%e5%bc%80%e5%8f%91php%e6%89%a9%e5%b1%95%ef%bc%88extension%e6%88%96%e6%a8%a1%e5%9d%97module%e7%ae%80%e4%bb%8b/</guid><description>PHP的插件分为两种:PHP extensions 和Zend Extensions.其中PHP extensions 被当作modules，而Zend extensions被当作extensions.这两个的主要差异在于Engine中注册了不同的钩子。（当然在插件代码编写和使用的配置文件中也存在一定差异，这是后话）
环境搭建 首先需要搭建基础的php环境，我采用Fedora自带的库，然后下载系统对应的rpm源码包编译后使用，这样就可以保证和系统自带版本一致。
yundownload &amp;ndash;source php rpm -ivh php-*.src.rpm Cd ~/rpmbuild/SPEC/ rpmbuild -ba php.spec
这样就有了php的源码环境。
代码编写 开发PHP插件可以使用源码中的ext_skel快速的生成框架代码，只需要简单的修改框架代码就可以生成一个可用的PHP插件。 最简单的使用模式就是 Php_src/ext/ext_skel &amp;ndash;extname=module 执行后生成了由你制定的module关联的几个文件，module.c和php_module.h,以及config.m4工程配置文件 对应的修改这几个文件就可以了。 如果是要开发zend_extension则记得添加如下内容
/* This is a Zend extension */ #ifndef ZEND_EXT_API #define ZEND_EXT_API ZEND_DLEXPORT #endif ZEND_EXTENSION(); ZEND_DLEXPORT zend_extension zend_extension_entry = {
编译测试 编译测试： 执行phpize生成configure文件 然后执行./configure和make 将module目录下的so文件拷贝到你要的目录，然后配置一个php配置文件 添加extension=path/module_name.so,如果是zend extensions，则是 Zend_extension=path/module_name.so 这样，就可以开始你的调试之旅了。</description></item></channel></rss>