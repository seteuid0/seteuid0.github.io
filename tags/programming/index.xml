<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on seteuid0's blog</title><link>/tags/programming/</link><description>Recent content in programming on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Tue, 11 Mar 2014 13:22:58 +0000</lastBuildDate><atom:link href="/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux下线程pthread实现suspend、resume的一种方式</title><link>/posts/linux_pthread_suspend_resume/</link><pubDate>Tue, 11 Mar 2014 13:22:58 +0000</pubDate><guid>/posts/linux_pthread_suspend_resume/</guid><description>Linux下线程pthread没有实现suspend,resume的相关功能，这几天项目需要，自己就使用pthread_cond_wait实现了下，把主要代码逻辑如下，贴出来供大家参考。 功能如下。 主线程监听用户消息，子线程完成实际任务。主线程需要依据用户输入控制工作子线程的暂停（suspend）和继续运行（resume）。 使用CTRL+C控制暂停、继续运行。 使用CTRL+\使程序退出，主线程先cancel，然后自己退出。 代码如下：
#include &amp;lt;pthread.h&amp;gt; #include &amp;lt;signal.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; typedef enum \_RUN\_STATUS{ STATUS\_RUNNING = 0, STATUS\_PAUSE, }RUN\_STATUS; sigset\_t mask; RUN\_STATUS run\_status; pthread\_mutex\_t lock = PTHREAD\_MUTEX\_INITIALIZER; pthread\_cond\_t waitloc = PTHREAD\_COND\_INITIALIZER; void cleanup\_handler(void\*arg) { printf(&amp;quot;child thread cleanup\\n&amp;quot;); pthread\_mutex\_unlock(&amp;amp;lock); } void \* thread\_func(void\*arg) { int err, signo; pthread\_cleanup\_push(cleanup\_handler, NULL); for(;;){ pthread\_mutex\_lock(&amp;amp;lock); if(run\_status == STATUS\_RUNNING){ pthread\_mutex\_unlock(&amp;amp;lock); printf(&amp;quot;child pthread task running-&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;\\n&amp;quot;); sleep(1); }else{ while(run\_status != STATUS\_RUNNING){ pthread\_cond\_wait(&amp;amp;waitloc, &amp;amp;lock); printf(&amp;quot;running again\\n&amp;quot;); } pthread\_mutex\_unlock(&amp;amp;lock); } } pthread\_cleanup\_pop(0); return 0; } int main() { int ret; run\_status = STATUS\_RUNNING; sigset\_t oldmask; pthread\_t tid; int err, signo; sigemptyset(&amp;amp;mask); sigaddset(&amp;amp;mask, SIGINT); sigaddset(&amp;amp;mask, SIGQUIT); pthread\_t tid\_self = pthread\_self(); if((ret = pthread\_sigmask(SIG\_BLOCK, &amp;amp;mask, &amp;amp;oldmask)) !</description></item><item><title>file not recognized: File truncated错误解决办法</title><link>/posts/file-not-recognized-file-truncated%e9%94%99%e8%af%af%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95/</link><pubDate>Mon, 03 Mar 2014 02:30:17 +0000</pubDate><guid>/posts/file-not-recognized-file-truncated%e9%94%99%e8%af%af%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95/</guid><description>使用rpmbuild重新编译clamav，遇到了：file not recognized: File truncated。感觉不像时程序代码问题，找到以下解决办法：
when the compilation line looks like:c++ -Dmylib\_EXPORTS -Wall -Werror -g -fPIC -I/home/user/dev/mygit/build -I/home/user/dev/mygit/src -o CMakeFiles/mylib.dir/MyCppClass.cpp.o -c /home/user/dev/mygit/src/MyCppClass.cppcomes from the fact that, as stated, the generated object (.o) file is empty (or just truncated). A quick look can also tell it:ls -l CMakeFiles/mylib.dir/Now, when the issue remains even though you re-run the compilation line, it may come from the fact that the object (.o) file is empty/truncated within the compilation cache (ccache) itself.</description></item><item><title>linux编程中由_GNU_SOURCE未声明所导致的问题</title><link>/posts/linux%e7%bc%96%e7%a8%8b%e4%b8%ad%e7%94%b1_gnu_source%e6%9c%aa%e5%a3%b0%e6%98%8e%e6%89%80%e5%af%bc%e8%87%b4%e7%9a%84%e9%97%ae%e9%a2%98/</link><pubDate>Fri, 21 Feb 2014 08:54:45 +0000</pubDate><guid>/posts/linux%e7%bc%96%e7%a8%8b%e4%b8%ad%e7%94%b1_gnu_source%e6%9c%aa%e5%a3%b0%e6%98%8e%e6%89%80%e5%af%bc%e8%87%b4%e7%9a%84%e9%97%ae%e9%a2%98/</guid><description>今天在写程序的时候遇到了如下的错误，核对了半天，感觉头文件已经包含，后来发现是缺少了#define _GNU_SOURCE
gcc example.c -o example example.c: 在函数‘call’中: example.c:58:17: 错误：数组元素的类型不完全 struct mmsghdr msgs[VLEN]; example.c: In function &amp;lsquo;call&amp;rsquo;: example.c:59:17: error: array type has incomplete element type struct mmsghdr msgs[VLEN];
查看/usr/include下面的定义发现原因。 由于mmsghdr是recvmmsg所需要的，而recvmmsg只在linux中存在，所以在sys/socket.h中有如下定义：
#ifdef __USE_GNU /* For `recvmmsg' and `sendmmsg'. */ struct mmsghdr { struct msghdr msg_hdr; /* Actual message header. */ unsigned int msg_len; /* Number of received or sent bytes for the entry. */ }; #endif
在features.h文件中可以看到</description></item><item><title>编码版b374k实现分析</title><link>/posts/%e7%bc%96%e7%a0%81%e7%89%88b374k%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</link><pubDate>Fri, 10 Jan 2014 09:54:37 +0000</pubDate><guid>/posts/%e7%bc%96%e7%a0%81%e7%89%88b374k%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</guid><description>实验PHP+SELINUX的时候，使用B374k，发现PHP文件的上下文意外的发生了变化，Inode号却没有发生变化，审计日志里也找不到relabel相关信息，就想一探究竟。 看代码发现上下文变化的这个版本是代码进行了编码处理的，从google code里找到的那些没有编码处理的版本上下文不会发生变化，看来只能对解码处理。 第一层使用了简单的“.&amp;ldquo;符号把字符串进行了分割，将$b374k=@create_function('$x',&amp;lsquo;ev&amp;rsquo;.&amp;lsquo;al&amp;rsquo;.'(gz'.&amp;lsquo;inf&amp;rsquo;.&amp;lsquo;late&amp;rsquo;.'(bas'.&amp;lsquo;e64&amp;rsquo;.'_de'.&amp;lsquo;co&amp;rsquo;.&amp;lsquo;de($x)));');处理后就可以看到(gzinflate(base64_decode($x)))；使用这个函数把后面的解码就可以得到解密后的代码。将代码格式化处理下，可以看到前半部分还是编码后的代码，后半部分有一些功能代码。
eval(gzinflate(base64_decode($x7774cacf))); rebirth(); eval(gzinflate(base64_decode(hate($xc3a649b2,$xec8e9aa2))));
同样，去掉eval，通过gzinflate(base64_decode($x7774cacf))解码，得到上面的功能代码，将解码后的内容格式化可以得到
里面是基础的编码、解码、生成随机数功能函数，可以注意到里面的rebirth函数，该函数将该PHP文件重新编码后替换当前的PHP文件。而随后的代码便调用了rebirth()函数，实现了这个webshell的rebirth。 而eval(gzinflate(base64_decode(hate($xc3a649b2,$xec8e9aa2))));就是执行本次请求的功能。可以找一个文件将该解码后的内容拷贝进去进行验证，功能与预期一致。 目前知道了上下文改变是由于用新生成的文件替换了之前的老文件，但是为什么inode号会保持一致？对该文件进行审计,将日志处理后可以看到。
syscall=4 ppid=2563 pid=2617 syscall=2 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13403 syscall=21 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13403 syscall=87 ppid=2563 pid=13403 syscall=82 ppid=2563 pid=13403 syscall=2 ppid=2563 pid=13404 syscall=2 ppid=2563 pid=13405 syscall=2 ppid=2563 pid=13405 syscall=2 ppid=2563 pid=13404 syscall=87 ppid=2563 pid=13405 syscall=82 ppid=2563 pid=13405 syscall=87 ppid=2563 pid=13404 syscall=82 ppid=2563 pid=13404 syscall=2 ppid=2563 pid=13406 syscall=2 ppid=2563 pid=13406 syscall=87 ppid=2563 pid=13406 syscall=82 ppid=2563 pid=13406 syscall=2 ppid=2563 pid=13407 syscall=2 ppid=2563 pid=13407 syscall=87 ppid=2563 pid=13407 syscall=82 ppid=2563 pid=13407</description></item><item><title>开发PHP扩展（extension)或模块(module)简介</title><link>/posts/%e5%bc%80%e5%8f%91php%e6%89%a9%e5%b1%95%ef%bc%88extension%e6%88%96%e6%a8%a1%e5%9d%97module%e7%ae%80%e4%bb%8b/</link><pubDate>Tue, 31 Dec 2013 02:17:57 +0000</pubDate><guid>/posts/%e5%bc%80%e5%8f%91php%e6%89%a9%e5%b1%95%ef%bc%88extension%e6%88%96%e6%a8%a1%e5%9d%97module%e7%ae%80%e4%bb%8b/</guid><description>PHP的插件分为两种:PHP extensions 和Zend Extensions.其中PHP extensions 被当作modules，而Zend extensions被当作extensions.这两个的主要差异在于Engine中注册了不同的钩子。（当然在插件代码编写和使用的配置文件中也存在一定差异，这是后话）
环境搭建 首先需要搭建基础的php环境，我采用Fedora自带的库，然后下载系统对应的rpm源码包编译后使用，这样就可以保证和系统自带版本一致。
yundownload &amp;ndash;source php rpm -ivh php-*.src.rpm Cd ~/rpmbuild/SPEC/ rpmbuild -ba php.spec
这样就有了php的源码环境。
代码编写 开发PHP插件可以使用源码中的ext_skel快速的生成框架代码，只需要简单的修改框架代码就可以生成一个可用的PHP插件。 最简单的使用模式就是 Php_src/ext/ext_skel &amp;ndash;extname=module 执行后生成了由你制定的module关联的几个文件，module.c和php_module.h,以及config.m4工程配置文件 对应的修改这几个文件就可以了。 如果是要开发zend_extension则记得添加如下内容
/* This is a Zend extension */ #ifndef ZEND_EXT_API #define ZEND_EXT_API ZEND_DLEXPORT #endif ZEND_EXTENSION(); ZEND_DLEXPORT zend_extension zend_extension_entry = {
编译测试 编译测试： 执行phpize生成configure文件 然后执行./configure和make 将module目录下的so文件拷贝到你要的目录，然后配置一个php配置文件 添加extension=path/module_name.so,如果是zend extensions，则是 Zend_extension=path/module_name.so 这样，就可以开始你的调试之旅了。</description></item><item><title>QT：类似迅雷浮窗的不规则窗口的实现</title><link>/posts/qt_thunder_similar_floating_window_to_achieve_irregular_window/</link><pubDate>Thu, 21 Nov 2013 14:05:00 +0000</pubDate><guid>/posts/qt_thunder_similar_floating_window_to_achieve_irregular_window/</guid><description>见http://blog.csdn.net/small_qch/article/details/7054750需要将父类修改成QDialog主要思路：1：将窗体设为Qt::FramelessWindowHint（去掉标题栏）。2：用一幅有部分区域是透明的图片作为程序的界面，并将图片透明的地方设为穿透。3：重载程序的鼠标事件。运行时截图（浅绿色的是桌面背景）源代码：</description></item><item><title>dbus学习总结</title><link>/posts/dbus_learning_summary-2/</link><pubDate>Tue, 19 Nov 2013 12:37:00 +0000</pubDate><guid>/posts/dbus_learning_summary-2/</guid><description>dbus使用的人比较多，在csdn上有几个人都介绍的比较详细，跟着走一次基本就可以掌握。推介http://blog.csdn.net/flowingflying/article/details/5512222系列的。可以掌握dbus-binding相关的使用方式，比较简单。对于method通信方式中，2端的连接，核心见如下的API：12345DBUS_EXPORT DBusMessage * dbus_message_new_method_call ( const char * destination,const char * path,const char * iface,const char * method) 也就是必须要知道对方的destination (也就是bus name,object path,interface name和method。一个程序因该对应一个bus name,连接dbus-daemon的时候请求获得，一个应用可以有几个object path。interface 就是可以比较好的将method分类，方便使用。</description></item><item><title>Dbus学习总结</title><link>/posts/dbus_learning_summary/</link><pubDate>Tue, 19 Nov 2013 12:34:00 +0000</pubDate><guid>/posts/dbus_learning_summary/</guid><description>dbus使用的人比较多，在csdn上有几个人都介绍的比较详细，跟着走一次基本就可以掌握。推介http://blog.csdn.net/flowingflying/article/details/5512222系列的。可以掌握dbus-binding相关的使用方式，比较简单。对于method通信方式中，2端的连接，核心见如下的API：也就是必须要知道对方的destination (也就是bus name,object path,interface name和method。一个程序因该对应一个bus name,连接dbus-daemon的时候请求获得，一个应用可以有几个object path。interface 就是可以比较好的将method分类，方便使用。</description></item><item><title>[zz]cgit安装部署</title><link>/posts/zz_cgit_installation_and_deployment/</link><pubDate>Wed, 30 Oct 2013 16:05:00 +0000</pubDate><guid>/posts/zz_cgit_installation_and_deployment/</guid><description>[how to] 如何在ubuntu上安装cgit分类： git2010-07-03 16:38 1688人阅读 评论(0) 收藏 举报ubuntuapachedeb工具gitcss cgit 是一种git 代码浏览工具，类似gitweb ，但是更快速，openembedded ,freedeskop 等项目都在采用cgit。我就尝试在我的ubuntu 10.04安装了cgit，感觉不错。步骤如下:安装cgit两种选择:1 直接用deb二进制包安装，点击这里 去下载 2 编译源代码,参考官方readme安装apache2假设你的DocumentRoot 是/var/www$ sudo mkdir /var/www/cgit$ sudo cp /usr/share/cgit/cgit.css /var/www/cgit$ sudo cp /usr/share/cgit/cgit.pnf /var/www/cgit建立一个cgit配置文件在/etc/apache2/conf.d/目录下面[cpp] view plaincopyalias /cgit /var/www/cgit &amp;lt;Directory &amp;ldquo;/var/www/cgit/&amp;quot;&amp;gt; AllowOverride None Options ExecCGI DirectoryIndex /cgi-bin/cgit.cgi Order allow,deny Allow from all cgit 配置文件cgitrc在/etc下面[c-sharp] view plaincopycss=/cgit/cgit.css logo=/cgit/cgit.png repo.url=cgit.git repo.path=/home/lynn/cgit.git repo.desc=demo repo.owner=lynn 重启apache2然后打开 http://localhost/cgit 就可以了</description></item><item><title>kerberos中wrong principal in request的一个可能原因，#define KRB5KRB_AP_WRONG_PRINC (-1765328240L)</title><link>/posts/kerberos_the_wrong_principal_in_one_of_the_possible_causes_request__define_krb5krb_ap_wrong_princ_-1765328240l/</link><pubDate>Thu, 19 Sep 2013 18:56:00 +0000</pubDate><guid>/posts/kerberos_the_wrong_principal_in_one_of_the_possible_causes_request__define_krb5krb_ap_wrong_princ_-1765328240l/</guid><description>最近配置kerberos，配置后用sclient测试的时候遇到wrong principal in request，搜了下没有找到解决办法，用gdb调了下发现原来是我的主机名配置的有问题。错误信息如下。修复方式为：如使用kerberos.example.com则主机名也为kerberos.example.com主机名的修改方式为：Fedora上是修改&amp;quot;/etc/hostname&amp;quot; 文件rhel主机名配置为/etc/sysconfig/network</description></item><item><title>django中添加xmlrpc支持</title><link>/posts/django_add_xmlrpc_support/</link><pubDate>Mon, 16 Sep 2013 13:44:00 +0000</pubDate><guid>/posts/django_add_xmlrpc_support/</guid><description>实现一个xmlrpc功能模块，代码如下add the following to urls.pyThat&amp;rsquo;s it!You can pretty much write a standard python function in there, just be sure to register it with the dispatcher when you&amp;rsquo;re done.Here&amp;rsquo;s a quick and dirty client example for testing:Based on experience, I do recommend that you use Dictionaries for your args rather than long args, but I think that&amp;rsquo;s personal preference (It allows named arguments, eliminates &amp;lsquo;out of order&amp;rsquo; argument issues and it makes the code more self-documenting).</description></item><item><title>linux 下如何通过软件模拟按键[转-修改]</title><link>/posts/how_software_under_linux_analog_buttons_turn_-_modify/</link><pubDate>Wed, 14 Aug 2013 17:13:00 +0000</pubDate><guid>/posts/how_software_under_linux_analog_buttons_turn_-_modify/</guid><description>其实在/dev/input/by-path目录下面的文件名有表明是什么设备，键盘还是鼠标，可以通过文件名来确认键盘所对应的dev设别，然后对该文件进行处理。然后按以下的内容进行操作即可。linux 下如何通过软件模拟按键[转-修改]转自：http://zhgw01.blog.163.com/blog/static/10414812200992854628702/参考http://www.linuxdiyf.com/viewarticle.php?id=104221名词解释：scancode: 驱动对硬件的标记keycode： 上层应用程序所见的标记，跟硬件的标记不同， 一般为KEY_F1之类的宏一般驱动将scancode绑定到keycode对未绑定的scancode, 可以通过setkeycodes将将其绑定到未使用的keycode注： 有些按键会被解释成acpi event, 可以通过acpi_listen来监听，但不一定成功，目前还没具体了解模 拟按键是上层应用程序的行为， 所以不需要编译成模块，只需要想平常的应用程序那样编译就可以了， 不过它要包含&amp;lt;linux/input.h&amp;gt;这个文件， 同时要明确键盘对应的/dev/input/event[0-4]到底是哪个文件， 此外还需要以root权限来运行赖半仙注解：运行命令 cat /proc/bus/input/devices 在输出里面查找 xxx keyboard 对应的文件是/dev/input/event几。我开始想当然的以为键盘文件是event1,结果死人都调不出来，弄了很久最后从event0开始一个一个试，才发现我的手提电脑键盘文件对应的是event4。在我的电脑上运行命令 ls /dev/input/event* 发现有好多输入设备…………/dev/input/event0 /dev/input/event10 /dev/input/event2 /dev/input/event4 /dev/input/event6 /dev/input/event8/dev/input/event1 /dev/input/event11 /dev/input/event3 /dev/input/event5 /dev/input/event7 /dev/input/event9下面是 cat /proc/bus/input/devices 命令对应键盘文件的一段输出I: Bus=0011 Vendor=0001 Product=0001 Version=ab41N: Name=&amp;ldquo;AT Translated Set 2 keyboard&amp;quot;P: Phys=isa0060/serio0/input0S: Sysfs=/devices/platform/i8042/serio0/input/input4U: Uniq=H: Handlers=kbd event4 B: EV=120013B: KEY=8000 0 0 0 0 0 5007 2002000 380307c f800d001 feffffdf ffefffff ffffffff ffffffffB: MSC=10B: LED=7下面的程序是模拟按键NumLock，就是控制小键盘灯的那个按键，按下去（运行程序没有问题）后小键盘灯就会点亮或者熄灭。 #include &amp;lt;linux/input.h&amp;gt;#include &amp;lt;time.</description></item><item><title>[zz] extJs常用的四种Ajax异步提交</title><link>/posts/zz_extjs_four_common_ajax_asynchronous_commit/</link><pubDate>Thu, 08 Aug 2013 08:09:00 +0000</pubDate><guid>/posts/zz_extjs_four_common_ajax_asynchronous_commit/</guid><description>extJs常用的四种Ajax异步提交分类： ExtJs2010-06-01 16:52 2973人阅读 评论(0) 收藏 举报ajaxextjsfunctionactionuserhtml[java] view plaincopy/** * * 第一种Ajax提交方式 * * * 这种方式需要直接使用ext Ajax方法进行提交 * * * 使用这种方式，需要将待传递的参数进行封装 * * * @return */ function saveUser_ajaxSubmit1() { Ext.Ajax.request( { url : &amp;lsquo;user_save.action&amp;rsquo;, method : &amp;lsquo;post&amp;rsquo;, params : { userName : document.getElementById(&amp;lsquo;userName&amp;rsquo;).value, password : document.getElementById(&amp;lsquo;password&amp;rsquo;).value }, success : function(response, options) { var o = Ext.util.JSON.decode(response.responseText); alert(o.msg); }, failure : function() { } }); } /** * * 第二种Ajax提交方式 * * * 这种方式将为ext的ajax指定一个html表单 * * * 使用这种方式，不需要将待传递的参数进行封装 * * * @return */ function saveUser_ajaxSubmit2() { Ext.</description></item><item><title>[zz]ExtJS之Ext.Ajax.request用法详解</title><link>/posts/zz_extjs_detailed_usage_of_extajaxrequest/</link><pubDate>Thu, 08 Aug 2013 08:07:00 +0000</pubDate><guid>/posts/zz_extjs_detailed_usage_of_extajaxrequest/</guid><description>ExtJS之Ext.Ajax.request用法详解 RIA-ExtJS专栏EXTAjaxjsonOO浏览器 Java代码 &amp;lt;span style=&amp;ldquo;font-size: medium;&amp;quot;&amp;gt;Ext.Ajax.request({ url:&amp;lsquo;findbyid.action&amp;rsquo;, params:{ id:cell.getId() }, success: function(resp,opts) { var respText = Ext.util.JSON.decode(resp.responseText); name=respText.name; oid=respText.id; findbyid(graph,cell,oid,name); //Ext.Msg.alert(&amp;lsquo;错误&amp;rsquo;, respText.name+&amp;quot;=====&amp;quot;+respText.id); }, failure: function(resp,opts) { var respText = Ext.util.JSON.decode(resp.responseText); Ext.Msg.alert(&amp;lsquo;错误&amp;rsquo;, respText.error); } });在Ext开发过程中，基本上时刻需要用到异步请求，那么这个请求到底是怎么执行的呢，我们接下来来探讨下 首先：Ext.Ajax类继承了Ext.data.Connection，为Ajax的请求提供了最大灵活性的操作方式再简单请求基础上我们加上一个使用的 说明的是这种请求通常都是放在触发某个事件的处理方法中的url:就是我们要请求的路径params:里面的参数用逗号隔开，就是我们要发出请求带的参数success:是服务器处理成功返回failure:是服务器处理失败返回重点讲的就是如何处理返回值信息，我们的resp这个参数就显得非常重要了resp是Ext构造的一个返回结果对象，如服务器端返回“this is a test！”（可以通过throw new Exception(&amp;ldquo;this is a test!&amp;quot;)简单实现)。那么返回将是如下内容：Java代码 &amp;lt;span style=&amp;ldquo;font-size: medium;&amp;quot;&amp;gt;tId.1 status.200 statusText.OK getResponseHeader.[object Object] getAllResponseHeaders.Server: Apache-Coyote/1.1 Content-Type: text/html;charset=GBK Content-Language: zh-CN Content-Length: 108 Date: Wed, 31 Oct 2007 12:51:23 GMT responseText. 错误错误：this is a test!</description></item><item><title>git-web中添加用户认证</title><link>/posts/git-web_to_add_user_authentication/</link><pubDate>Thu, 04 Jul 2013 10:10:00 +0000</pubDate><guid>/posts/git-web_to_add_user_authentication/</guid><description>git-web默认配置没有用户认证,有时为了权限控制,认证还是必须的.在网上找了下,动手修改,解决办法如下:使用一下的配置文件可以添加密码验证&amp;lt;VirtualHost *:80&amp;gt; ServerName gitweb.example.com DocumentRoot /var/www/gitweb/public_html DAV on AuthType Basic AuthName &amp;ldquo;Private Git Repository&amp;rdquo; AuthUserFile /etc/apache2/dav_git.passwd Require valid-user Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch AllowOverride All order allow,deny Allow from all AddHandler cgi-script cgi DirectoryIndex gitweb.cgi 然后使用设置HTTP认证密码，这个密码和git仓库的提交无关htpasswd -c /etc/apache2/dav_git.passwd YourName来设置密码文件中的密文如果没有需要开启模块12. 为gitweb指定仓库地址 编辑 /etc/gitweb.conf 写入$projectroot = &amp;ldquo;/var/git&amp;rdquo;; 13. 开启apache2相应模块a2enmod dav_fsa2enmod dav</description></item><item><title>eclipse出错</title><link>/posts/eclipse_error/</link><pubDate>Tue, 19 Mar 2013 12:46:00 +0000</pubDate><guid>/posts/eclipse_error/</guid><description>出现错误，日志文件提示： 突然就想起来昨晚更新了系统包，应该是python的版本不对，把~/.eclipse下面的东西清除掉就可以了``` BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=zh_CNCommand-line arguments: -os linux -ws gtk -arch x86_64!ENTRY org.eclipse.ui 2 2 2013-03-07 15:58:25.830!MESSAGE Invalid preference category path: org.eclipse.birt.chart.reportitem.ui.ChartPreferencePage (bundle: org.eclipse.birt.chart.ui.extension, page: org.eclipse.birt.chart.ui.swt.fieldassist.preferences.FieldAssistPreferencePage)!ENTRY com.aptana.shared_core 1 1 2013-03-07 15:58:31.238!MESSAGE Information about process of adding new interpreter:- Chosen interpreter (name and file):&amp;lsquo;Tuple - Ok, file is non-null. Getting info on:/usr/bin/python2.7- Beggining task:Getting libs totalWork:100- Setting task name:Mounting executable string&amp;hellip;- Setting task name:Executing: /usr/bin/python2.7 -u /usr/share/eclipse/dropins/pydev/eclipse/plugins/org.python.pydev_2.7.1.2012100913/pysrc/interpreterInfo.py- Setting task name:Making pythonpath environment&amp;hellip; /usr/bin/python2.</description></item><item><title>pcre使用</title><link>/posts/pcre_use/</link><pubDate>Thu, 14 Mar 2013 06:22:00 +0000</pubDate><guid>/posts/pcre_use/</guid><description>在网上找到的pcre使用的资料，PCRE是一个NFA正则引擎，不然不能提供完全与Perl一致的正则语法功能。但它同时也实现了DFA，只是满足数学意义上的正则。PCRE提供了19个接口函数，为了简单介绍，使用PCRE内带的测试程序(pcretest.c)示例用法。1. pcre_compile原型：#include &amp;lt;pcre.h&amp;gt;pcre *pcre_compile(const char *pattern, int options, const char **errptr, int *erroffset, const unsigned char *tableptr);功能：将一个正则表达式编译成一个内部表示，在匹配多个字符串时，可以加速匹配。其同pcre_compile2功能一样只是缺少一个参数errorcodeptr。参数：pattern 正则表达式options 为0，或者其他参数选项errptr 出错消息erroffset 出错位置tableptr 指向一个字符数组的指针，可以设置为空NULL示例：L1720 re = pcre_compile((char *)p, options, &amp;amp;error, &amp;amp;erroroffset, tables);2. pcre_compile2原型：#include &amp;lt;pcre.h&amp;gt;pcre *pcre_compile2(const char *pattern, int options, int *errorcodeptr, const char **errptr, int *erroffset, const unsigned char *tableptr);功能：将一个正则表达式编译成一个内部表示，在匹配多个字符串时，可以加速匹配。其同pcre_compile功能一样只是多一个参数errorcodeptr。参数：pattern 正则表达式options 为0，或者其他参数选项errorcodeptr 存放出错码errptr 出错消息erroffset 出错位置tableptr 指向一个字符数组的指针，可以设置为空NULL3. pcre_config原型：#include &amp;lt;pcre.h&amp;gt;int pcre_config(int what, void *where);功能：查询当前PCRE版本中使用的选项信息。参数：what 选项名where 存储结果的位置示例：Line1312 (void)pcre_config(PCRE_CONFIG_POSIX_MALLOC_THRESHOLD, &amp;amp;rc);4. pcre_copy_named_substring原型：#include &amp;lt;pcre.h&amp;gt;int pcre_copy_named_substring(const pcre *code, const char *subject, int *ovector, int stringcount, const char *stringname, char *buffer, int buffersize);功能：根据名字获取捕获的字串。参数：code 成功匹配的模式subject 匹配的串ovector pcre_exec() 使用的偏移向量stringcount pcre_exec()的返回值stringname 捕获字串的名字buffer 用来存储的缓冲区buffersize 缓冲区大小示例：Line2730 int rc = pcre_copy_named_substring(re, (char *)bptr, use_offsets,count, (char *)copynamesptr, copybuffer, sizeof(copybuffer));5.</description></item></channel></rss>