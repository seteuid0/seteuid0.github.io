<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>e820 on seteuid0's blog</title><link>/tags/e820/</link><description>Recent content in e820 on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Wed, 16 Oct 2013 16:57:00 +0000</lastBuildDate><atom:link href="/tags/e820/index.xml" rel="self" type="application/rss+xml"/><item><title>【zz】linux内核e820来源及相关知识</title><link>/posts/zz_linux_kernel_sources_and_relevant_knowledge_e820/</link><pubDate>Wed, 16 Oct 2013 16:57:00 +0000</pubDate><guid>/posts/zz_linux_kernel_sources_and_relevant_knowledge_e820/</guid><description>http://hi.baidu.com/ballmillsap/item/c2f3cf6f43d3220aa1cf0fe4e820简介操作系统内存布局中断 int 0x15e820简介 收藏本文系转载，原文地址：http://wangcong.org/blog/?p=320，其中附录部分 为本人所加&amp;hellip; e820是和BIOS的一个中断相关的，具体说是int 0x15。之所以叫e820是因为在用这个中断时ax必须是0xe820。这个中断的作用是得到系统的内存布局。因为系统内存会有很多段，每段的类型属性 也不一样，所以这个查询是“迭代式”的，每次求得一个段。 我们看内核源代码。主要涉及两个文件：arch/x86/boot/memory.c和arch/x86/kernel /e820_32.c。我们 已经很幸运了，这部分代码已经用C重写过了。你可能会奇怪，启动调用e820时我们还在实模式，怎么能用C呢？答案是，这里用的是16位的C。gcc早已 经支持.code16 gcc模式了。 看detect_memory_e820()函数，里面就是e820的本质。它把int 0x15放到一个do-while循环里，每次得到的一个内存段放到struct e820entry里，而struct e820entry的结构正是e820返回结果的结构！而像其它启动时获得的结果一样，最终都会被放到boot_params里，e820被放到了 boot_params.e820_map。如果你对struct e820entry还有疑问，你可以看一下arch/x86/kernel/e820_32.c::print_memory_map()，看看里面是怎 么使用它的。 当然了，在arch/x86/boot/memory.c里，你还会看到另外两个利用int 0x15查询内存的函数，不过用途不一样了。附：boot_params 结构体定义，其中E820MAX 定义为128:struct e820entry {__u64 addr; /* start of memory segment */__u64 size; /* size of memory segment */__u32 type; /* type of memory segment */} __attribute__((packed));struct boot_params { struct screen_info screen_info; /* 0x000 */ struct apm_bios_info apm_bios_info; /* 0x040 */ __u8 _pad2[12]; /* 0x054 */ struct ist_info ist_info; /* 0x060 */ __u8 _pad3[16]; /* 0x070 */ __u8 hd0_info[16]; /* obsolete!</description></item></channel></rss>