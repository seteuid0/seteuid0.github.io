<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pthread on seteuid0's blog</title><link>/tags/pthread/</link><description>Recent content in pthread on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Tue, 11 Mar 2014 13:22:58 +0000</lastBuildDate><atom:link href="/tags/pthread/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux下线程pthread实现suspend、resume的一种方式</title><link>/posts/linux_pthread_suspend_resume/</link><pubDate>Tue, 11 Mar 2014 13:22:58 +0000</pubDate><guid>/posts/linux_pthread_suspend_resume/</guid><description>Linux下线程pthread没有实现suspend,resume的相关功能，这几天项目需要，自己就使用pthread_cond_wait实现了下，把主要代码逻辑如下，贴出来供大家参考。 功能如下。 主线程监听用户消息，子线程完成实际任务。主线程需要依据用户输入控制工作子线程的暂停（suspend）和继续运行（resume）。 使用CTRL+C控制暂停、继续运行。 使用CTRL+\使程序退出，主线程先cancel，然后自己退出。 代码如下：
#include &amp;lt;pthread.h&amp;gt; #include &amp;lt;signal.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; typedef enum \_RUN\_STATUS{ STATUS\_RUNNING = 0, STATUS\_PAUSE, }RUN\_STATUS; sigset\_t mask; RUN\_STATUS run\_status; pthread\_mutex\_t lock = PTHREAD\_MUTEX\_INITIALIZER; pthread\_cond\_t waitloc = PTHREAD\_COND\_INITIALIZER; void cleanup\_handler(void\*arg) { printf(&amp;quot;child thread cleanup\\n&amp;quot;); pthread\_mutex\_unlock(&amp;amp;lock); } void \* thread\_func(void\*arg) { int err, signo; pthread\_cleanup\_push(cleanup\_handler, NULL); for(;;){ pthread\_mutex\_lock(&amp;amp;lock); if(run\_status == STATUS\_RUNNING){ pthread\_mutex\_unlock(&amp;amp;lock); printf(&amp;quot;child pthread task running-&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;\\n&amp;quot;); sleep(1); }else{ while(run\_status != STATUS\_RUNNING){ pthread\_cond\_wait(&amp;amp;waitloc, &amp;amp;lock); printf(&amp;quot;running again\\n&amp;quot;); } pthread\_mutex\_unlock(&amp;amp;lock); } } pthread\_cleanup\_pop(0); return 0; } int main() { int ret; run\_status = STATUS\_RUNNING; sigset\_t oldmask; pthread\_t tid; int err, signo; sigemptyset(&amp;amp;mask); sigaddset(&amp;amp;mask, SIGINT); sigaddset(&amp;amp;mask, SIGQUIT); pthread\_t tid\_self = pthread\_self(); if((ret = pthread\_sigmask(SIG\_BLOCK, &amp;amp;mask, &amp;amp;oldmask)) !</description></item></channel></rss>