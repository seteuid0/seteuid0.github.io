<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>extjs on seteuid0's blog</title><link>/tags/extjs/</link><description>Recent content in extjs on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Thu, 08 Aug 2013 08:09:00 +0000</lastBuildDate><atom:link href="/tags/extjs/index.xml" rel="self" type="application/rss+xml"/><item><title>[zz] extJs常用的四种Ajax异步提交</title><link>/posts/zz_extjs_four_common_ajax_asynchronous_commit/</link><pubDate>Thu, 08 Aug 2013 08:09:00 +0000</pubDate><guid>/posts/zz_extjs_four_common_ajax_asynchronous_commit/</guid><description>extJs常用的四种Ajax异步提交分类： ExtJs2010-06-01 16:52 2973人阅读 评论(0) 收藏 举报ajaxextjsfunctionactionuserhtml[java] view plaincopy/** * * 第一种Ajax提交方式 * * * 这种方式需要直接使用ext Ajax方法进行提交 * * * 使用这种方式，需要将待传递的参数进行封装 * * * @return */ function saveUser_ajaxSubmit1() { Ext.Ajax.request( { url : &amp;lsquo;user_save.action&amp;rsquo;, method : &amp;lsquo;post&amp;rsquo;, params : { userName : document.getElementById(&amp;lsquo;userName&amp;rsquo;).value, password : document.getElementById(&amp;lsquo;password&amp;rsquo;).value }, success : function(response, options) { var o = Ext.util.JSON.decode(response.responseText); alert(o.msg); }, failure : function() { } }); } /** * * 第二种Ajax提交方式 * * * 这种方式将为ext的ajax指定一个html表单 * * * 使用这种方式，不需要将待传递的参数进行封装 * * * @return */ function saveUser_ajaxSubmit2() { Ext.</description></item><item><title>[zz]ExtJS之Ext.Ajax.request用法详解</title><link>/posts/zz_extjs_detailed_usage_of_extajaxrequest/</link><pubDate>Thu, 08 Aug 2013 08:07:00 +0000</pubDate><guid>/posts/zz_extjs_detailed_usage_of_extajaxrequest/</guid><description>ExtJS之Ext.Ajax.request用法详解 RIA-ExtJS专栏EXTAjaxjsonOO浏览器 Java代码 &amp;lt;span style=&amp;ldquo;font-size: medium;&amp;quot;&amp;gt;Ext.Ajax.request({ url:&amp;lsquo;findbyid.action&amp;rsquo;, params:{ id:cell.getId() }, success: function(resp,opts) { var respText = Ext.util.JSON.decode(resp.responseText); name=respText.name; oid=respText.id; findbyid(graph,cell,oid,name); //Ext.Msg.alert(&amp;lsquo;错误&amp;rsquo;, respText.name+&amp;quot;=====&amp;quot;+respText.id); }, failure: function(resp,opts) { var respText = Ext.util.JSON.decode(resp.responseText); Ext.Msg.alert(&amp;lsquo;错误&amp;rsquo;, respText.error); } });在Ext开发过程中，基本上时刻需要用到异步请求，那么这个请求到底是怎么执行的呢，我们接下来来探讨下 首先：Ext.Ajax类继承了Ext.data.Connection，为Ajax的请求提供了最大灵活性的操作方式再简单请求基础上我们加上一个使用的 说明的是这种请求通常都是放在触发某个事件的处理方法中的url:就是我们要请求的路径params:里面的参数用逗号隔开，就是我们要发出请求带的参数success:是服务器处理成功返回failure:是服务器处理失败返回重点讲的就是如何处理返回值信息，我们的resp这个参数就显得非常重要了resp是Ext构造的一个返回结果对象，如服务器端返回“this is a test！”（可以通过throw new Exception(&amp;ldquo;this is a test!&amp;quot;)简单实现)。那么返回将是如下内容：Java代码 &amp;lt;span style=&amp;ldquo;font-size: medium;&amp;quot;&amp;gt;tId.1 status.200 statusText.OK getResponseHeader.[object Object] getAllResponseHeaders.Server: Apache-Coyote/1.1 Content-Type: text/html;charset=GBK Content-Language: zh-CN Content-Length: 108 Date: Wed, 31 Oct 2007 12:51:23 GMT responseText. 错误错误：this is a test!</description></item></channel></rss>