<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ARM on seteuid0's blog</title><link>/tags/arm/</link><description>Recent content in ARM on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Sat, 02 Nov 2019 08:55:07 +0000</lastBuildDate><atom:link href="/tags/arm/index.xml" rel="self" type="application/rss+xml"/><item><title>Rockchip linux sdk buildroot使用记录</title><link>/posts/rockchip-linux-sdk-buildroot%e4%bd%bf%e7%94%a8%e8%ae%b0%e5%bd%95/</link><pubDate>Sat, 02 Nov 2019 08:55:07 +0000</pubDate><guid>/posts/rockchip-linux-sdk-buildroot%e4%bd%bf%e7%94%a8%e8%ae%b0%e5%bd%95/</guid><description>Rockchip Linux SDK里面的buildroot可以制作一个简洁的rootfs，但按照文档还是有一些问题，以下是使用时大致的一个记录及代码修改记录。 SDK从 http://opensource.rock-chips.com/wiki_Linux_SDK 获取。http://opensource.rock-chips.com/wiki_Source 里面有使用方法。 先要获取repogit clone https://github.com/rockchip-linux/repo mkdir linux cd linux而后同步代码，我这里使用的是RK3399的代码，由于网络原因可能会有超时发生，可以使用后面的脚本进行多次获取。``` ../repo/repo init &amp;ndash;repo-url=https://github.com/rockchip-linux/repo -u https://github.com/rockchip-linux/manifests -b master -m rk3399_linux_release.xml ../repo/repo sync
#!/bin/sh ../repo/repo sync -c while \[ $? -ne 0 \] ; do ../repo/repo sync -c; done ```代码就绪后就可以开始动手编译了。``` #cd u-boot #./make.sh evb-rk3399 $ source buildroot/build/envsetup.sh You're building on Linux Lunch menu...pick a combo: 1. rockchip\_rk3308\_release 2. rockchip\_rk3308\_debug 3. rockchip\_rk3308\_robot\_release 4. rockchip\_rk3308\_robot\_debug 5. rockchip\_rk3308\_mini\_release Which would you like?</description></item><item><title>[转]U-boot 之TFTP服务器配置</title><link>/posts/u-boot-tftp-server-config/</link><pubDate>Wed, 15 Apr 2015 16:27:38 +0000</pubDate><guid>/posts/u-boot-tftp-server-config/</guid><description>一.PC端配置 1.关闭防火墙 [root@gliethttp root]# /etc/init.d/iptables stop 2.使用setup启动tftp [root@gliethttp root]# setup -&amp;gt;System services-&amp;gt;选中tftp 3.如果setup中找不到tftp选项，那么你需要rpm包来安装 在redhat9的CD3里可以找到tftp-server-0.32-4.i386.rpm文件 [root@gliethttp root]# rpm -ivh tftp-server-0.32-4.i386.rpm 4.修改tftp服务器配置 [root@gliethttp root]# vim /etc/xinetd.d/tftp 将server_args配置项为你自己的tftpboot根目录 将disable 配置为no service tftp { socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /tftpboot disable = no per_source = 11 cps = 100 2 flags = IPv4 } 5.启动tftp服务器 [root@gliethttp root]# /etc/init.d/xinetd restart 6.下载文件准备 [root@gliethttp root]# mkdir /tftpboot [root@gliethttp root]# cp usb1-uImage /tftpboot ；拷贝预下载的内核文件到/tftpboot目录下 [root@gliethttp root]# cp minigui9200.</description></item><item><title>[ZZ]Device Tree（一）：背景介绍 为什么引入dtb</title><link>/posts/zzdevice-tree%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d/</link><pubDate>Mon, 23 Mar 2015 02:44:42 +0000</pubDate><guid>/posts/zzdevice-tree%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d/</guid><description>作者：linuxer 发布于：2014-5-22 16:46 分类：统一设备模型
一、前言 作为一个多年耕耘在linux 2.6.23内核的开发者，各个不同项目中各种不同周边外设驱动的开发以及各种琐碎的、扯皮的俗务占据了大部分的时间。当有机会下载3.14的内核并准备学习的时候，突然发现linux kernel对于我似乎变得非常的陌生了，各种新的机制，各种framework、各种新的概念让我感到阅读内核代码变得举步维艰。 还好，剖析内核的热情还在，剩下的就交给时间的。首先进入视线的是Device Tree机制，这是和porting内核非常相关的机制，如果想让将我们的硬件平台迁移到高版本的内核上，Device Tree是一个必须要扫清的障碍。 我想从下面三个方面来了解Device Tree： 1、为何要引入Device Tree，这个机制是用来解决什么问题的？（这是本文的主题） 2、Device Tree的基础概念（请参考DT基础概念） 3、ARM linux中和Device Tree相关的代码分析（请参考DT代码分析） 阅读linux内核代码就像欣赏冰山，有看得到的美景（各种内核机制及其代码），也有埋在水面之下看不到的基础（机制背后的源由和目的）。沉醉于各种内核机制的代码固然有无限乐趣，但更重要的是注入更多的思考，思考其背后的机理，真正理解软件抽象。这样才能举一反三，并应用在具体的工作和生活中。 本文主要从下面几个方面阐述为何ARM linux会引入Device Tree： 1、没有Device Tree的ARM linux是如何运转的？ 2、混乱的ARM architecture代码和存在的问题 3、新内核的解决之道 二、没有Device Tree的ARM linux是如何运转的？ 我曾经porting内核到两个ARM-based的平台上。一个是小的芯片公司的应用处理器，公司自己购买了CPU core，该CPU core使用ARM兼容的指令集（但不是ARM）加上各种公司自行设计的多媒体外设整合成公司的产品进行销售。而我的任务就是porting 2.4.18内核到该平台上。在黑白屏幕的手机时代，那颗AP（application process）支持了彩屏、camera、JPEG硬件加速、2D/3D加速、MMC/SD卡、各种音频加速（内置DSP）等等特性，功能强大到无法直视。另外一次移植经历是让2.6.23内核跑在一个大公司的冷门BP（baseband processor）上。具体porting的方法是很简单的： 1、自己撰写一个bootloader并传递适当的参数给kernel。除了传统的command line以及tag list之类的，最重要的是申请一个machine type，当拿到属于自己项目的machine type ID的时候，当时心情雀跃，似乎自己已经是开源社区的一份子了（其实当时是有意愿，或者说有目标是想将大家的代码并入到linux kernel main line的）。 2、在内核的arch/arm目录下建立mach-xxx目录，这个目录下，放入该SOC的相关代码，例如中断controller的代码，时间相关的代码，内存映射，睡眠相关的代码等等。此外，最重要的是建立一个board specific文件，定义一个machine的宏：
MACHINE_START(project name, &amp;ldquo;xxx公司的xxx硬件平台&amp;rdquo;) .phys_io = 0x40000000, .boot_params = 0xa0000100, .io_pg_offst = (io_p2v(0x40000000) &amp;raquo; 18) &amp;amp; 0xfffc, .map_io = xxx_map_io, .</description></item></channel></rss>