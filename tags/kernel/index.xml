<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kernel on seteuid0's blog</title><link>/tags/kernel/</link><description>Recent content in kernel on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Tue, 27 Feb 2018 12:19:05 +0000</lastBuildDate><atom:link href="/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>[转]linux图形显示相关内容</title><link>/posts/%e8%bd%aclinux%e5%9b%be%e5%bd%a2%e6%98%be%e7%a4%ba%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9/</link><pubDate>Tue, 27 Feb 2018 12:19:05 +0000</pubDate><guid>/posts/%e8%bd%aclinux%e5%9b%be%e5%bd%a2%e6%98%be%e7%a4%ba%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9/</guid><description>1. 前言 图形子系统是linux系统中比较复杂的子系统之一：对下，它要管理形态各异的、性能各异的显示相关的器件；对上，它要向应用程序提供易用的、友好的、功能强大的图形用户界面（GUI）。因此，它是linux系统中少有的、和用户空间程序（甚至是用户）息息相关的一个子系统。 本文是图形子系统分析文章的第一篇，也是提纲挈领的一篇，将会从整体上，对linux显示子系统做一个简单的概述，进而罗列出显示子系统的软件构成，后续的文章将会围绕这些软件一一展开分析。 注1：本文所有的描述将以原生linux系统为例（如Ubuntu、Debian等），对其它基于linux的系统（如Android），部分内容会不适用。 注2：本文很多图片都是从网上搜集而来的（很多是从维基百科）。虽然蜗窝的宗旨是用自己的语言表述，尽量自己画图，但是linux图形子系统太复杂了，蜗蜗的理解有限，而老外的图画的实在太好，蜗蜗觉得，再怎么努力，也画不出更好的了，因此本着为读者负责的态度，就直接copy了。
2. 概念介绍 2.1 GUI（Graphical User Interface，图形用户界面） linux图形子系统的本质，是提供图形化的人机交互（human-computer interaction）界面，也即常说的GUI（Graphical User Interface）。而人机交互的本质，是人脑通过人的输出设备（动作、声音等），控制电脑的输入设备，电脑经过一系列的处理后，经由电脑的输出设备将结果输出，人脑再通过人的输入设备接收电脑的输出，最终实现“人脑&amp;lt;&amp;ndash;&amp;gt;电脑”之间的人机交互。下面一幅摘自维基百科的图片（可从“这里”查看比较清晰的SVG格式的原始图片），对上述过程做了很好的总结：
该图以一个非常前卫的应用场景&amp;mdash;-虚拟现实（VR，Virtual Reality）游戏，说明了以图形化为主的人机交互过程： 1）人脑通过动作、声音（对人脑而言，是output），控制电脑的输入设备，包括键盘、鼠标、操作杆、麦克风、游戏手柄（包含加速度计、陀螺仪等传感器）。 2）电脑通过输入设备，接收人脑的指令，这些指令经过kernel Input subsystem、Middleware Gesture/Speech recognition等软件的处理，转换成应用程序（Game）可以识别的、有意义的信息。 3）应用程序（Game）根据输入信息，做出相应的反馈，主要包括图像和声音。对VR游戏而言，可能需要3D rendering，这可以借助openGL及其相应的用户空间driver实现。 4）应用程序的反馈，经由kernel的Video subsystem（如DRM/KMS）、audio subsystem（如ALSA），输出到电脑的输出设备上，包括显示设备（2D/3D）、扬声器/耳机（3D Positional Audio）、游戏手柄（力的反馈）等。 5）输出到显示设备上时，可能会经过图形加速模块（Graphics accelerator）。 注3：图中提到了VR场景的典型帧率（1280×800@95fps for VR），这是一个非常庞大的信息输出，要求图形子系统能10.5ms的时间内，生成并输出一帧，以RGBA的数据格式为例，每秒需要处理的数据量是1280x800x95x4x8=3.11296Gb，压力和挑战是相当大的（更不用提1080P了）。
有关GUI更为详细的解释，请参考：https://en.wikipedia.org/wiki/Graphical_user_interface。
2.2 Windowing system（窗口系统） 窗口系统，是GUI的一种（也是当前计算机设备、智能设备广泛使用的一种），以WIMP （windows、icons、menus、pointer) 的形式，提供人机交互接口。Linux系统中有很多窗口系统的实现，如X Window System、Wayland、Android SurfaceFlinger等，虽然形态各异，但思路大致相同，包含如下要点：
1）一般都使用client-server架构，server（称作display server，或者windows server、compositor等等）管理所有输入设备，以及用于输出的显示设备。 2）应用程序作为display server的一个client，在自己窗口（window）中运行，并绘制自己的GUI。 3）client的绘图请求，都会提交给display server，display server响应并处理这些请求，以一定的规则混合、叠加，最终在有限的输出资源上（屏幕），显示多个应用程序的GUI。 3）display server和自己的client之间，通过某种类型的通信协议交互，该通信协议通常称作display server protocol。 4）display server protocol可以是基于网络的，甚至是网络透明的（network transparent），如X Window System所使用的。也可以是其它类型的，如Android SurfaceFlinger所使用的binder。
有关Windowing system的详细解释，请参考：https://en.</description></item><item><title>linux-3.19下运行vmware解决方案</title><link>/posts/linux-3-19-vmware-vmnet-error/</link><pubDate>Thu, 30 Apr 2015 02:32:59 +0000</pubDate><guid>/posts/linux-3-19-vmware-vmnet-error/</guid><description>由于linux3.19内核升级导致接口变化，vmnet无法编译通过。解决办法如下，可以把附件的vmnet替换掉原来的，即可使用。下载后执行：``` cp vmnet.tar /usr/lib/vmware/modules/source/vmnet.tar</description></item><item><title>搭建linux0.11系统环境</title><link>/posts/%e6%90%ad%e5%bb%balinux0-11%e7%b3%bb%e7%bb%9f%e7%8e%af%e5%a2%83/</link><pubDate>Wed, 14 Jan 2015 16:17:56 +0000</pubDate><guid>/posts/%e6%90%ad%e5%bb%balinux0-11%e7%b3%bb%e7%bb%9f%e7%8e%af%e5%a2%83/</guid><description>要学习Linux0.11的内核代码必须要有一个运行环境来做实验，本文简要介绍如何搭建该环境。 环境：ubuntu14.10 x86_64 Linux0.11的内核可以说是古董级的，所以必须要祭出模拟器了，有2中搭建方案bochs或qemu
使用bochs仿真器： 1、使用发行版的bochs，通过apt-get安装，需要安装如下软件包，如果缺包在之后的运行中就会有各种问题，此处忽略。当然你也可以从http://sourceforge.net/projects/bochs/files/Disk%20Images/ 处下载安装。ii bochs 2.6-2 amd64 IA-32 PC emulator ii bochs-doc 2.6-2 all Bochs upstream documentation ii bochs-term 2.6-2 amd64 Terminal (ncurses-based) plugin for Bochs ii bochs-wx 2.6-2 amd64 WxWindows plugin for Bochs ii bochs-x 2.6-2 amd64 X11 plugin for Bochs ii bochsbios 2.6-2 all BIOS for the Bochs emulator2、下载虚拟文件系统：地址：http://www.oldlinux.org/Linux.old/bochs/linux-0.11-devel-040329.zip 3、由于bochs的变化，所以需要修改配置文件，我修改bochsrc-hd.bxrc后的内容如下：``` megs: 16 floppya: 1_44=&amp;ldquo;bootimage-0.11-hd&amp;rdquo;, status=inserted floppyb: 1_44=diskb.img, status=inserted ata0-master: type=disk, path=&amp;ldquo;hdc-0.11.img&amp;rdquo;, mode=flat, cylinders=121, heads=16, spt=63 boot: a log: bochsout.</description></item><item><title>grsecurity系列之一:概述及简易安装部署</title><link>/posts/grsecurity%e7%b3%bb%e5%88%97%e4%b9%8b%e4%b8%80%e6%a6%82%e8%bf%b0%e5%8f%8a%e7%ae%80%e6%98%93%e5%ae%89%e8%a3%85%e9%83%a8%e7%bd%b2/</link><pubDate>Thu, 20 Nov 2014 14:52:52 +0000</pubDate><guid>/posts/grsecurity%e7%b3%bb%e5%88%97%e4%b9%8b%e4%b8%80%e6%a6%82%e8%bf%b0%e5%8f%8a%e7%ae%80%e6%98%93%e5%ae%89%e8%a3%85%e9%83%a8%e7%bd%b2/</guid><description>近日准备分析下grsecurity，把过程总结记录下与大家分享、讨论。 SELinux应该很多人都知道，不错，它是Linux的LSM框架下强制访问控制机制中使用较为普遍的一种，由NSA开发。在RHEL、Fedora系统中可以看到它的身影，而apparmor被ubuntu维护并默认使用。基本上这两种强制访问控制机制是当前Linux系统中使用最为广泛的。grsecurity没有使用LSM框架，而是对应kernel upstream的不同主流版本发布不同的patch。部署起来没有系统默认安装的selinux、apparmor那么方便，但存在即有意义。grsecurity发展有13年之久，这么多年为什么一直都没有进入内核，以及它与selinux、apparmor相比有什么差别，此次暂不评述。不可否认的是由于grsecurity实现时超出LSM框架，所以实现了很多其他强制访问控制机制所不能、或很难实现的功能，本系列文章分别描述，如有不周，请大家批评指正。 grsecurity官网上从Memroy Corruption defenses、Filesystem Hardening、Miscellaneous Protections、RBAC、GCC Plugins几个方面描述其特性，之后做详尽描述。
安装 从http://grsecurity.net/download.php可以看到当前稳定版本所对应的内核版本。下载对应的内核版本及grsecurity的patch。本处使用linux-3.2.64内核版本及grsecurity-3.0-3.2.64-201411150025.patch 补丁。``` #tar xf linux-3.2.64.tar.xz #cd linux-3.2.64 #patch -p1 &amp;lt; ../grsecurity-3.0-3.2.64-201411150025.patch #make menuconfig #make DISABLE_PAX_PLUGINS=y -j8 #make DISABLE_PAX_PLUGINS=y -j8 modules #sudo make DISABLE_PAX_PLUGINS=y -j8 modules_install #sudo make DISABLE_PAX_PLUGINS=y -j8 install
1. 由于安装了gcc-&amp;lt;ver&amp;gt;-plugin-dev，还是提示无法找到，因此本次去除该特性； 2. grsecurity的配置在&amp;quot;security options&amp;quot;-&amp;gt;&amp;quot;grsecurity&amp;quot;里面，本次可以使用Automatic配置，之后在做调整 3. \-j8指定并行编译的进程数，可使用CPU数的2倍 之后大家还可以下载、编译安装gradm。 重启~~~ Ok，可以开始体验grsecurity了～</description></item><item><title>CVE-2013-1959内核漏洞原理与本地提权利用代码实现分析</title><link>/posts/cve-2013-1959%e5%86%85%e6%a0%b8%e6%bc%8f%e6%b4%9e%e5%8e%9f%e7%90%86%e4%b8%8e%e6%9c%ac%e5%9c%b0%e6%8f%90%e6%9d%83%e5%88%a9%e7%94%a8%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</link><pubDate>Thu, 17 Apr 2014 11:58:21 +0000</pubDate><guid>/posts/cve-2013-1959%e5%86%85%e6%a0%b8%e6%bc%8f%e6%b4%9e%e5%8e%9f%e7%90%86%e4%b8%8e%e6%9c%ac%e5%9c%b0%e6%8f%90%e6%9d%83%e5%88%a9%e7%94%a8%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90/</guid><description>关键字：CVE-2013-1959，cve，kernel vulnerability，内核漏洞，POC，利用代码，本地提权，exploit， analysis,user namespace,capabilities 2013年4月28日，Andy Lutomirski在oss-security披露了该cve的细节。CVE-2013-1959是当前内核稳定版本安全补丁修复所对应的一个CVE。这个CVE的原因是在user namespace中，/proc/uid_map存多个不正确的权限检查。如果启用相关的配置，Linux 3.8和很多3.9rcs将受到影响。利用者可以获取root权限。 修复这个CVE对应的有3个patch，以下先大致介绍这三个Patch所修改的内容。 Patch1：Add file_ns_capable() helper function for open-time capability checking``` From 935d8aabd4331f47a89c3e1daa5779d23cf244ee Mon Sep 17 00:00:00 2001 From: Linus Torvalds torvalds@linux-foundation.org Date: Sun, 14 Apr 2013 10:06:31 -0700 Subject: [PATCH] Add file_ns_capable() helper function for open-time capability checking
Nothing is using it yet, but this will allow us to delay the open-time checks to use time, without breaking the normal UNIX permission semantics where permissions are determined by the opener (and the file descriptor can then be passed to a different process, or the process can drop capabilities).</description></item><item><title>SELinux中核外应用查询策略API总结</title><link>/posts/selinux%e4%b8%ad%e6%a0%b8%e5%a4%96%e5%ba%94%e7%94%a8%e6%9f%a5%e8%af%a2%e7%ad%96%e7%95%a5api%e6%80%bb%e7%bb%93/</link><pubDate>Wed, 19 Feb 2014 15:23:31 +0000</pubDate><guid>/posts/selinux%e4%b8%ad%e6%a0%b8%e5%a4%96%e5%ba%94%e7%94%a8%e6%9f%a5%e8%af%a2%e7%ad%96%e7%95%a5api%e6%80%bb%e7%bb%93/</guid><description>SELinux中支持应用使用libselinux库来针对SELinux进行安全扩展（selinux aware application)，这样应用就可以使用SELinux的策略库来实现内部的访问控制，当前的passwd、dbus、udev等都使用selinux进行了扩展。其中passwd使用selinux进行密码修改检查，dbus对收、发进行了权限检查，分成了：acquire_svc和send_msg。 SELinux提供给用户空间的用户计算策略是否允许的接口主要有2类：selinux_check_access和avc_has_perm，下面对这两类接口进行说明。 selinux_check_access的函数原型为：
int selinux_check_access(const security_context_t scon, const security_context_t tcon, const char *class, const char *perm, void *audit‐ data);
需要输入的为主体、客体、客体类、权限集的字符串表示。 avc_has_perm的函数原型为：
int avc_has_perm(security_id_t ssid, security_id_t tsid, security_class_t tclass, access_vector_t requested, struct avc_entry_ref *aeref, void *auditdata);
需要输入的为主体、客体、客体类、权限集对应的id号，因此需要在使用以前将安全上下文与id号进行映射。在/usr/include/selinux/flask.h和/usr/include/selinux/av_permissions.h对客体类和权限集进行了定义，但是如果使用头文件中的编号，就导致应用与默认的refpolicy的编号顺序必须保持一致，否则容易导致编号与实际内容产生冲突。SELinux的开发者创建了selinux_set_mapping函数来动态建立客体类和权限集的映射关系。
int selinux_set_mapping(struct security_class_mapping *map); struct security_class_mapping { const char *name; const char *perms[]; };
例如：
static struct security_class_mapping dbus_map[] = { { &amp;ldquo;dbus&amp;rdquo;, { &amp;ldquo;acquire_svc&amp;rdquo;, &amp;ldquo;send_msg&amp;rdquo;, NULL } }, { NULL } }; #define DBUS__ACQUIRE_SVC 1 #define DBUS__SEND_MSG 2</description></item><item><title>SELinux策略约束（constrain）里的L与H</title><link>/posts/selinux%e7%ad%96%e7%95%a5%e9%87%8c%e7%9a%84l%e4%b8%8eh/</link><pubDate>Mon, 20 Jan 2014 06:57:10 +0000</pubDate><guid>/posts/selinux%e7%ad%96%e7%95%a5%e9%87%8c%e7%9a%84l%e4%b8%8eh/</guid><description>在SELinux里，除了使用TE（type enforcement）来实现强制访问控制，还可以使用MLS机制的MCS或MLS。 MCS是single-sensitivity的安全机制，通过不同的categories来实现控制效果。 MCS的控制规则只能在base策略里面实现，如果想要修改refpolicy里的默认控制规则，可以修改策略里的mcs文件。MCS的基础内容如下：
mlsconstrain dir { search read ioctl lock } (( h1 dom h2 ) or ( t1 != mcs_constrained_type )); mlsconstrain dir { write setattr append unlink link rename add_name remove_name } (( h1 dom h2 ) or ( t1 != mcs_constrained_type ));
里面的mlsconstrain是约束语法，dir{search &amp;hellip;.}是对应的客体类和权限集。后面的就是MCS约束的定义。分为T、L、H{1/2}，分别表示类型（type），低安全集（L）和高安全集（H），之后的1，或2描述该表达式所限定的主体与客体，即L1表示主体的低安全级，如果上下文system_u:system_r:httpd_t:s0-s0:c0.c1024中，L1就是s0。 在selinux里面，看上面MCS对dir的约束定义，大家可能会有一个疑虑，selinux都是默认对当前级别（low level）进行判断，策略里面怎么是对high level进行判断。 看了下selinux的内核代码才知道缘由。 在selinux进行inode_doinit_with_dentry的时候，security_context_to_sid_default会到用到mls_context_to_sid对mls部分的上下文进行处理。该函数后部分有如下代码
if (l == 0) { context-&amp;gt;range.level[1].sens = context-&amp;gt;range.level[0].sens; rc = ebitmap_cpy(&amp;amp;context-&amp;gt;range.level[1].cat, &amp;amp;context-&amp;gt;range.level[0].cat); if (rc) goto out; }</description></item><item><title>Apparmor的前世今生</title><link>/posts/apparmor%e7%9a%84%e5%89%8d%e4%b8%96%e4%bb%8a%e7%94%9f/</link><pubDate>Wed, 01 Jan 2014 14:51:44 +0000</pubDate><guid>/posts/apparmor%e7%9a%84%e5%89%8d%e4%b8%96%e4%bb%8a%e7%94%9f/</guid><description>Apparmor是linux下安全机制的一种，使用LSM（Linux security modules），在2.6.36进入内核。以下介绍下Apparmor项目的发展历程。 1998～2003时，Apparmor在Immunix Linux中使用，当时名称是Subdomain。2005年5月10日，Immunix作为Novell的长期合作伙伴，被Novell收购，其中Apparmor是Novell的主要关注重点，而且被命名为Novell Apparmor。从2005年到2007年9月由Novell进行维护。2007年4月，Ubuntu进入Apparmor，进入Ubuntu 7.10包，作为Ubuntu8.04的一部分发布。 2007年9月，Novell将维护Apparmor的团队解散了。而Suse也在OpenSUSE11.1中引入了对SELinux的支持。作为Apparmor的founder和leader，Crispin Cowan和其他四个同事丢掉了在Novell的工作，当时Crispin表示会继续Apparmor的开发，他和其他2个同事Steve Beattie和Dominic Reynolds开办了Mercenary Linux公司，专注于Apparmor咨询工作。好景不长，2008年8月，有人发出了Apparmor is Dead的博文，引发讨论。随后 Crispin Cowan也在2008年加入了Windows Security Team。 从2009年开始，Canonical开始开发apparmor。现在的Maintainer是John Johansen john.johansen@canonical.com 参考资料： 1、blogs.msdn.com/b/michael_howard/archive/2008/01/17/crispin-cowan-joins-the-windows-security-team.aspx 2、en.wikipedia.org/wiki/Immunix 3、news.cnet.com/8301-13580_3-9796140-39.html 4、etbe.coker.com.au/2008/08/23/apparmor-is-dead/ 5、http://en.wikipedia.org/wiki/AppArmor</description></item><item><title>【zz】linux内核e820来源及相关知识</title><link>/posts/zz_linux_kernel_sources_and_relevant_knowledge_e820/</link><pubDate>Wed, 16 Oct 2013 16:57:00 +0000</pubDate><guid>/posts/zz_linux_kernel_sources_and_relevant_knowledge_e820/</guid><description>http://hi.baidu.com/ballmillsap/item/c2f3cf6f43d3220aa1cf0fe4e820简介操作系统内存布局中断 int 0x15e820简介 收藏本文系转载，原文地址：http://wangcong.org/blog/?p=320，其中附录部分 为本人所加&amp;hellip; e820是和BIOS的一个中断相关的，具体说是int 0x15。之所以叫e820是因为在用这个中断时ax必须是0xe820。这个中断的作用是得到系统的内存布局。因为系统内存会有很多段，每段的类型属性 也不一样，所以这个查询是“迭代式”的，每次求得一个段。 我们看内核源代码。主要涉及两个文件：arch/x86/boot/memory.c和arch/x86/kernel /e820_32.c。我们 已经很幸运了，这部分代码已经用C重写过了。你可能会奇怪，启动调用e820时我们还在实模式，怎么能用C呢？答案是，这里用的是16位的C。gcc早已 经支持.code16 gcc模式了。 看detect_memory_e820()函数，里面就是e820的本质。它把int 0x15放到一个do-while循环里，每次得到的一个内存段放到struct e820entry里，而struct e820entry的结构正是e820返回结果的结构！而像其它启动时获得的结果一样，最终都会被放到boot_params里，e820被放到了 boot_params.e820_map。如果你对struct e820entry还有疑问，你可以看一下arch/x86/kernel/e820_32.c::print_memory_map()，看看里面是怎 么使用它的。 当然了，在arch/x86/boot/memory.c里，你还会看到另外两个利用int 0x15查询内存的函数，不过用途不一样了。附：boot_params 结构体定义，其中E820MAX 定义为128:struct e820entry {__u64 addr; /* start of memory segment */__u64 size; /* size of memory segment */__u32 type; /* type of memory segment */} __attribute__((packed));struct boot_params { struct screen_info screen_info; /* 0x000 */ struct apm_bios_info apm_bios_info; /* 0x040 */ __u8 _pad2[12]; /* 0x054 */ struct ist_info ist_info; /* 0x060 */ __u8 _pad3[16]; /* 0x070 */ __u8 hd0_info[16]; /* obsolete!</description></item><item><title>[zz] linux常见发行版和kernel版本对应关系</title><link>/posts/zz_linux_kernel_version_releases_and_common_correspondence_between/</link><pubDate>Sat, 12 Oct 2013 04:43:00 +0000</pubDate><guid>/posts/zz_linux_kernel_version_releases_and_common_correspondence_between/</guid><description>linux常见发行版和kernel版本对应关系 2010-06-22 13:47:08分类： LINUXDebian 5.04 2.6.26Fedora 62.6.18Fedora 82.6.23Fedora 92.6.25Fedora 102.6.27Fedora 112.6.29Fedora 122.6.31mandriva 20102.6.31openSUSE 10.32.6.22suse 10.12.6.16suse 11.22.6.31redhat Enter 4.32.6.9redhat 9.02.4.20redhat Enter 5.42.6.18ubuntu 8.042.6.24ubuntu 9.042.6.28ubuntu 9.102.6.31</description></item><item><title>[zz]Linus大神又怒了 我为什么要说“又”？</title><link>/posts/zz_linus_great_god_angry_why_i_say_the_quotandquot/</link><pubDate>Wed, 26 Dec 2012 11:32:00 +0000</pubDate><guid>/posts/zz_linus_great_god_angry_why_i_say_the_quotandquot/</guid><description>Linus大神实乃性情中人，口无遮拦。继称OpenBSD开发者是一帮自慰的猴子、 调侃digg用户是“手淫的海象”、以及 对 Nvidia 比中指爆粗 后，又有不懂事的人惹大神发怒了。这回是由在于Linus认为Mauro违反了内核维护的基本原则。他的原话很好理解：Linus大神实乃性情中人，口无遮拦。继称OpenBSD开发者是一帮自慰的猴子、 调侃digg用户是“手淫的海象”、以及 对 Nvidia 比中指爆粗 后，又有不懂事的人惹大神发怒了。闭上你的臭嘴，Mauro！这明显是一个bug，Kernel中的bug！你做了多长时间的维护人员了，为什么还不明白Kernel维护的第一原则？如果修改会导致用户程序的破坏，那问题一定是在Kernel上！永远不可以归咎用户程序的责任，学会这点真的很难吗？更糟糕的是，commit f0ed2ce840b3虽然并没有破坏程序，但它完全是废话。……永远不可以破坏USERSPACE！或许有人觉得Linus的批评太过严厉，但这也正反映出他对Kernel设计、维护原则的坚持，如果没有这种信念，相信Linux很难有今天的地位。希望各位程序员引以为戒！http://thread.gmane.org/gmane.linux.kernel/1413835/focus=1414106From: Linus Torvalds &amp;lt;torvalds linux-foundation.org&amp;gt; Subject: Re: [Regression w/ patch] Media commit causes user space to misbahave (was: Re: Linux 3.8-rc1) Newsgroups: gmane.linux.kernel Date: 2012-12-23 17:36:15 GMT (1 day, 17 hours and 45 minutes ago) On Sun, Dec 23, 2012 at 6:08 AM, Mauro Carvalho Chehab &amp;lt;mchehab redhat.com&amp;gt; wrote: &amp;gt; &amp;gt; Are you saying that pulseaudio is entering on some weird loop if the &amp;gt; returned value is not -EINVAL?</description></item></channel></rss>