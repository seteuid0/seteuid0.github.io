<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gui on seteuid0's blog</title><link>/tags/gui/</link><description>Recent content in gui on seteuid0's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This is a customized copyright.</copyright><lastBuildDate>Tue, 27 Feb 2018 12:19:05 +0000</lastBuildDate><atom:link href="/tags/gui/index.xml" rel="self" type="application/rss+xml"/><item><title>[转]linux图形显示相关内容</title><link>/posts/%e8%bd%aclinux%e5%9b%be%e5%bd%a2%e6%98%be%e7%a4%ba%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9/</link><pubDate>Tue, 27 Feb 2018 12:19:05 +0000</pubDate><guid>/posts/%e8%bd%aclinux%e5%9b%be%e5%bd%a2%e6%98%be%e7%a4%ba%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9/</guid><description>1. 前言 图形子系统是linux系统中比较复杂的子系统之一：对下，它要管理形态各异的、性能各异的显示相关的器件；对上，它要向应用程序提供易用的、友好的、功能强大的图形用户界面（GUI）。因此，它是linux系统中少有的、和用户空间程序（甚至是用户）息息相关的一个子系统。 本文是图形子系统分析文章的第一篇，也是提纲挈领的一篇，将会从整体上，对linux显示子系统做一个简单的概述，进而罗列出显示子系统的软件构成，后续的文章将会围绕这些软件一一展开分析。 注1：本文所有的描述将以原生linux系统为例（如Ubuntu、Debian等），对其它基于linux的系统（如Android），部分内容会不适用。 注2：本文很多图片都是从网上搜集而来的（很多是从维基百科）。虽然蜗窝的宗旨是用自己的语言表述，尽量自己画图，但是linux图形子系统太复杂了，蜗蜗的理解有限，而老外的图画的实在太好，蜗蜗觉得，再怎么努力，也画不出更好的了，因此本着为读者负责的态度，就直接copy了。
2. 概念介绍 2.1 GUI（Graphical User Interface，图形用户界面） linux图形子系统的本质，是提供图形化的人机交互（human-computer interaction）界面，也即常说的GUI（Graphical User Interface）。而人机交互的本质，是人脑通过人的输出设备（动作、声音等），控制电脑的输入设备，电脑经过一系列的处理后，经由电脑的输出设备将结果输出，人脑再通过人的输入设备接收电脑的输出，最终实现“人脑&amp;lt;&amp;ndash;&amp;gt;电脑”之间的人机交互。下面一幅摘自维基百科的图片（可从“这里”查看比较清晰的SVG格式的原始图片），对上述过程做了很好的总结：
该图以一个非常前卫的应用场景&amp;mdash;-虚拟现实（VR，Virtual Reality）游戏，说明了以图形化为主的人机交互过程： 1）人脑通过动作、声音（对人脑而言，是output），控制电脑的输入设备，包括键盘、鼠标、操作杆、麦克风、游戏手柄（包含加速度计、陀螺仪等传感器）。 2）电脑通过输入设备，接收人脑的指令，这些指令经过kernel Input subsystem、Middleware Gesture/Speech recognition等软件的处理，转换成应用程序（Game）可以识别的、有意义的信息。 3）应用程序（Game）根据输入信息，做出相应的反馈，主要包括图像和声音。对VR游戏而言，可能需要3D rendering，这可以借助openGL及其相应的用户空间driver实现。 4）应用程序的反馈，经由kernel的Video subsystem（如DRM/KMS）、audio subsystem（如ALSA），输出到电脑的输出设备上，包括显示设备（2D/3D）、扬声器/耳机（3D Positional Audio）、游戏手柄（力的反馈）等。 5）输出到显示设备上时，可能会经过图形加速模块（Graphics accelerator）。 注3：图中提到了VR场景的典型帧率（1280×800@95fps for VR），这是一个非常庞大的信息输出，要求图形子系统能10.5ms的时间内，生成并输出一帧，以RGBA的数据格式为例，每秒需要处理的数据量是1280x800x95x4x8=3.11296Gb，压力和挑战是相当大的（更不用提1080P了）。
有关GUI更为详细的解释，请参考：https://en.wikipedia.org/wiki/Graphical_user_interface。
2.2 Windowing system（窗口系统） 窗口系统，是GUI的一种（也是当前计算机设备、智能设备广泛使用的一种），以WIMP （windows、icons、menus、pointer) 的形式，提供人机交互接口。Linux系统中有很多窗口系统的实现，如X Window System、Wayland、Android SurfaceFlinger等，虽然形态各异，但思路大致相同，包含如下要点：
1）一般都使用client-server架构，server（称作display server，或者windows server、compositor等等）管理所有输入设备，以及用于输出的显示设备。 2）应用程序作为display server的一个client，在自己窗口（window）中运行，并绘制自己的GUI。 3）client的绘图请求，都会提交给display server，display server响应并处理这些请求，以一定的规则混合、叠加，最终在有限的输出资源上（屏幕），显示多个应用程序的GUI。 3）display server和自己的client之间，通过某种类型的通信协议交互，该通信协议通常称作display server protocol。 4）display server protocol可以是基于网络的，甚至是网络透明的（network transparent），如X Window System所使用的。也可以是其它类型的，如Android SurfaceFlinger所使用的binder。
有关Windowing system的详细解释，请参考：https://en.</description></item></channel></rss>