<!doctype html><html><head><title>[ZZ]v4l2的学习建议和流程解析</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:title" content="[ZZ]v4l2的学习建议和流程解析"><meta property="og:description" content="最近设计摄像头相关工作，之前虽然断断续续对V4L有些了解但不系统，在网上搜索了下发现V4L2应用还是非常广泛，所以资料也非常多，转载一片整理"><meta property="og:type" content="article"><meta property="og:url" content="/posts/zzv4l2%e7%9a%84%e5%ad%a6%e4%b9%a0%e5%bb%ba%e8%ae%ae%e5%92%8c%e6%b5%81%e7%a8%8b%e8%a7%a3%e6%9e%90/"><meta property="article:published_time" content="2019-08-20T13:28:31+00:00"><meta property="article:modified_time" content="2019-08-20T13:28:31+00:00"><meta property="og:site_name" content="My Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="[ZZ]v4l2的学习建议和流程解析"><meta name=twitter:description content="最近设计摄像头相关工作，之前虽然断断续续对V4L有些了解但不系统，在网上搜索了下发现V4L2应用还是非常广泛，所以资料也非常多，转载一片整理"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=/scss/journal.min.5e8f3f653e9f6ce67bf72ff8ee6fee69decf7b5639a3ae7f8344750ad4e065b1.css integrity="sha256-Xo8/ZT6fbOZ79y/47m/uad7Pe1Y5o65/g0R1CtTgZbE=" media=screen><link rel=stylesheet href=/scss/dark-mode.min.bdfa63b2e89903517dcbb1032b537d54cff3f425c19d008a78dfe49e6cd07ced.css integrity="sha256-vfpjsuiZA1F9y7EDK1N9VM/z9CXBnQCKeN/knmzQfO0=" media=screen><script src=//js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script><script src=//js/toc-collapse.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=/vendor/js/md5.min.js></script><script>var gitalk=new Gitalk({clientID:'your client id',clientSecret:'your client secret',repo:'repo name',owner:'user',admin:['user'],id:md5(location.pathname),distractionFreeMode:'false'});window.onload=function(){gitalk.render('gitalk-container')}</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=/><div class=nav-title>seteuid0's blog</div><div class=nav-subtitle>Themed by Diary.</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>Archive</a>
<a class="a-block nav-link-item false" href=/categories>Categories</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a>
<a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer><a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> <a href=https://amazingrise.net>Rise</a><br><a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
This is a customized copyright.</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- -</center><ul><ul class=collapse data-toggle=collapse><li><a href=#%e4%b8%80video-for-linux-two onclick="onNavClick(`#一video-for-linux-two-nav`)" id=一video-for-linux-two-nav>一、Video for Linux two</a></li><li><a href=#%e4%ba%8cv4l2%e7%bb%93%e6%9e%84%e4%bd%93%e4%bb%8b%e7%bb%8d onclick="onNavClick(`#二v4l2结构体介绍-nav`)" id=二v4l2结构体介绍-nav>二、v4l2结构体介绍</a></li><li><a href=#%e4%b8%89%e8%b0%83%e7%94%a8v4l2%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b onclick="onNavClick(`#三调用v4l2的工作流程-nav`)" id=三调用v4l2的工作流程-nav>三、调用v4l2的工作流程</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>Archive</a>
<a class="a-block drawer-menu-item false" href=/categories>Categories</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a>
<a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- -</center><ul><ul class=collapse data-toggle=collapse><li><a href=#%e4%b8%80video-for-linux-two onclick="onNavClick(`#一video-for-linux-two-nav`)" id=一video-for-linux-two-nav>一、Video for Linux two</a></li><li><a href=#%e4%ba%8cv4l2%e7%bb%93%e6%9e%84%e4%bd%93%e4%bb%8b%e7%bb%8d onclick="onNavClick(`#二v4l2结构体介绍-nav`)" id=二v4l2结构体介绍-nav>二、v4l2结构体介绍</a></li><li><a href=#%e4%b8%89%e8%b0%83%e7%94%a8v4l2%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b onclick="onNavClick(`#三调用v4l2的工作流程-nav`)" id=三调用v4l2的工作流程-nav>三、调用v4l2的工作流程</a></li></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=/>seteuid0's blog</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/><div class=single-column-header-title>seteuid0's blog</div><div class=single-column-header-subtitle>Themed by Diary.</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>[ZZ]v4l2的学习建议和流程解析<div class=post-meta><time itemprop=datePublished></time><i class=material-icons>label</i>
<a href=/tags/camera>camera</a>
&nbsp;
<a href=/tags/ioctl>ioctl</a>
&nbsp;
<a href=/tags/linux>linux</a>
&nbsp;
<a href=/tags/linux>linux</a>
&nbsp;
<a href=/tags/v4l2>v4l2</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><p>最近设计摄像头相关工作，之前虽然断断续续对V4L有些了解但不系统，在网上搜索了下发现V4L2应用还是非常广泛，所以资料也非常多，转载一片整理的比较全面的，就不重复造轮子了。 原文地址：https://www.cnblogs.com/silence-hust/p/4464291.html v4l2，一开始听到这个名词的时候，以为又是一个很难很难的模块，涉及到视频的处理，后来在网上各种找资料后，才发现其实v4l2已经分装好了驱动程序，只要我们根据需要调用相应的接口和函数，从而实现视频的获取和处理。只要认真的看几篇文章就对v4l2有一定的了解了，由于是第一次接触，网上的资料良莠不齐，难得可以找到几篇自己感觉很不错的。记录下来：（没必要看太多，很多都是一样的意思） <a href=http://www.embedu.org/Column/Column320.htm>http://www.embedu.org/Column/Column320.htm</a>   <strong>这篇是不错的介绍，很讨厌有弹窗</strong> <a href=http://www.cnblogs.com/emouse/archive/2013/03/04/2943243.html>http://www.cnblogs.com/emouse/archive/2013/03/04/2943243.html</a>  <strong>这个可以作为第一篇来看，博主整理的不错</strong> <a href=http://blog.chinaunix.net/uid-11765716-id-2855735.html>http://blog.chinaunix.net/uid-11765716-id-2855735.html</a>    <strong>这篇也比较详细</strong> <a href=http://blog.csdn.net/ddddwant/article/details/8475211>http://blog.csdn.net/ddddwant/article/details/8475211</a>   <strong>这篇提到的问题和我遇到的一样，花屏了，内存没有读取好</strong> <a href=http://my.oschina.net/u/1024767/blog/210801#OSC_h2_14>http://my.oschina.net/u/1024767/blog/210801#OSC_h2_14</a>    <strong>对capture.c文件的解读</strong> <a href=http://blog.csdn.net/g_salamander/article/details/8107692>http://blog.csdn.net/g_salamander/article/details/8107692</a>    <strong>对各个结构体有比较好的说明</strong>  </p><h2 id=一video-for-linux-two><strong>一、Video for Linux two</strong></h2><p>v4l2为linux下视频设备程序提供了一套接口规范。包括一套数据结构和底层V4L2驱动接口。只能在linux下使用。它使程序有发现设备和操作设备的能力。它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。当然也可以用于其他多媒体的开发，如音频等。 在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文是/dev/v4l/video0。为了通用，可以建立一个到/dev/video0的链接。V4L2支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)。V4L2在include/linux/videodev.h文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。V4L2从Linux 2.5.x版本的内核中开始出现。</p><p>　　V4L2规范中不仅定义了通用API元素(Common API Elements)，图像的格式(Image Formats)，输入/输出方法(Input/Output)，还定义了Linux内核驱动处理视频信息的一系列接口(Interfaces)，这些接口主要有：</p><p>　　视频采集接口——Video Capture Interface; 视频输出接口—— Video Output Interface; 视频覆盖/预览接口——Video Overlay Interface; 视频输出覆盖接口——Video Output Overlay Interface; 编解码接口——Codec Interface。</p><h2 id=二v4l2结构体介绍>二、v4l2结构体介绍</h2><p>1、常用的结构体在内核目录include/linux/videodev2.h中定义</p><p>        struct v4l2_requestbuffers        //申请帧缓冲，对应命令VIDIOC_REQBUFS struct v4l2_capability        //视频设备的功能，对应命令VIDIOC_QUERYCAP struct v4l2_input        //视频输入信息，对应命令VIDIOC_ENUMINPUT struct v4l2_standard        //视频的制式，比如PAL，NTSC，对应命令VIDIOC_ENUMSTD struct v4l2_format        //帧的格式，对应命令VIDIOC_G_FMT、VIDIOC_S_FMT等 struct v4l2_buffer        //驱动中的一帧图像缓存，对应命令VIDIOC_QUERYBUF struct v4l2_crop        //视频信号矩形边框 v4l2_std_id        //视频制式</p><p>常用结构体的内容：</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p><code>struct</code> <code>v4l2_capability</code></p><p><code>{</code></p><p><code>u8 driver[16]; ``// 驱动名字</code></p><p><code>u8 card[32]; ``// 设备名字</code></p><p><code>u8 bus_info[32]; ``// 设备在系统中的位置</code></p><p><code>u32 version; ``// 驱动版本号</code></p><p><code>u32 capabilities; ``// 设备支持的操作</code></p><p><code>u32 reserved[4]; ``// 保留字段</code></p><p><code>};</code></p><p>其中域 capabilities 代表设备支持的操作模式，常见的值有 V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING 表示是一个视频捕捉设备并且具有数据流控制模式；另外 driver 域需要和 struct video_device 中的 name 匹配。</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p><code>struct</code> <code>v4l2_format { </code></p><p><code>enum</code> <code>v4l2_buf_type type; </code></p><p><code>union</code> <code>{ </code></p><p><code>struct</code> <code>v4l2_pix_format         pix;     ``/* V4L2_BUF_TYPE_VIDEO_CAPTURE */</code></p><p><code>struct</code> <code>v4l2_window             win;     ``/* V4L2_BUF_TYPE_VIDEO_OVERLAY */</code></p><p><code>struct</code> <code>v4l2_vbi_format         vbi;     ``/* V4L2_BUF_TYPE_VBI_CAPTURE */</code></p><p><code>struct</code> <code>v4l2_sliced_vbi_format  sliced;  ``/* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */</code></p><p><code>__u8   raw_data[200];                   ``/* user-defined */</code></p><p><code>} fmt; </code></p><p><code>}; </code></p><p><code>enum</code> <code>v4l2_buf_type { </code></p><p><code>V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1, </code></p><p><code>V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2, </code></p><p><code>V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3, </code></p><p><code>... </code></p><p><code>V4L2_BUF_TYPE_PRIVATE              = 0x80, </code></p><p><code>}; </code></p><p><code>struct</code> <code>v4l2_pix_format { </code></p><p><code>__u32                   width; </code></p><p><code>__u32                   height; </code></p><p><code>__u32                   pixelformat; </code></p><p><code>enum</code> <code>v4l2_field         field; </code></p><p><code>__u32                   bytesperline;   ``/* for padding, zero if unused */</code></p><p><code>__u32                   sizeimage; </code></p><p><code>enum</code> <code>v4l2_colorspace    colorspace; </code></p><p><code>__u32                   priv;           ``/* private data, depends on pixelformat */</code></p><p><code>};</code></p><p>常见的捕获模式为 V4L2_BUF_TYPE_VIDEO_CAPTURE 即视频捕捉模式，在此模式下 fmt 联合体采用域 v4l2_pix_format：其中 width 为视频的宽、height 为视频的高、pixelformat 为视频数据格式（常见的值有 V4L2_PIX_FMT_YUV422P | V4L2_PIX_FMT_RGB565）、bytesperline 为一行图像占用的字节数、sizeimage 则为图像占用的总字节数、colorspace 指定设备的颜色空间。   struct v4l2_requestbuffers 与 VIDIOC_REQBUFS ，VIDIOC_REQBUFS 命令通过结构 v4l2_requestbuffers 请求驱动申请一片连续的内存用于缓存视频信息：</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p><code>struct</code> <code>v4l2_requestbuffers {</code></p><p><code>__u32                   count;</code></p><p><code>enum</code> <code>v4l2_buf_type      type;</code></p><p><code>enum</code> <code>v4l2_memory        memory;</code></p><p><code>__u32                   reserved[2];</code></p><p><code>};</code></p><p><code>enum</code> <code>v4l2_memory {</code></p><p><code>V4L2_MEMORY_MMAP             = 1,</code></p><p><code>V4L2_MEMORY_USERPTR          = 2,</code></p><p><code>V4L2_MEMORY_OVERLAY          = 3,</code></p><p><code>};</code></p><p>count 指定根据图像占用空间大小申请的缓存区个数，type 为视频捕获模式，memory 为内存区的使用方式。</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p><code>struct</code> <code>v4l2_buffer {</code></p><p><code>__u32   index;</code></p><p><code>enum</code> <code>v4l2_buf_type    type;</code></p><p><code>__u32    bytesused;</code></p><p><code>__u32    flags;</code></p><p><code>enum</code> <code>v4l2_field  field;</code></p><p><code>struct</code> <code>timeval    timestamp;</code></p><p><code>struct</code> <code>v4l2_timecode   timecode;</code></p><p><code>__u32     sequence;</code></p><p><code>/* memory location */</code></p><p><code>enum</code> <code>v4l2_memory    memory;</code></p><p><code>union</code> <code>{</code></p><p><code>__u32   offset;</code></p><p><code>unsigned ``long</code>   <code>userptr;</code></p><p><code>} m;</code></p><p><code>__u32    length;</code></p><p><code>__u32    input;</code></p><p><code>__u32    reserved;</code></p><p><code>};</code></p><p>index 为缓存编号 type 为视频捕获模式 bytesused 为缓存已使用空间大小 flags 为缓存当前状态（常见值有 V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE，分别代表当前缓存已经映射、缓存可以采集数据、缓存可以提取数据） timestamp 为时间戳 sequence为缓存序号 memory 为缓存使用方式 offset 为当前缓存与内存区起始地址的偏移 length 为缓存大小 reserved 一般用于传递物理地址值。 另外 VIDIOC_QBUF 和 VIDIOC_DQBUF 命令都采用结构 v4l2_buffer 与驱动通信：VIDIOC_QBUF 命令向驱动传递应用程序已经处理完的缓存，即将缓存加入空闲可捕获视频的队列，传递的主要参数为 index；VIDIOC_DQBUF 命令向驱动获取已经存放有视频数据的缓存，v4l2_buffer 的各个域几乎都会被更新，但主要的参数也是 index，应用程序会根据 index 确定可用数据的起始地址和范围。  </p><p>2、常用的IOCTL接口命令也在include/linux/videodev2.h中定义</p><p>VIDIOC_REQBUFS //分配内存 VIDIOC_QUERYBUF         //把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址 VIDIOC_QUERYCAP        //查询驱动功能 VIDIOC_ENUM_FMT        //获取当前驱动支持的视频格式 VIDIOC_S_FMT        //设置当前驱动的频捕获格式 VIDIOC_G_FMT        //读取当前驱动的频捕获格式 VIDIOC_TRY_FMT        //验证当前驱动的显示格式 VIDIOC_CROPCAP        //查询驱动的修剪能力 VIDIOC_S_CROP        //设置视频信号的矩形边框 VIDIOC_G_CROP        //读取视频信号的矩形边框 VIDIOC_QBUF        //把数据从缓存中读取出来 VIDIOC_DQBUF        //把数据放回缓存队列 VIDIOC_STREAMON        //开始视频显示函数 VIDIOC_STREAMOFF        //结束视频显示函数 VIDIOC_QUERYSTD         //检查当前视频设备支持的标准，例如PAL或NTSC。</p><h2 id=三调用v4l2的工作流程>三、调用v4l2的工作流程</h2><p>　　打开设备－> 检查和设置设备属性－> 设置帧格式－> 设置一种输入输出方法（缓冲 区管理）－> 循环获取数据－> 关闭设备。</p><p><strong>（1）打开设备文件</strong></p><p>　　打开视频设备非常简单，在V4L2中，视频设备被看做一个文件。使用open函数打开这个设备： 1. 用非阻塞模式打开摄像头设备 int cameraFd; cameraFd = open("/dev/video0", O_RDWR | O_NONBLOCK); 2. 如果用阻塞模式打开摄像头设备，上述代码变为： cameraFd = open("/dev/video0", O_RDWR); 关于阻塞模式和非阻塞模式 应用程序能够使用阻塞模式或非阻塞模式打开视频设备，如果使用非阻塞模式调用视频设备，即使尚未捕获到信息，驱动依旧会把缓存（DQBUFF）里的东西返回给应用程序。</p><p><strong>（2）取得设备的capability</strong></p><p>          struct v4l2_capability capability； int ret = ioctl(fd, VIDIOC_QUERYCAP, &capability);</p><p>　　看看设备具有什么功能，比如是否具有视频输入特性。</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p><code>struct</code> <code>v4l2_capability cap;</code></p><p><code>memset``(&cap, 0, ``sizeof``(cap));</code></p><p><code>/* 获取设备支持的操作 */</code></p><p><code>if``(ioctl(dev->fd, VIDIOC_QUERYCAP, &cap) &lt; 0){</code></p><p><code>if``(EINVAL == ``errno``){   ``/*EINVAL为返回的错误值*/</code></p><p><code>printf``(stderr,``"%s is no V4L2 device\n"``, dev->dev);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p><code>else</code></p><p><code>{</code></p><p><code>printf``(stderr,``"%s is not V4L2 device,unknow error\n"``, dev->dev);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p><code>}</code></p><p><code>//获取成功，检查是否有视频捕获功能</code></p><p><code>if``(!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)){</code></p><p><code>printf``(stderr, ``"%s is no video capture device\n"``,dev->dev);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p><code>/* streaming I/O ioctls */</code></p><p><code>if``(!(cap.capabilities & V4L2_CAP_STREAMING)){</code></p><p><code>printf``(stderr, ``"%s does not support streaming i/o\n"``,dev->dev);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p><strong>（3）选择视频输入</strong> struct v4l2_input input； ……初始化input int ret = ioctl(fd, VIDIOC_QUERYCAP, &input); 一个视频设备可以有多个视频输入。如果只有一路输入，这个功能可以没有。 VIDIOC_G_INPUT 和 VIDIOC_S_INPUT 用来查询和选则当前的 input，一个 video 设备节点可能对应多个视频源，比如 saf7113 可以最多支持四路 cvbs 输入，如果上层想在四个cvbs视频输入间切换，那么就要调用 ioctl(fd, VIDIOC_S_INPUT, &input) 来切换。VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的 video input和output的index.</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p><code>struct</code> <code>v4l2_input {</code></p><p><code>__u32 index; ``/* Which input *</code></p><p><code>/__u8 name[32]; /* Label */</code></p><p><code>__u32 type; ``/* Type of input */</code></p><p><code>__u32 audioset; ``/* Associated audios (bitfield) */</code></p><p><code>__u32 tuner; ``/* Associated tuner */</code></p><p><code>v4l2_std_id std;</code></p><p><code>__u32 status;</code></p><p><code>__u32 reserved[4];</code></p><p><code>};</code></p><p><strong>（4）检测视频支持的制式</strong> v4l2_std_id std; do { ret = ioctl(fd, VIDIOC_QUERYSTD, &std); } while (ret == -1 && errno == EAGAIN); switch (std) { case V4L2_STD_NTSC: //…… case V4L2_STD_PAL: //…… } <strong>（5）设置视频捕获格式</strong> v4l2_format 结构体用来设置摄像头的视频制式、帧格式等，在设置这个参数时应先填 好 v4l2_format 的各个域，如 type（传输流类型），fmt.pix.width(宽)，fmt.pix.heigth(高)，fmt.pix.field(采样区域，如隔行采样)，fmt.pix.pixelformat(采样类型，如 YUV4:2:2)，然后通过 VIDIO_S_FMT 操作命令设置视频捕捉格式。</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p><code>struct</code> <code>v4l2_format fmt;</code></p><p><code>memset``(&fmt, 0, ``sizeof``(fmt));</code></p><p><code>fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;</code></p><p><code>fmt.fmt.pix.width       = g_display_width;</code></p><p><code>fmt.fmt.pix.height      = g_display_height;</code></p><p><code>fmt.fmt.pix.pixelformat = g_fmt;</code></p><p><code>fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;</code></p><p><code>/* 设置设备捕获视频的格式 */</code></p><p><code>if``(ioctl(dev->fd, VIDIOC_S_FMT, &fmt) &lt; 0)</code></p><p><code>{</code></p><p><code>printf``(stderr, ``"%s iformat not supported \n"``,dev->dev);</code></p><p><code>close(dev->fd);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p>**注意：**如果该视频设备驱动不支持你所设定的图像格式，视频驱动会重新修改struct v4l2_format结构体变量的值为该视频设备所支持的图像格式，所以在程序设计中，设定完所有的视频格式后，要获取实际的视频格式，要重新读取struct v4l2_format结构体变量。 <strong>（6）向驱动申请帧缓存</strong> 一般不超过5个，CAP_BUF_NUM = 4</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p><code>struct</code> <code>v4l2_requestbuffers req;</code></p><p><code>/* 申请设备的缓存区 */</code></p><p><code>memset``(&req, 0, ``sizeof``(req));</code></p><p><code>req.count = CAP_BUF_NUM;  ``//申请一个拥有四个缓冲帧的缓冲区</code></p><p><code>req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</code></p><p><code>req.memory = V4L2_MEMORY_MMAP;</code></p><p><code>if</code> <code>(ioctl(dev->fd, VIDIOC_REQBUFS, &req) &lt; 0)</code></p><p><code>{</code></p><p><code>if</code> <code>(EINVAL == ``errno``)</code></p><p><code>{</code></p><p><code>printf``(stderr, ``"%s does not support "</code></p><p><code>"memory mapping\n"``, dev->dev);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p><code>else</code></p><p><code>{</code></p><p><code>printf``(stderr, ``"%s does not support "</code></p><p><code>"memory mapping, unknow error\n"``, dev->dev);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p><code>}</code></p><p><code>if</code> <code>(req.count &lt; 2)</code></p><p><code>{</code></p><p><code>printf``(stderr, ``"Insufficient buffer memory on %s\n"``,</code></p><p><code>dev->dev);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p>v4l2_requestbuffers结构中定义了缓存的数量，驱动会据此申请对应数量的视频缓存。多个缓存可以用于建立FIFO，来提高视频采集的效率。控制命令VIDIOC_REQBUFS 功能： 请求V4L2驱动分配视频缓冲区（申请V4L2视频驱动分配内存），V4L2是视频设备的驱动层，位于内核空间，所以通过VIDIOC_REQBUFS控制命令字申请的内存位于内核空间，应用程序不能直接访问，需要通过调用mmap内存映射函数把内核空间内存映射到用户空间后，应用程序通过访问用户空间地址来访问内核空间。 参数说明：参数类型为V4L2的申请缓冲区数据结构体类型struct v4l2_requestbuffers  ； 返回值说明： 执行成功时，函数返回值为 0；V4L2驱动层分配好了视频缓冲区； <strong>（7）获取每个缓存的信息，并mmap到用户空间</strong> 应用程序和设备有三种交换数据的方法，直接 read/write、内存映射(memory mapping)和用户指针。这里只讨论内存映射(memory mapping)。</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p><code>typedef</code> <code>struct</code> <code>VideoBuffer {   ``//定义一个结构体来映射每个缓冲帧</code></p><p><code>void</code> <code>*start;</code></p><p><code>size_t</code> <code>length;</code></p><p><code>} VideoBuffer;</code></p><p><code>VideoBuffer* buffers = ``calloc``( req.count, ``sizeof``(*buffers) );</code></p><p><code>struct</code> <code>v4l2_buffer buf;</code></p><p><code>for</code> <code>(numBufs = 0; numBufs &lt; req.count; numBufs++) {``//映射所有的缓存</code></p><p><code>memset``( &buf, 0, ``sizeof``(buf) );</code></p><p><code>buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</code></p><p><code>buf.memory = V4L2_MEMORY_MMAP;</code></p><p><code>buf.index = numBufs;</code></p><p><code>if</code> <code>(ioctl(fd, VIDIOC_QUERYBUF, &buf) == -1) {``//获取到对应index的缓存信息，此处主要利用length信息及offset信息来完成后面的mmap操作。</code></p><p><code>return</code> <code>-1;</code></p><p><code>}</code></p><p><code>buffers[numBufs].length = buf.length;</code></p><p><code>// 转换成相对地址</code></p><p><code>buffers[numBufs].start = mmap(NULL, buf.length,</code></p><p><code>PROT_READ | PROT_WRITE,</code></p><p><code>MAP_SHARED,</code></p><p><code>fd, buf.m.offset);</code></p><p><code>if</code> <code>(buffers[numBufs].start == MAP_FAILED) {</code></p><p><code>return</code> <code>-1;</code></p><p><code>}</code></p><p><code>//addr 映射起始地址，一般为NULL ，让内核自动选择</code></p><p><code>//length 被映射内存块的长度</code></p><p><code>//prot 标志映射后能否被读写，其值为PROT_EXEC,PROT_READ,PROT_WRITE, PROT_NONE</code></p><p><code>//flags 确定此内存映射能否被其他进程共享，MAP_SHARED,MAP_PRIVATE</code></p><p><code>//fd,offset, 确定被映射的内存地址 返回成功映射后的地址，不成功返回MAP_FAILED ((void*)-1)</code></p><p><code>int</code> <code>munmap(``void</code> <code>*addr, ``size_t</code> <code>length);``// 断开映射</code></p><p><code>//addr 为映射后的地址，length 为映射后的内存长度</code></p><p><strong>（8）开始采集视频 (在缓冲区处理好之后就可以获得视频了 )</strong> 在开始之前，还应当把缓冲帧放入缓冲队列，应用程序和设备有三种交换数据的方法，直接 <strong>read/write</strong>、<strong>内存映射(memory mapping)和用户指针</strong>。这里只讨论内存映射(memory mapping)。</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p><code>//把四个缓冲帧放入队列</code></p><p><code>for</code> <code>(i = 0; i &lt; CAP_BUF_NUM; i++)</code></p><p><code>{</code></p><p><code>memset``(&buf, 0, ``sizeof``(buf));</code></p><p><code>buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</code></p><p><code>buf.memory = V4L2_MEMORY_MMAP;</code></p><p><code>buf.index = i;</code></p><p><code>buf.m.offset = dev->buffer[i].offset;</code></p><p><code>/* 将空闲的内存加入可捕获视频的队列 */</code></p><p><code>if``(ioctl(dev->fd, VIDIOC_QBUF, &buf) &lt; 0)</code></p><p><code>{</code></p><p><code>printf``(``"ERROR: VIDIOC_QBUF[%s], FUNC[%s], LINE[%d]\n"``, dev->dev, __FUNCTION__, __LINE__);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p><code>}</code></p><p><code>type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</code></p><p><code>/* 打开设备视频流 */</code></p><p><code>if``(ioctl(dev->fd, VIDIOC_STREAMON, &type) &lt; 0)</code></p><p><code>{</code></p><p><code>printf``(``"ERROR: VIDIOC_STREAMON[%s], FUNC[%s], LINE[%d]\n"``, dev->dev, __FUNCTION__, __LINE__);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p>前期初始化完成后，只是解决了一帧视频数据的格式和大小问题，而连续视频帧数据的采集需要用帧缓冲区队列的方式来解决，即要通过驱动程序在内存中申请几个帧缓冲区来存放视频数据。 应用程序通过API接口提供的方法(VIDIOC_REQBUFS)申请若干个视频数据的帧缓冲区，申请帧缓冲区数量一般不低于3个，每个帧缓冲区存放一帧视频数据，这些帧缓冲区在内核空间。 应用程序通过API接口提供的查询方法(VIDIOC_QUERYBUF)查询到帧缓冲区在内核空间的长度和偏移量地址。 应用程序再通过内存映射方法(mmap)，将申请到的内核空间帧缓冲区的地址映射到用户空间地址，这样就可以直接处理帧缓冲区的数据。 (1)将帧缓冲区在视频输入队列排队，并启动视频采集 在驱动程序处理视频的过程中，定义了两个队列：视频采集输入队列(incoming queues)和视频采集输出队列(outgoing queues)，前者是等待驱动存放视频数据的队列，后者是驱动程序已经放入了视频数据的队列。如图2所示。 应用程序需要将上述帧缓冲区在视频采集输入队列排队(VIDIOC_QBUF)，然后可启动视频采集。 (2)循环往复，采集连续的视频数据 启动视频采集后，驱动程序开始采集一帧数据，把采集的数据放入视频采集输入队列的第一个帧缓冲区，一帧数据采集完成，也就是第一个帧缓冲区存满一帧数据后，驱动程序将该帧缓冲区移至视频采集输出队列，等待应用程序从输出队列取出。驱动程序接下来采集下一帧数据，放入第二个帧缓冲区，同样帧缓冲区存满下一帧数据后，被放入视频采集输出队列。 应用程序从视频采集输出队列中取出含有视频数据的帧缓冲区，处理帧缓冲区中的视频数据，如存储或压缩。 最后，应用程序将处理完数据的帧缓冲区重新放入视频采集输入队列,这样可以循环采集，如图1所示。 <img src=http://www.xiangb.com/vga/UploadFiles_6698/201102/20110215120200245.jpg alt> <strong>（9）取出FIFO缓存中已经采样的帧缓存</strong></p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p><code>struct</code> <code>v4l2_buffer capture_buf；</code></p><p><code>memset``(&capture_buf, 0, ``sizeof``(capture_buf));</code></p><p><code>capture_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</code></p><p><code>capture_buf.memory = V4L2_MEMORY_MMAP;</code></p><p><code>/* 将已经捕获好视频的内存拉出已捕获视频的队列 */</code></p><p><code>if</code> <code>(ioctl(dev.fd, VIDIOC_DQBUF, &capture_buf) &lt; 0)</code></p><p><code>{</code></p><p><code>printf``(``"ERROR: VIDIOC_DQBUF[%s], FUNC[%s], LINE[%d]\n"``, dev, __FUNCTION__, __LINE__);</code></p><p><code>return</code> <code>TFAIL;</code></p><p><code>}</code></p><p><code>}</code></p><p><code>image_data_handle(buffer[capture_buf.index].start, capture_buf.bytesused);</code></p><p><strong>（10）将刚刚处理完的缓冲重新入队列尾，这样可以循环采集</strong> if (ioctl(fd, VIDIOC_QBUF, &buf) == -1) { return -1; } <strong>（11）停止视频的采集，解除映射</strong> int ret = ioctl(fd, VIDIOC_STREAMOFF, &buf_type);```
　　munmap(buffer[j].start, buffer[j].length);</p><pre><code class=language-**（12）关闭视频设备** data-lang=**（12）关闭视频设备**>
　　设置视频的帧率，使用ioctl(fd\_v4l, VIDIOC\_S\_PARM, &amp;parm)

　　设置视频的旋转方式，使用ioctl(fd\_v4l, VIDIOC\_S\_CTRL, &amp;ctrl)

　　(4)向驱动申请视频流数据的帧缓冲区

　　请求/申请若干个帧缓冲区，一般为不少于3个,使用ioctl(fd\_v4l, VIDIOC\_REQBUFS, &amp;req)

　　查询帧缓冲区在内核空间中的长度和偏移量 ioctl(fd\_v4l, VIDIOC\_QUERYBUF, &amp;buf)

　　(5)应用程序通过内存映射，将帧缓冲区的地址映射到用户空间，这样就可以直接操作采集到的帧了，而不必去复制。 buffers\[i\].start = mmap (NULL, buffers\[i\].length, PROT\_READ | PROT\_WRITE, MAP\_SHARED, fd\_v4l, buffers\[i\].offset); (6)将申请到的帧缓冲全部放入视频采集输出队列，以便存放采集的数据。ioctl (fd\_v4l, VIDIOC\_QBUF, &amp;buf) (7)开始视频流数据的采集。 ioctl (fd\_v4l, VIDIOC\_STREAMON, &amp;type) (8) 驱动将采集到的一帧视频数据存入输入队列第一个帧缓冲区，存完后将该帧缓冲区移至视频采集输出队列。 (9)应用程序从视频采集输出队列中取出已含有采集数据的帧缓冲区。ioctl (fd\_v4l, VIDIOC\_DQBUF, &amp;buf) ，应用程序处理该帧缓冲区的原始视频数据。 (10)处理完后，应用程序的将该帧缓冲区重新排入输入队列,这样便可以循环采集数据。ioctl (fd\_v4l, VIDIOC\_QBUF, &amp;buf) 重复上述步骤8到10，直到停止采集数据。 (11)停止视频的采集。ioctl (fd\_v4l, VIDIOC\_STREAMOFF, &amp;type) (12)释放申请的视频帧缓冲区unmap，关闭视频设备文件close(fd\_v4l)。 以上的程序流程，包含了视频设备采集连续的视频数据的逻辑关系。而在实际运用中，往往还要加入对视频数据进行处理(如压缩编码)的工作，否则，视频流数据量相当大，需要很大的存储空间和传输带宽。</code></pre><hr width=100% id=EOF><p style=color:#777></p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/rockchip-linux-sdk-buildroot%e4%bd%bf%e7%94%a8%e8%ae%b0%e5%bd%95/><br>Rockchip linux sdk buildroot使用记录</a>
<a class=older-posts href=/posts/after-upgrade-to-fedora-28-cannot-set-locale/><br>After upgrade to Fedora 28 cannot set locale</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer><a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> <a href=https://amazingrise.net>Rise</a><br><a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
This is a customized copyright.</div></div><script>let app;app=new Vue({el:'#app',data:{scrollY:0,navOpacity:0,isDrawerOpen:false,mounted:false,isDarkMode:false},methods:{sgn(t,x){let k=1./(1.-2*t);if(x<=t)return 0;else if(x>=1-t)return 1;else{return k*(x-t);}},handleScroll(){this.scrollY=window.scrollY;this.navOpacity=this.sgn(.0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*0.8))));const{navBar,navBackground,navTitle,extraContainer,streamContainer}=this.$refs;if(this.navOpacity>=1){navBackground.style.opacity=1;navTitle.style.opacity=1;}else{navBackground.style.opacity=0;navTitle.style.opacity=0;}},handleResize(){const{navBar,navBackground,navTitle,extraContainer,streamContainer}=this.$refs;extraContainer.style.left=(streamContainer.offsetWidth-extraContainer.offsetWidth)+'px';},navBarHeight(){return this.$refs.navBar.offsetHeight;},pageHeadHeight(){return this.$refs.pageHead.offsetHeight;},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen;document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset';},closeDrawer(){this.isDrawerOpen=false;document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset';},toggleDarkMode(){this.isDarkMode=!this.isDarkMode;if(this.isDarkMode==true){document.cookie="night=1;path=/";document.body.classList.add("night");}else{document.cookie="night=0;path=/";document.body.classList.remove("night");}}},created(){window.addEventListener('scroll',this.handleScroll);window.addEventListener('resize',this.handleResize);window._nonDesktop=function(){let check=false;(function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check=true;})(navigator.userAgent||navigator.vendor||window.opera);return check;};var night=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/,"$1");if(night==""){if(window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches){}}else{if(night=="1"){this.toggleDarkMode();}}},mounted(){this.handleScroll();this.handleResize();this.mounted=true;},destroyed(){window.removeEventListener('scroll',this.handleScroll);window.removeEventListener('resize',this.handleResize);}});</script><script src=//js/journal.js></script></body></html>